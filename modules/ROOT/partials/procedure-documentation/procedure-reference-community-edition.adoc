[[community-edition-procedure-reference]]
.Community Edition procedures
[options=header, cols="20a,40a,30m,10m"]
|===
|Name
|Description
|Signature
|Mode|db.awaitIndex() |Wait for an index to come online (for example: CALL db.awaitIndex(":Person(name)")). |db.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID |READ
|db.awaitIndexes() |Wait for all indexes to come online (for example: CALL db.awaitIndexes("500")). |db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID |READ
|db.constraints() |List all constraints in the database. |db.constraints() :: (description :: STRING?) |READ
|db.createIndex() |Create a schema index with specified index provider (for example: CALL db.createIndex(":Person(name)", "lucene+native-2.0")) - YIELD index, providerName, status |db.createIndex(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?) |SCHEMA
|db.createLabel() |Create a label |db.createLabel(newLabel :: STRING?) :: VOID |WRITE
|db.createProperty() |Create a Property |db.createProperty(newProperty :: STRING?) :: VOID |WRITE
|db.createRelationshipType() |Create a RelationshipType |db.createRelationshipType(newRelationshipType :: STRING?) :: VOID |WRITE
|db.createUniquePropertyConstraint() |Create a unique property constraint with index backed by specified index provider (for example: CALL db.createUniquePropertyConstraint(":Person(name)", "lucene+native-2.0")) - YIELD index, providerName, status |db.createUniquePropertyConstraint(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?) |SCHEMA
|db.index.explicit.addNode() |Add a node to an explicit index based on a specified key and value |db.index.explicit.addNode(indexName :: STRING?, node :: NODE?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?) |WRITE
|db.index.explicit.addRelationship() |Add a relationship to an explicit index based on a specified key and value |db.index.explicit.addRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?) |WRITE
|db.index.explicit.auto.searchNodes() |Search nodes in explicit automatic index. Replaces `START n=node:node_auto_index('key:foo*')` |db.index.explicit.auto.searchNodes(query :: ANY?) :: (node :: NODE?, weight :: FLOAT?) |READ
|db.index.explicit.auto.searchRelationships() |Search relationship in explicit automatic index. Replaces `START r=relationship:relationship_auto_index('key:foo*')` |db.index.explicit.auto.searchRelationships(query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?) |READ
|db.index.explicit.auto.seekNodes() |Get node from explicit automatic index. Replaces `START n=node:node_auto_index(key = 'A')` |db.index.explicit.auto.seekNodes(key :: STRING?, value :: ANY?) :: (node :: NODE?) |READ
|db.index.explicit.auto.seekRelationships() |Get relationship from explicit automatic index. Replaces `START r=relationship:relationship_auto_index(key = 'A')` |db.index.explicit.auto.seekRelationships(key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?) |READ
|db.index.explicit.drop() |Remove an explicit index - YIELD type,name,config |db.index.explicit.drop(indexName :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?) |WRITE
|db.index.explicit.existsForNodes() |Check if a node explicit index exists |db.index.explicit.existsForNodes(indexName :: STRING?) :: (success :: BOOLEAN?) |READ
|db.index.explicit.existsForRelationships() |Check if a relationship explicit index exists |db.index.explicit.existsForRelationships(indexName :: STRING?) :: (success :: BOOLEAN?) |READ
|db.index.explicit.forNodes() |Get or create a node explicit index - YIELD type,name,config |db.index.explicit.forNodes(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?) |WRITE
|db.index.explicit.forRelationships() |Get or create a relationship explicit index - YIELD type,name,config |db.index.explicit.forRelationships(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?) |WRITE
|db.index.explicit.list() |List all explicit indexes - YIELD type,name,config |db.index.explicit.list() :: (type :: STRING?, name :: STRING?, config :: MAP?) |READ
|db.index.explicit.removeNode() |Remove a node from an explicit index with an optional key |db.index.explicit.removeNode(indexName :: STRING?, node :: NODE?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?) |WRITE
|db.index.explicit.removeRelationship() |Remove a relationship from an explicit index with an optional key |db.index.explicit.removeRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?) |WRITE
|db.index.explicit.searchNodes() |Search nodes in explicit index. Replaces `START n=node:nodes('key:foo*')` |db.index.explicit.searchNodes(indexName :: STRING?, query :: ANY?) :: (node :: NODE?, weight :: FLOAT?) |READ
|db.index.explicit.searchRelationships() |Search relationship in explicit index. Replaces `START r=relationship:relIndex('key:foo*')` |db.index.explicit.searchRelationships(indexName :: STRING?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?) |READ
|db.index.explicit.searchRelationshipsBetween() |Search relationship in explicit index, starting at the node 'in' and ending at 'out'. |db.index.explicit.searchRelationshipsBetween(indexName :: STRING?, in :: NODE?, out :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?) |READ
|db.index.explicit.searchRelationshipsIn() |Search relationship in explicit index, starting at the node 'in'. |db.index.explicit.searchRelationshipsIn(indexName :: STRING?, in :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?) |READ
|db.index.explicit.searchRelationshipsOut() |Search relationship in explicit index, ending at the node 'out'. |db.index.explicit.searchRelationshipsOut(indexName :: STRING?, out :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?) |READ
|db.index.explicit.seekNodes() |Get node from explicit index. Replaces `START n=node:nodes(key = 'A')` |db.index.explicit.seekNodes(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (node :: NODE?) |READ
|db.index.explicit.seekRelationships() |Get relationship from explicit index. Replaces `START r=relationship:relIndex(key = 'A')` |db.index.explicit.seekRelationships(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?) |READ
|db.index.fulltext.awaitEventuallyConsistentIndexRefresh() |Wait for the updates from recently committed transactions to be applied to any eventually-consistent fulltext indexes. |db.index.fulltext.awaitEventuallyConsistentIndexRefresh() :: VOID |READ
|db.index.fulltext.awaitIndex() |Similar to db.awaitIndex(index, timeout), except instead of an index pattern, the index is specified by name. The name can be quoted by backticks, if necessary. |db.index.fulltext.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID |READ
|db.index.fulltext.createNodeIndex() |Create a node fulltext index for the given labels and properties. The optional 'config' map parameter can be used to supply settings to the index. Note: index specific settings are currently experimental, and might not replicated correctly in a cluster, or during backup. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread. |db.index.fulltext.createNodeIndex(indexName :: STRING?, labels :: LIST? OF STRING?, propertyNames :: LIST? OF STRING?, config = {} :: MAP?) :: VOID |SCHEMA
|db.index.fulltext.createRelationshipIndex() |Create a relationship fulltext index for the given relationship types and properties. The optional 'config' map parameter can be used to supply settings to the index. Note: index specific settings are currently experimental, and might not replicated correctly in a cluster, or during backup. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread. |db.index.fulltext.createRelationshipIndex(indexName :: STRING?, relationshipTypes :: LIST? OF STRING?, propertyNames :: LIST? OF STRING?, config = {} :: MAP?) :: VOID |SCHEMA
|db.index.fulltext.drop() |Drop the specified index. |db.index.fulltext.drop(indexName :: STRING?) :: VOID |SCHEMA
|db.index.fulltext.listAvailableAnalyzers() |List the available analyzers that the fulltext indexes can be configured with. |db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING?, description :: STRING?) |READ
|db.index.fulltext.queryNodes() |Query the given fulltext index. Returns the matching nodes and their lucene query score, ordered by score. |db.index.fulltext.queryNodes(indexName :: STRING?, queryString :: STRING?) :: (node :: NODE?, score :: FLOAT?) |READ
|db.index.fulltext.queryRelationships() |Query the given fulltext index. Returns the matching relationships and their lucene query score, ordered by score. |db.index.fulltext.queryRelationships(indexName :: STRING?, queryString :: STRING?) :: (relationship :: RELATIONSHIP?, score :: FLOAT?) |READ
|db.indexes() |List all indexes in the database. |db.indexes() :: (description :: STRING?, indexName :: STRING?, tokenNames :: LIST? OF STRING?, properties :: LIST? OF STRING?, state :: STRING?, type :: STRING?, progress :: FLOAT?, provider :: MAP?, id :: INTEGER?, failureMessage :: STRING?) |READ
|db.labels() |List all labels in the database. |db.labels() :: (label :: STRING?) |READ
|db.propertyKeys() |List all property keys in the database. |db.propertyKeys() :: (propertyKey :: STRING?) |READ
|db.relationshipTypes() |List all relationship types in the database. |db.relationshipTypes() :: (relationshipType :: STRING?) |READ
|db.resampleIndex() |Schedule resampling of an index (for example: CALL db.resampleIndex(":Person(name)")). |db.resampleIndex(index :: STRING?) :: VOID |READ
|db.resampleOutdatedIndexes() |Schedule resampling of all outdated indexes. |db.resampleOutdatedIndexes() :: VOID |READ
|db.schema() |Show the schema of the data. |db.schema() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?) |READ
|db.schema.nodeTypeProperties() |Show the derived property schema of the nodes in tabular form. |db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?) |READ
|db.schema.relTypeProperties() |Show the derived property schema of the relationships in tabular form. |db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?) |READ
|db.schema.visualization() |Visualize the schema of the data. Replaces db.schema. |db.schema.visualization() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?) |READ
|db.stats.clear() |Clear collected data of a given data section. Valid sections are 'QUERIES' |db.stats.clear(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ
|db.stats.collect() |Start data collection of a given data section. Valid sections are 'QUERIES' |db.stats.collect(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ
|db.stats.retrieve() |Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META' |db.stats.retrieve(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?) |READ
|db.stats.retrieveAllAnonymized() |Retrieve all available statistical data about the current database, in an anonymized form. |db.stats.retrieveAllAnonymized(graphToken :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?) |READ
|db.stats.status() |Retrieve the status of all available collector daemons, for this database. |db.stats.status() :: (section :: STRING?, status :: STRING?, data :: MAP?) |READ
|db.stats.stop() |Stop data collection of a given data section. Valid sections are 'QUERIES' |db.stats.stop(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ
|dbms.changePassword() |Change the current user's password. Deprecated by dbms.security.changePassword. |dbms.changePassword(password :: STRING?) :: VOID |DBMS
|dbms.clearQueryCaches() |Clears all query caches. |dbms.clearQueryCaches() :: (value :: STRING?) |DBMS
|dbms.components() |List DBMS components and their versions. |dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?) |DBMS
|dbms.functions() |List all user functions in the DBMS. |dbms.functions() :: (name :: STRING?, signature :: STRING?, description :: STRING?) |DBMS
|dbms.listConfig() |List the currently active config of Neo4j. |dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?) |DBMS
|dbms.procedures() |List all procedures in the DBMS. |dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, mode :: STRING?) |DBMS
|dbms.queryJmx() |Query JMX management data by domain and name. For instance, "org.neo4j:*" |dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?) |DBMS
|dbms.security.changePassword() |Change the current user's password. |dbms.security.changePassword(password :: STRING?) :: VOID |DBMS
|dbms.security.createUser() |Create a new user. |dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID |DBMS
|dbms.security.deleteUser() |Delete the specified user. |dbms.security.deleteUser(username :: STRING?) :: VOID |DBMS
|dbms.security.listUsers() |List all native users. |dbms.security.listUsers() :: (username :: STRING?, flags :: LIST? OF STRING?) |DBMS
|dbms.security.showCurrentUser() |Show the current user. Deprecated by dbms.showCurrentUser. |dbms.security.showCurrentUser() :: (username :: STRING?, flags :: LIST? OF STRING?) |DBMS
|dbms.showCurrentUser() |Show the current user. |dbms.showCurrentUser() :: (username :: STRING?, flags :: LIST? OF STRING?) |DBMS
|===
