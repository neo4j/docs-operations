[[complete-procedure-reference]]
.Complete procedure reference
[options=header, cols="a,a,m,m,a"]
|===
|Name
|Description
|Signature
|Mode|[enterprise-edition]#Roles#
|db.awaitIndex() |Wait for an index to come online (for example: CALL db.awaitIndex("MyIndex", 300)). |db.awaitIndex(indexName :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.awaitIndexes() |Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)). |db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.clearQueryCaches() |Clears all query caches. |db.clearQueryCaches() :: (value :: STRING?) |DBMS |[enterprise-edition]#admin#
|db.constraints() |List all constraints in the database. |db.constraints() :: (name :: STRING?, description :: STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.createIndex() |Create a named schema index with specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status |db.createIndex(indexName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, status :: STRING?) |SCHEMA |[enterprise-edition]#architect, admin#
|db.createLabel() |Create a label |db.createLabel(newLabel :: STRING?) :: VOID |WRITE |[enterprise-edition]#publisher, architect, admin#
|db.createProperty() |Create a Property |db.createProperty(newProperty :: STRING?) :: VOID |WRITE |[enterprise-edition]#publisher, architect, admin#
|db.createRelationshipType() |Create a RelationshipType |db.createRelationshipType(newRelationshipType :: STRING?) :: VOID |WRITE |[enterprise-edition]#publisher, architect, admin#
|db.createUniquePropertyConstraint() |Create a named unique property constraint. Backing index will use specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status |db.createUniquePropertyConstraint(constraintName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, status :: STRING?) |SCHEMA |[enterprise-edition]#architect, admin#
|db.index.fulltext.awaitEventuallyConsistentIndexRefresh() |Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes. |db.index.fulltext.awaitEventuallyConsistentIndexRefresh() :: VOID |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.index.fulltext.createNodeIndex() |Create a node full-text index for the given labels and properties. The optional 'config' map parameter can be used to supply settings to the index. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread. |db.index.fulltext.createNodeIndex(indexName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, config = {} :: MAP?) :: VOID |SCHEMA |[enterprise-edition]#architect, admin#
|db.index.fulltext.createRelationshipIndex() |Create a relationship full-text index for the given relationship types and properties. The optional 'config' map parameter can be used to supply settings to the index. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread. |db.index.fulltext.createRelationshipIndex(indexName :: STRING?, relationshipTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, config = {} :: MAP?) :: VOID |SCHEMA |[enterprise-edition]#architect, admin#
|db.index.fulltext.drop() |Drop the specified index. |db.index.fulltext.drop(indexName :: STRING?) :: VOID |SCHEMA |[enterprise-edition]#architect, admin#
|db.index.fulltext.listAvailableAnalyzers() |List the available analyzers that the full-text indexes can be configured with. |db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING?, description :: STRING?, stopwords :: LIST? OF STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.index.fulltext.queryNodes() |Query the given full-text index. Returns the matching nodes and their Lucene query score, ordered by score. |db.index.fulltext.queryNodes(indexName :: STRING?, queryString :: STRING?) :: (node :: NODE?, score :: FLOAT?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.index.fulltext.queryRelationships() |Query the given full-text index. Returns the matching relationships and their Lucene query score, ordered by score. |db.index.fulltext.queryRelationships(indexName :: STRING?, queryString :: STRING?) :: (relationship :: RELATIONSHIP?, score :: FLOAT?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.indexDetails() |Detailed description of specific index. |db.indexDetails(indexName :: STRING?) :: (id :: INTEGER?, name :: STRING?, state :: STRING?, populationPercent :: FLOAT?, uniqueness :: STRING?, type :: STRING?, entityType :: STRING?, labelsOrTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, provider :: STRING?, indexConfig :: MAP?, failureMessage :: STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.indexes() |List all indexes in the database. |db.indexes() :: (id :: INTEGER?, name :: STRING?, state :: STRING?, populationPercent :: FLOAT?, uniqueness :: STRING?, type :: STRING?, entityType :: STRING?, labelsOrTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, provider :: STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.info() |Provides information regarding the database. |db.info() :: (id :: STRING?, name :: STRING?, creationDate :: STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.labels() |List all available labels in the database. |db.labels() :: (label :: STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.ping() |This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure. |db.ping() :: (success :: BOOLEAN?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.prepareForReplanning() |Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics. |db.prepareForReplanning(timeOutSeconds = 300 :: INTEGER?) :: VOID |READ |[enterprise-edition]#admin#
|db.propertyKeys() |List all property keys in the database. |db.propertyKeys() :: (propertyKey :: STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.relationshipTypes() |List all available relationship types in the database. |db.relationshipTypes() :: (relationshipType :: STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.resampleIndex() |Schedule resampling of an index (for example: CALL db.resampleIndex("MyIndex")). |db.resampleIndex(indexName :: STRING?) :: VOID |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.resampleOutdatedIndexes() |Schedule resampling of all outdated indexes. |db.resampleOutdatedIndexes() :: VOID |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.schema.nodeTypeProperties() |Show the derived property schema of the nodes in tabular form. |db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.schema.relTypeProperties() |Show the derived property schema of the relationships in tabular form. |db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.schema.visualization() |Visualize the schema of the data. |db.schema.visualization() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.schemaStatements() |List all statements for creating and dropping existing indexes and constraints. |db.schemaStatements() :: (name :: STRING?, type :: STRING?, createStatement :: STRING?, dropStatement :: STRING?) |READ |[enterprise-edition]#reader, editor, publisher, architect, admin#
|db.stats.clear() |Clear collected data of a given data section. Valid sections are 'QUERIES' |db.stats.clear(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ |[enterprise-edition]#admin#
|db.stats.collect() |Start data collection of a given data section. Valid sections are 'QUERIES' |db.stats.collect(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ |[enterprise-edition]#admin#
|db.stats.retrieve() |Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META' |db.stats.retrieve(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?) |READ |[enterprise-edition]#admin#
|db.stats.retrieveAllAnonymized() |Retrieve all available statistical data about the current database, in an anonymized form. |db.stats.retrieveAllAnonymized(graphToken :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?) |READ |[enterprise-edition]#admin#
|db.stats.status() |Retrieve the status of all available collector daemons, for this database. |db.stats.status() :: (section :: STRING?, status :: STRING?, data :: MAP?) |READ |[enterprise-edition]#admin#
|db.stats.stop() |Stop data collection of a given data section. Valid sections are 'QUERIES' |db.stats.stop(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ |[enterprise-edition]#admin#
|dbms.cluster.routing.getRoutingTable() |Returns endpoints of this instance. |dbms.cluster.routing.getRoutingTable(context :: MAP?, database = null :: STRING?) :: (ttl :: INTEGER?, servers :: LIST? OF MAP?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|dbms.components() |List DBMS components and their versions. |dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|dbms.database.state() |The actual status of the database with the provided name on this neo4j instance. |dbms.database.state(databaseName :: STRING?) :: (role :: STRING?, address :: STRING?, status :: STRING?, error :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|dbms.functions() |List all functions in the DBMS. |dbms.functions() :: (name :: STRING?, signature :: STRING?, description :: STRING?, aggregating :: BOOLEAN?, defaultBuiltInRoles :: LIST? OF STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|dbms.info() |Provides information regarding the DBMS. |dbms.info() :: (id :: STRING?, name :: STRING?, creationDate :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|dbms.listConfig() |List the currently active config of Neo4j. |dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?) |DBMS |[enterprise-edition]#admin#
|dbms.procedures() |List all procedures in the DBMS. |dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, mode :: STRING?, defaultBuiltInRoles :: LIST? OF STRING?, worksOnSystem :: BOOLEAN?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|dbms.queryJmx() |Query JMX management data by domain and name. For instance, "*:*" |dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|dbms.routing.getRoutingTable() |Returns endpoints of this instance. |dbms.routing.getRoutingTable(context :: MAP?, database = null :: STRING?) :: (ttl :: INTEGER?, servers :: LIST? OF MAP?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|dbms.security.changePassword() |Change the current user's password. |dbms.security.changePassword(password :: STRING?) :: VOID |DBMS |N/A
|dbms.security.createUser() |Create a new user. |dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID |DBMS |[enterprise-edition]#admin#
|dbms.security.deleteUser() |Delete the specified user. |dbms.security.deleteUser(username :: STRING?) :: VOID |DBMS |[enterprise-edition]#admin#
|dbms.security.listUsers() |List all native users. |dbms.security.listUsers() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?) |DBMS |[enterprise-edition]#admin#
|dbms.showCurrentUser() |Show the current user. |dbms.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|tx.getMetaData() |Provides attached transaction metadata. |tx.getMetaData() :: (metadata :: MAP?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|tx.setMetaData() |Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log. |tx.setMetaData(data :: MAP?) :: VOID |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#db.checkpoint()# |Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `dbms.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load. |db.checkpoint() :: (success :: BOOLEAN?, message :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#db.createNodeKey()# |Create a named node key constraint. Backing index will use specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status |db.createNodeKey(constraintName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, status :: STRING?) |SCHEMA |[enterprise-edition]#architect, admin#
|[enterprise-edition]#db.listLocks()# |List all locks at this database. |db.listLocks() :: (resourceType :: STRING?, resourceId :: INTEGER?, description :: STRING?) |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.killConnection()# |Kill network connection with the given connection id. |dbms.killConnection(id :: STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.killConnections()# |Kill all network connections with the given connection ids. |dbms.killConnections(ids :: LIST? OF STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.killQueries()# |Kill all transactions executing a query with any of the given query ids. |dbms.killQueries(ids :: LIST? OF STRING?) :: (queryId :: STRING?, username :: STRING?, message :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.killQuery()# |Kill all transactions executing the query with the given query id. |dbms.killQuery(id :: STRING?) :: (queryId :: STRING?, username :: STRING?, message :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.killTransaction()# |Kill transaction with provided id. |dbms.killTransaction(id :: STRING?) :: (transactionId :: STRING?, username :: STRING?, message :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.killTransactions()# |Kill transactions with provided ids. |dbms.killTransactions(ids :: LIST? OF STRING?) :: (transactionId :: STRING?, username :: STRING?, message :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.listActiveLocks()# |List the active lock requests granted for the transaction executing the query with the given query id. |dbms.listActiveLocks(queryId :: STRING?) :: (mode :: STRING?, resourceType :: STRING?, resourceId :: INTEGER?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.listConnections()# |List all accepted network connections at this instance that are visible to the user. |dbms.listConnections() :: (connectionId :: STRING?, connectTime :: STRING?, connector :: STRING?, username :: STRING?, userAgent :: STRING?, serverAddress :: STRING?, clientAddress :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.listQueries()# |List all queries currently executing at this instance that are visible to the user. |dbms.listQueries() :: (queryId :: STRING?, username :: STRING?, metaData :: MAP?, query :: STRING?, parameters :: MAP?, planner :: STRING?, runtime :: STRING?, indexes :: LIST? OF MAP?, startTime :: STRING?, protocol :: STRING?, clientAddress :: STRING?, requestUri :: STRING?, status :: STRING?, resourceInformation :: MAP?, activeLockCount :: INTEGER?, elapsedTimeMillis :: INTEGER?, cpuTimeMillis :: INTEGER?, waitTimeMillis :: INTEGER?, idleTimeMillis :: INTEGER?, allocatedBytes :: INTEGER?, pageHits :: INTEGER?, pageFaults :: INTEGER?, connectionId :: STRING?, database :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.listTransactions()# |List all transactions currently executing at this instance that are visible to the user. |dbms.listTransactions() :: (transactionId :: STRING?, username :: STRING?, metaData :: MAP?, startTime :: STRING?, protocol :: STRING?, clientAddress :: STRING?, requestUri :: STRING?, currentQueryId :: STRING?, currentQuery :: STRING?, activeLockCount :: INTEGER?, status :: STRING?, resourceInformation :: MAP?, elapsedTimeMillis :: INTEGER?, cpuTimeMillis :: INTEGER?, waitTimeMillis :: INTEGER?, idleTimeMillis :: INTEGER?, allocatedBytes :: INTEGER?, allocatedDirectBytes :: INTEGER?, pageHits :: INTEGER?, pageFaults :: INTEGER?, connectionId :: STRING?, initializationStackTrace :: STRING?, database :: STRING?) |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.scheduler.groups()# |List the job groups that are active in the database internal job scheduler. |dbms.scheduler.groups() :: (group :: STRING?, threads :: INTEGER?) |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.scheduler.profile()# |Begin profiling all threads within the given job group, for the specified duration. Note that profiling incurs overhead to a system, and will slow it down. |dbms.scheduler.profile(method :: STRING?, group :: STRING?, duration :: STRING?) :: (profile :: STRING?) |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.activateUser()# |Activate a suspended user. |dbms.security.activateUser(username :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.addRoleToUser()# |Assign a role to the user. |dbms.security.addRoleToUser(roleName :: STRING?, username :: STRING?) :: VOID |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.changePassword()# |Change the current user's password. |dbms.security.changePassword(password :: STRING?, requirePasswordChange = false :: BOOLEAN?) :: VOID |DBMS |[enterprise-edition]#reader, editor, publisher, architect, admin#
|[enterprise-edition]#dbms.security.changeUserPassword()# |Change the given user's password. |dbms.security.changeUserPassword(username :: STRING?, newPassword :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.clearAuthCache()# |Clears authentication and authorization cache. |dbms.security.clearAuthCache() :: VOID |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.createRole()# |Create a new role. |dbms.security.createRole(roleName :: STRING?) :: VOID |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.deleteRole()# |Delete the specified role. Any role assignments will be removed. |dbms.security.deleteRole(roleName :: STRING?) :: VOID |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.listRoles()# |List all available roles. |dbms.security.listRoles() :: (role :: STRING?, users :: LIST? OF STRING?) |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.listRolesForUser()# |List all roles assigned to the specified user. |dbms.security.listRolesForUser(username :: STRING?) :: (value :: STRING?) |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.listUsersForRole()# |List all users currently assigned the specified role. |dbms.security.listUsersForRole(roleName :: STRING?) :: (value :: STRING?) |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.removeRoleFromUser()# |Unassign a role from the user. |dbms.security.removeRoleFromUser(roleName :: STRING?, username :: STRING?) :: VOID |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.security.suspendUser()# |Suspend the specified user. |dbms.security.suspendUser(username :: STRING?) :: VOID |DBMS |[enterprise-edition]#admin#
|[enterprise-edition]#dbms.setConfigValue()# |Updates a given setting value. Passing an empty value will result in removing the configured value and falling back to the default value. Changes will not persist and will be lost if the server is restarted. |dbms.setConfigValue(setting :: STRING?, value :: STRING?) :: VOID |DBMS |[enterprise-edition]#admin#
|===
