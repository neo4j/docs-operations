[[enterprise-edition-procedure-reference]]
[role=enterprise-edition]
.Enterprise Edition procedures
[options=header, cols="a,a,m,m,a"]
|===
|Name
|Description
|Signature
|Mode|Roles
|db.awaitIndex() |Wait for an index to come online (for example: CALL db.awaitIndex("MyIndex", 300)). |db.awaitIndex(indexName :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID |READ |PUBLIC, admin
|db.awaitIndexes() |Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)). |db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID |READ |PUBLIC, admin
|db.checkpoint() |Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `db.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load. |db.checkpoint() :: (success :: BOOLEAN?, message :: STRING?) |DBMS |PUBLIC, admin
|db.clearQueryCaches() |Clears all query caches. |db.clearQueryCaches() :: (value :: STRING?) |DBMS |admin
|db.createLabel() |Create a label |db.createLabel(newLabel :: STRING?) :: VOID |WRITE |PUBLIC, admin
|db.createProperty() |Create a Property |db.createProperty(newProperty :: STRING?) :: VOID |WRITE |PUBLIC, admin
|db.createRelationshipType() |Create a RelationshipType |db.createRelationshipType(newRelationshipType :: STRING?) :: VOID |WRITE |PUBLIC, admin
|db.index.fulltext.awaitEventuallyConsistentIndexRefresh() |Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes. |db.index.fulltext.awaitEventuallyConsistentIndexRefresh() :: VOID |READ |PUBLIC, admin
|db.index.fulltext.listAvailableAnalyzers() |List the available analyzers that the full-text indexes can be configured with. |db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING?, description :: STRING?, stopwords :: LIST? OF STRING?) |READ |PUBLIC, admin
|db.index.fulltext.queryNodes() |Query the given full-text index. Returns the matching nodes, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned. |db.index.fulltext.queryNodes(indexName :: STRING?, queryString :: STRING?, options = {} :: MAP?) :: (node :: NODE?, score :: FLOAT?) |READ |PUBLIC, admin
|db.index.fulltext.queryRelationships() |Query the given full-text index. Returns the matching relationships, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned. |db.index.fulltext.queryRelationships(indexName :: STRING?, queryString :: STRING?, options = {} :: MAP?) :: (relationship :: RELATIONSHIP?, score :: FLOAT?) |READ |PUBLIC, admin
|db.info() |Provides information regarding the database. |db.info() :: (id :: STRING?, name :: STRING?, creationDate :: STRING?) |READ |PUBLIC, admin
|db.labels() |List all available labels in the database. |db.labels() :: (label :: STRING?) |READ |PUBLIC, admin
|db.listLocks() |List all locks at this database. |db.listLocks() :: (mode :: STRING?, resourceType :: STRING?, resourceId :: INTEGER?, transactionId :: STRING?) |DBMS |admin
|db.ping() |This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure. |db.ping() :: (success :: BOOLEAN?) |READ |PUBLIC, admin
|db.prepareForReplanning() |Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics. |db.prepareForReplanning(timeOutSeconds = 300 :: INTEGER?) :: VOID |READ |admin
|db.propertyKeys() |List all property keys in the database. |db.propertyKeys() :: (propertyKey :: STRING?) |READ |PUBLIC, admin
|db.relationshipTypes() |List all available relationship types in the database. |db.relationshipTypes() :: (relationshipType :: STRING?) |READ |PUBLIC, admin
|db.resampleIndex() |Schedule resampling of an index (for example: CALL db.resampleIndex("MyIndex")). |db.resampleIndex(indexName :: STRING?) :: VOID |READ |PUBLIC, admin
|db.resampleOutdatedIndexes() |Schedule resampling of all outdated indexes. |db.resampleOutdatedIndexes() :: VOID |READ |PUBLIC, admin
|db.schema.nodeTypeProperties() |Show the derived property schema of the nodes in tabular form. |db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?) |READ |PUBLIC, admin
|db.schema.relTypeProperties() |Show the derived property schema of the relationships in tabular form. |db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?) |READ |PUBLIC, admin
|db.schema.visualization() |Visualizes the schema of the data based on available statistics. A new node is returned for each label. The properties represented on the node include `name` (label name), `indexes` (list of indexes), and `constraints` (list of constraints). A relationship of a given type is returned for all possible combinations of start and end nodes. Note that this may include additional relationships that do not exist in the data due to the information available in the count store. |db.schema.visualization() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?) |READ |PUBLIC, admin
|db.stats.clear() |Clear collected data of a given data section. Valid sections are 'QUERIES' |db.stats.clear(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ |admin
|db.stats.collect() |Start data collection of a given data section. Valid sections are 'QUERIES' |db.stats.collect(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ |admin
|db.stats.retrieve() |Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META' |db.stats.retrieve(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?) |READ |admin
|db.stats.retrieveAllAnonymized() |Retrieve all available statistical data about the current database, in an anonymized form. |db.stats.retrieveAllAnonymized(graphToken :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?) |READ |admin
|db.stats.status() |Retrieve the status of all available collector daemons, for this database. |db.stats.status() :: (section :: STRING?, status :: STRING?, data :: MAP?) |READ |admin
|db.stats.stop() |Stop data collection of a given data section. Valid sections are 'QUERIES' |db.stats.stop(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?) |READ |admin
|dbms.checkConfigValue() |Check if a potential config setting value is valid. |dbms.checkConfigValue(setting :: STRING?, value :: STRING?) :: (valid :: BOOLEAN?, message :: STRING?) |DBMS |admin
|dbms.cluster.checkConnectivity() |Check the connectivity of this instance to other cluster members. Not all ports are relevant to all members. Valid values for 'port-name' are: [CLUSTER, RAFT] |dbms.cluster.checkConnectivity(port-name = null :: STRING?, server = null :: STRING?) :: (serverId :: STRING?, mode-constraint :: STRING?, port-name :: STRING?, port-address :: STRING?, result :: STRING?) |DBMS |admin
|dbms.cluster.cordonServer() |Mark a server in the topology as not suitable for new allocations. It will not force current allocations off the server. This is useful when deallocating databases when you have multiple unavailable servers. |dbms.cluster.cordonServer(server :: STRING?) :: VOID |WRITE |admin
|dbms.cluster.protocols() |Overview of installed protocols |dbms.cluster.protocols() :: (orientation :: STRING?, remoteAddress :: STRING?, applicationProtocol :: STRING?, applicationProtocolVersion :: INTEGER?, modifierProtocols :: STRING?) |DBMS |PUBLIC, admin
|dbms.cluster.readReplicaToggle() |The toggle can pause or resume read replica |dbms.cluster.readReplicaToggle(databaseName :: STRING?, pause :: BOOLEAN?) :: (state :: STRING?) |DBMS |admin
|dbms.cluster.routing.getRoutingTable() |Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example an endpoint may serve read queries, write queries and/or future getRoutingTable requests. |dbms.cluster.routing.getRoutingTable(context :: MAP?, database = null :: STRING?) :: (ttl :: INTEGER?, servers :: LIST? OF MAP?) |DBMS |PUBLIC, admin
|dbms.cluster.uncordonServer() |Remove the cordon on a server, returning it to 'enabled'. |dbms.cluster.uncordonServer(server :: STRING?) :: VOID |WRITE |admin
|dbms.components() |List DBMS components and their versions. |dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?) |DBMS |PUBLIC, admin
|dbms.info() |Provides information regarding the DBMS. |dbms.info() :: (id :: STRING?, name :: STRING?, creationDate :: STRING?) |DBMS |PUBLIC, admin
|dbms.killConnection() |Kill network connection with the given connection id. |dbms.killConnection(id :: STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?) |DBMS |PUBLIC, admin
|dbms.killConnections() |Kill all network connections with the given connection ids. |dbms.killConnections(ids :: LIST? OF STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?) |DBMS |PUBLIC, admin
|dbms.listActiveLocks() |List the active lock requests granted for the transaction executing the query with the given query id. |dbms.listActiveLocks(queryId :: STRING?) :: (mode :: STRING?, resourceType :: STRING?, resourceId :: INTEGER?) |DBMS |PUBLIC, admin
|dbms.listCapabilities() |List capabilities |dbms.listCapabilities() :: (name :: STRING?, description :: STRING?, value :: ANY?) |DBMS |PUBLIC, admin
|dbms.listConfig() |List the currently active config of Neo4j. |dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?, defaultValue :: STRING?, startupValue :: STRING?, explicitlySet :: BOOLEAN?, validValues :: STRING?) |DBMS |admin
|dbms.listConnections() |List all accepted network connections at this instance that are visible to the user. |dbms.listConnections() :: (connectionId :: STRING?, connectTime :: STRING?, connector :: STRING?, username :: STRING?, userAgent :: STRING?, serverAddress :: STRING?, clientAddress :: STRING?) |DBMS |PUBLIC, admin
|dbms.listPools() |List all memory pools, including sub pools, currently registered at this instance that are visible to the user. |dbms.listPools() :: (pool :: STRING?, databaseName :: STRING?, heapMemoryUsed :: STRING?, heapMemoryUsedBytes :: STRING?, nativeMemoryUsed :: STRING?, nativeMemoryUsedBytes :: STRING?, freeMemory :: STRING?, freeMemoryBytes :: STRING?, totalPoolMemory :: STRING?, totalPoolMemoryBytes :: STRING?) |DBMS |PUBLIC, admin
|dbms.quarantineDatabase() |Place a database into quarantine or remove from it. |dbms.quarantineDatabase(databaseName :: STRING?, setStatus :: BOOLEAN?, reason = No reason given :: STRING?) :: (databaseName :: STRING?, quarantined :: BOOLEAN?, result :: STRING?) |DBMS |admin
|dbms.queryJmx() |Query JMX management data by domain and name. For instance, "*:*" |dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?) |DBMS |PUBLIC, admin
|dbms.routing.getRoutingTable() |Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example an endpoint may serve read queries, write queries and/or future getRoutingTable requests. |dbms.routing.getRoutingTable(context :: MAP?, database = null :: STRING?) :: (ttl :: INTEGER?, servers :: LIST? OF MAP?) |DBMS |PUBLIC, admin
|dbms.scheduler.failedJobs() |List failed job runs. There is a limit for amount of historical data. |dbms.scheduler.failedJobs() :: (jobId :: STRING?, group :: STRING?, database :: STRING?, submitter :: STRING?, description :: STRING?, type :: STRING?, submitted :: STRING?, executionStart :: STRING?, failureTime :: STRING?, failureDescription :: STRING?) |DBMS |admin
|dbms.scheduler.groups() |List the job groups that are active in the database internal job scheduler. |dbms.scheduler.groups() :: (group :: STRING?, threads :: INTEGER?) |DBMS |admin
|dbms.scheduler.jobs() |List all jobs that are active in the database internal job scheduler. |dbms.scheduler.jobs() :: (jobId :: STRING?, group :: STRING?, submitted :: STRING?, database :: STRING?, submitter :: STRING?, description :: STRING?, type :: STRING?, scheduledAt :: STRING?, period :: STRING?, state :: STRING?, currentStateDescription :: STRING?) |DBMS |admin
|dbms.security.clearAuthCache() |Clears authentication and authorization cache. |dbms.security.clearAuthCache() :: VOID |DBMS |admin
|dbms.setConfigValue() |Updates a given setting value. Passing an empty value will result in removing the configured value and falling back to the default value. Changes will not persist and will be lost if the server is restarted. |dbms.setConfigValue(setting :: STRING?, value :: STRING?) :: VOID |DBMS |admin
|dbms.setDatabaseAllocator() |With this method you can set the allocator, which is responsible to select servers for hosting databases. |dbms.setDatabaseAllocator(allocator :: STRING?) :: VOID |WRITE |admin
|dbms.setDefaultAllocationNumbers() |With this method you can set the default number of primaries and secondaries. |dbms.setDefaultAllocationNumbers(primaries :: INTEGER?, secondaries :: INTEGER?) :: VOID |WRITE |admin
|dbms.setDefaultDatabase() |Change the default database to the provided value. The database must exist and the old default database must be stopped. |dbms.setDefaultDatabase(databaseName :: STRING?) :: (result :: STRING?) |WRITE |admin
|dbms.showCurrentUser() |Show the current user. |dbms.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?) |DBMS |PUBLIC, admin
|dbms.showTopologyGraphConfig() |With this method the configuration of the Topology Graph can be displayed. |dbms.showTopologyGraphConfig() :: (allocator :: STRING?, defaultPrimariesCount :: INTEGER?, defaultSecondariesCount :: INTEGER?, defaultDatabase :: STRING?) |READ |admin
|dbms.upgrade() |Upgrade the system database schema if it is not the current schema. |dbms.upgrade() :: (status :: STRING?, upgradeResult :: STRING?) |WRITE |admin
|dbms.upgradeStatus() |Report the current status of the system database sub-graph schema. |dbms.upgradeStatus() :: (status :: STRING?, description :: STRING?, resolution :: STRING?) |READ |admin
|tx.getMetaData() |Provides attached transaction metadata. |tx.getMetaData() :: (metadata :: MAP?) |DBMS |PUBLIC, admin
|tx.setMetaData() |Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log. |tx.setMetaData(data :: MAP?) :: VOID |DBMS |PUBLIC, admin
|===
