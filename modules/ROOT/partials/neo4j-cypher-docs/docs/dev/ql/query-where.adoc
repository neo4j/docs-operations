[[query-where]]
= WHERE

[abstract]
--
`WHERE` adds constraints to the patterns in a `MATCH` or `OPTIONAL MATCH` clause or filters the results of a `WITH` clause.
--


* <<where-introduction, Introduction>>
* <<query-where-basic, Basic usage>>
 ** <<boolean-operations, Boolean operations>>
 ** <<filter-on-node-label, Filter on node label>>
 ** <<filter-on-node-property, Filter on node property>>
 ** <<filter-on-relationship-property, Filter on relationship property>>
 ** <<filter-on-dynamic-property, Filter on dynamically-computed property>>
 ** <<property-existence-checking, Property existence checking>>
* <<query-where-string, String matching>>
 ** <<match-string-start, Prefix string search using `STARTS WITH`>>
 ** <<match-string-end, Suffix string search using `ENDS WITH`>>
 ** <<match-string-contains, Substring search using `CONTAINS`>>
 ** <<match-string-negation, String matching negation>>
* <<query-where-regex, Regular expressions>>
 ** <<matching-using-regular-expressions, Matching using regular expressions>>
 ** <<escaping-in-regular-expressions, Escaping in regular expressions>>
 ** <<case-insensitive-regular-expressions, Case-insensitive regular expressions>>
* <<query-where-patterns, Using path patterns in `WHERE`>>
 ** <<filter-on-patterns, Filter on patterns>>
 ** <<filter-on-patterns-using-not, Filter on patterns using `NOT`>>
 ** <<filter-on-patterns-with-properties, Filter on patterns with properties>>
 ** <<filter-on-relationship-type, Filter on relationship type>>
 * <<existential-subqueries, Using existential subqueries in `WHERE`>>
 ** <<existential-subquery-simple-case, Simple existential subquery>>
 ** <<existential-subquery-with-where, Existential subquery with `WHERE` clause>>
 ** <<existential-subquery-nesting, Nesting existential subqueries>>
* <<query-where-lists, Lists>>
 ** <<where-in-operator, `IN` operator>>
* <<missing-properties-and-values, Missing properties and values>>
 ** <<default-to-false-missing-property, Default to `false` if property is missing>>
 ** <<default-to-true-missing-property, Default to `true` if property is missing>>
 ** <<filter-on-null, Filter on `null`>>
* <<query-where-ranges, Using ranges>>
 ** <<simple-range, Simple range>>
 ** <<composite-range, Composite range>>
* <<pattern-element-predicates, Pattern element predicates>>
 ** <<node-pattern-predicates, Node pattern predicates>>
      

[[where-introduction]]
== Introduction

`WHERE` is not a clause in its own right -- rather, it's part of `MATCH`, `OPTIONAL MATCH` and `WITH`.

In the case of `WITH`, `WHERE` simply filters the results.

For `MATCH` and `OPTIONAL MATCH` on the other hand, `WHERE` adds constraints to the patterns described.
_It should not be seen as a filter after the matching is finished._

[IMPORTANT]
====
In the case of multiple `MATCH` / `OPTIONAL MATCH` clauses, the predicate in `WHERE` is always a part of the patterns in the directly preceding `MATCH` / `OPTIONAL MATCH`.
Both results and performance may be impacted if the `WHERE` is put inside the wrong `MATCH` clause.


====

[NOTE]
====
<<administration-indexes-search-performance, Indexes>> may be used to optimize queries using `WHERE` in a variety of cases.


====

The following graph is used for the examples below:

.Graph
["dot", "WHERE-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Swedish, Person|name = \'Andy\'\lage = 36\lbelt = \'white\'\l}"
  ]
  N0 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "HAS_DOG\nsince = 2016\l"
  ]
  N0 -> N2 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "KNOWS\nsince = 1999\l"
  ]
  N0 -> N1 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "KNOWS\nsince = 2012\l"
  ]
  N1 [
    label = "{Person|age = 25\laddress = \'Sweden/Malmo\'\lname = \'Timothy\'\l}"
  ]
  N2 [
    label = "{Person|name = \'Peter\'\lemail = \'peter_n@example.com\'\lage = 35\l}"
  ]
  N2 -> N4 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "HAS_DOG\nsince = 2010\l"
  ]
  N2 -> N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "HAS_DOG\nsince = 2018\l"
  ]
  N3 [
    label = "{Dog|name = \'Andy\'\l}"
  ]
  N4 [
    label = "{Dog|name = \'Fido\'\l}"
  ]
  N4 -> N6 [
    color = "#a40000"
    fontcolor = "#a40000"
    label = "HAS_TOY\n"
  ]
  N5 [
    label = "{Dog|name = \'Ozzy\'\l}"
  ]
  N6 [
    label = "{Toy|name = \'Banana\'\l}"
  ]

----
 

[[query-where-basic]]
== Basic usage

[[boolean-operations]]
=== Boolean operations

You can use the boolean operators `AND`, `OR`, `XOR` and `NOT`.
See <<cypher-working-with-null>> for more information on how this works with `null`.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.name = 'Peter' XOR (n.age < 30 AND n.name = 'Timothy') OR NOT (n.name = 'Timothy' OR n.name = 'Peter')
RETURN
  n.name AS name,
  n.age AS age
ORDER BY name
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+ | +age+
| +"Andy"+ | +36+
| +"Peter"+ | +35+
| +"Timothy"+ | +25+
2+d|Rows: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.name = 'Peter' XOR (n.age < 30 AND n.name = 'Timothy') OR NOT (n.name = 'Timothy' OR n.name = 'Peter')
RETURN
  n.name AS name,
  n.age AS age
ORDER BY name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[filter-on-node-label]]
=== Filter on node label

To filter nodes by label, write a label predicate after the `WHERE` keyword using `WHERE n:foo`.


.Query
[source, cypher]
----
MATCH (n)
WHERE n:Swedish
RETURN n.name, n.age
----

The name and age for the *'Andy'* node will be returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Andy"+ | +36+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n)
WHERE n:Swedish
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[filter-on-node-property]]
=== Filter on node property

To filter on a node property, write your clause after the `WHERE` keyword.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.age < 30
RETURN n.name, n.age
----

The name and age values for the *'Timothy'* node are returned because he is less than 30 years of age.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Timothy"+ | +25+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.age < 30
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[filter-on-relationship-property]]
=== Filter on relationship property

To filter on a relationship property, write your clause after the `WHERE` keyword.


.Query
[source, cypher]
----
MATCH (n:Person)-[k:KNOWS]->(f)
WHERE k.since < 2000
RETURN f.name, f.age, f.email
----

The name, age and email values for the *'Peter'* node are returned because Andy has known him since before 2000.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +f.name+ | +f.age+ | +f.email+
| +"Peter"+ | +35+ | +"peter_n@example.com"+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)-[k:KNOWS]->(f)
WHERE k.since < 2000
RETURN f.name, f.age, f.email
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[filter-on-dynamic-property]]
=== Filter on dynamically-computed node property

To filter on a property using a dynamically computed name, use square bracket syntax.


.Query
[source, cypher]
----
WITH 'AGE' AS propname
MATCH (n:Person)
WHERE n[toLower(propname)] < 30
RETURN n.name, n.age
----

The name and age values for the *'Timothy'* node are returned because he is less than 30 years of age.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Timothy"+ | +25+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
WITH 'AGE' AS propname
MATCH (n:Person)
WHERE n[toLower(propname)] < 30
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[property-existence-checking]]
=== Property existence checking

Use the `IS NOT NULL` predicate to only include nodes or relationships in which a property exists.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.belt IS NOT NULL
RETURN n.name, n.belt
----

The name and belt for the *'Andy'* node are returned because he is the only one with a `belt` property.

[IMPORTANT]
====
The `exists()` function has been deprecated for property existence checking and has been superseded by `IS NOT NULL`.


====

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.belt+
| +"Andy"+ | +"white"+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.belt IS NOT NULL
RETURN n.name, n.belt
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[usage-with-with-clause]]
=== Usage with `WITH`

As `WHERE` is not considered a clause in its own right, its scope is not limited by a `WITH` directly before it.


.Query
[source, cypher]
----
MATCH (n:Person)
WITH n.name as name
WHERE n.age = 25
RETURN name
----

The name for the *'Timothy'* node is returned because the `WHERE` clause still acts as a filter on the `MATCH`.
The `WITH` reduces the scope for the rest of the query moving forward.
In this case 'name' is now the only variable in scope for the `RETURN` clause.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Timothy"+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WITH n.name as name
WHERE n.age = 25
RETURN name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-where-string]]
== String matching

The prefix and suffix of a string can be matched using `STARTS WITH` and `ENDS WITH`.
To undertake a substring search - i.e. match regardless of location within a string - use `CONTAINS`.
The matching is _case-sensitive_.
Attempting to use these operators on values which are not strings will return `null`.

[[match-string-start]]
=== Prefix string search using `STARTS WITH`

The `STARTS WITH` operator is used to perform case-sensitive matching on the beginning of a string.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.name STARTS WITH 'Pet'
RETURN n.name, n.age
----

The name and age for the *'Peter'* node are returned because his name starts with *'Pet'*.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Peter"+ | +35+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.name STARTS WITH 'Pet'
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-string-end]]
=== Suffix string search using `ENDS WITH`

The `ENDS WITH` operator is used to perform case-sensitive matching on the ending of a string.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.name ENDS WITH 'ter'
RETURN n.name, n.age
----

The name and age for the *'Peter'* node are returned because his name ends with *'ter'*.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Peter"+ | +35+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.name ENDS WITH 'ter'
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-string-contains]]
=== Substring search using `CONTAINS`

The `CONTAINS` operator is used to perform case-sensitive matching regardless of location within a string.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.name CONTAINS 'ete'
RETURN n.name, n.age
----

The name and age for the *'Peter'* node are returned because his name contains with *'ete'*.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Peter"+ | +35+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.name CONTAINS 'ete'
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-string-negation]]
=== String matching negation

Use the `NOT` keyword to exclude all matches on given string from your result:


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE NOT n.name ENDS WITH 'y'
RETURN n.name, n.age
----

The name and age for the *'Peter'* node are returned because his name does not end with *'y'*.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Peter"+ | +35+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE NOT n.name ENDS WITH 'y'
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-where-regex]]
== Regular expressions

Cypher supports filtering using regular expressions.
The regular expression syntax is inherited from link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html[the Java regular expressions].
This includes support for flags that change how strings are matched, including case-insensitive `(?i)`, multiline `(?m)` and dotall `(?s)`.
Flags are given at the beginning of the regular expression, for example `MATCH (n) WHERE n.name =~ '(?i)Lon.*' RETURN n` will return nodes with name 'London' or with name 'LonDoN'.

[[matching-using-regular-expressions]]
=== Matching using regular expressions

You can match on regular expressions by using `=~ 'regexp'`, like this:


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.name =~ 'Tim.*'
RETURN n.name, n.age
----

The name and age for the *'Timothy'* node are returned because his name starts with *'Tim'*.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Timothy"+ | +25+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.name =~ 'Tim.*'
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[escaping-in-regular-expressions]]
=== Escaping in regular expressions

Characters like `.` or `*` have special meaning in a regular expression.
To use these as ordinary characters, without special meaning, escape them.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.email =~ '.*\\.com'
RETURN n.name, n.age, n.email
----

The name, age and email for the 'Peter' node are returned because his email ends with '.com'.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +n.name+ | +n.age+ | +n.email+
| +"Peter"+ | +35+ | +"peter_n@example.com"+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.email =~ '.*\\.com'
RETURN n.name, n.age, n.email
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[case-insensitive-regular-expressions]]
=== Case-insensitive regular expressions

By pre-pending a regular expression with `(?i)`, the whole expression becomes case-insensitive.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.name =~ '(?i)AND.*'
RETURN n.name, n.age
----

The name and age for the 'Andy' node are returned because his name starts with 'AND' irrespective of casing.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Andy"+ | +36+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.name =~ '(?i)AND.*'
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-where-patterns]]
== Using path patterns in `WHERE`

[[filter-on-patterns]]
=== Filter on patterns

Patterns are expressions in Cypher, expressions that return a list of paths.
List expressions are also predicates -- an empty list represents `false`, and a non-empty represents `true`.

So, patterns are not only expressions, they are also predicates.
The only limitation to your pattern is that you must be able to express it in a single path.
You cannot use commas between multiple paths like you do in `MATCH`.
You can achieve  the same effect by combining multiple patterns with `AND`.

Note that you cannot introduce new variables here.
Although it might look very similar to the `MATCH` patterns, the `WHERE` clause is all about eliminating matched paths.
`+MATCH (a)-[*]->(b)+` is very different from `+WHERE (a)-[*]->(b)+`.
The first will produce a path for every path it can find between `a` and `b`, whereas the latter will eliminate any matched paths where `a` and `b` do not have a directed relationship chain between them.


.Query
[source, cypher]
----
MATCH
  (timothy:Person {name: 'Timothy'}),
  (other:Person)
WHERE other.name IN ['Andy', 'Peter'] AND (other)-->(timothy)
RETURN other.name, other.age
----

The name and age for nodes that have an outgoing relationship to the *'Timothy'* node are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +other.name+ | +other.age+
| +"Andy"+ | +36+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH
  (timothy:Person {name: 'Timothy'}),
  (other:Person)
WHERE other.name IN ['Andy', 'Peter'] AND (other)-->(timothy)
RETURN other.name, other.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[filter-on-patterns-using-not]]
=== Filter on patterns using `NOT`

The `NOT` operator can be used to exclude a pattern.


.Query
[source, cypher]
----
MATCH
  (person:Person),
  (peter:Person {name: 'Peter'})
WHERE NOT (person)-->(peter)
RETURN person.name, person.age
----

Name and age values for nodes that do not have an outgoing relationship to the *'Peter'* node are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +person.age+
| +"Timothy"+ | +25+
| +"Peter"+ | +35+
2+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH
  (person:Person),
  (peter:Person {name: 'Peter'})
WHERE NOT (person)-->(peter)
RETURN person.name, person.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[filter-on-patterns-with-properties]]
=== Filter on patterns with properties

You can also add properties to your patterns:


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE (n)-[:KNOWS]-({name: 'Timothy'})
RETURN n.name, n.age
----

Finds all name and age values for nodes that have a `KNOWS` relationship to a node with the name *'Timothy'*.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +n.age+
| +"Andy"+ | +36+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE (n)-[:KNOWS]-({name: 'Timothy'})
RETURN n.name, n.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[filter-on-relationship-type]]
=== Filter on relationship type

You can put the exact relationship type in the `MATCH` pattern, but sometimes you want to be able to do more advanced filtering on the type.
You can use the special property `type` to compare the type with something else.
In this example, the query does a regular expression comparison with the name of the relationship type.


.Query
[source, cypher]
----
MATCH (n:Person)-[r]->()
WHERE n.name='Andy' AND type(r) =~ 'K.*'
RETURN type(r), r.since
----

This returns all relationships having a type whose name starts with *'K'*.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +type(r)+ | +r.since+
| +"KNOWS"+ | +1999+
| +"KNOWS"+ | +2012+
2+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)-[r]->()
WHERE n.name='Andy' AND type(r) =~ 'K.*'
RETURN type(r), r.since
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

An existential subquery can be used to find out if a specified pattern exists at least once in the data.
It can be used in the same way as a path pattern but it allows you to use `MATCH` and `WHERE` clauses internally.
A subquery has a scope, as indicated by the opening and closing braces, `{` and `}`.
Any variable that is defined in the outside scope can be referenced inside the subquery's own scope.
Variables introduced inside the subquery are not part of the outside scope and therefore can't be accessed on the outside.
If the subquery evaluates even once to anything that is not null, the whole expression will become true.
This also means that the system only needs to calculate the first occurrence where the subquery evaluates to something that is not null and can skip the rest of the work.


*Syntax:*
[source, cypher, role=noplay]
EXISTS {
  MATCH [Pattern]
  WHERE [Expression]
}




It is worth noting that the `MATCH` keyword can be omitted in subqueries and that the `WHERE` clause is optional.

[[existential-subqueries]]
== Using existential subqueries in `WHERE`

[[existential-subquery-simple-case]]
=== Simple existential subquery

Variables introduced by the outside scope can be used in the inner `MATCH` clause. The following example shows this:


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(:Dog)
}
RETURN person.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
| +"Peter"+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(:Dog)
}
RETURN person.name AS name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[existential-subquery-with-where]]
=== Existential subquery with `WHERE` clause

A `WHERE` clause can be used in conjunction to the `MATCH`.
Variables introduced by the `MATCH` clause and the outside scope can be used in this scope.


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
}
RETURN person.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
}
RETURN person.name AS name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[existential-subquery-nesting]]
=== Nesting existential subqueries

Existential subqueries can be nested like the following example shows.
The nesting also affects the scopes.
That means that it is possible to access all variables from inside the subquery which are either on the outside scope or defined in the very same subquery.


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE EXISTS {
    MATCH (dog)-[:HAS_TOY]->(toy:Toy)
    WHERE toy.name = 'Banana'
  }
}
RETURN person.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE EXISTS {
    MATCH (dog)-[:HAS_TOY]->(toy:Toy)
    WHERE toy.name = 'Banana'
  }
}
RETURN person.name AS name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-where-lists]]
== Lists

[[where-in-operator]]
=== `IN` operator

To check if an element exists in a list, you can use the `IN` operator.


.Query
[source, cypher]
----
MATCH (a:Person)
WHERE a.name IN ['Peter', 'Timothy']
RETURN a.name, a.age
----

This query shows how to check if a property exists in a literal list.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.name+ | +a.age+
| +"Timothy"+ | +25+
| +"Peter"+ | +35+
2+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (a:Person)
WHERE a.name IN ['Peter', 'Timothy']
RETURN a.name, a.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[missing-properties-and-values]]
== Missing properties and values

[[default-to-false-missing-property]]
=== Default to `false` if property is missing

As missing properties evaluate to `null`, the comparison in the example will evaluate to `false` for nodes without the `belt` property.


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.belt = 'white'
RETURN n.name, n.age, n.belt
----

Only the name, age and belt values of nodes with white belts are returned.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +n.name+ | +n.age+ | +n.belt+
| +"Andy"+ | +36+ | +"white"+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.belt = 'white'
RETURN n.name, n.age, n.belt
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[default-to-true-missing-property]]
=== Default to `true` if property is missing

If you want to compare a property on a node or relationship, but only if it exists, you can compare the property against both the value you are looking for and `null`, like:


.Query
[source, cypher]
----
MATCH (n:Person)
WHERE n.belt = 'white' OR n.belt IS NULL
RETURN n.name, n.age, n.belt
ORDER BY n.name
----

This returns all values for all nodes, even those without the belt property.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +n.name+ | +n.age+ | +n.belt+
| +"Andy"+ | +36+ | +"white"+
| +"Peter"+ | +35+ | +<null>+
| +"Timothy"+ | +25+ | +<null>+
3+d|Rows: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (n:Person)
WHERE n.belt = 'white' OR n.belt IS NULL
RETURN n.name, n.age, n.belt
ORDER BY n.name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[filter-on-null]]
=== Filter on `null`

Sometimes you might want to test if a value or a variable is `null`.
This is done just like SQL does it, using `IS NULL`.
Also like SQL, the negative is `IS NOT NULL`, although `NOT(IS NULL x)` also works.


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE person.name = 'Peter' AND person.belt IS NULL
RETURN person.name, person.age, person.belt
----

The name and age values for nodes that have name *'Peter'* but no belt property are returned.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.age+ | +person.belt+
| +"Peter"+ | +35+ | +<null>+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE person.name = 'Peter' AND person.belt IS NULL
RETURN person.name, person.age, person.belt
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-where-ranges]]
== Using ranges

[[simple-range]]
=== Simple range

To check for an element being inside a specific range, use the inequality operators `<`, `\<=`, `>=`, `>`.


.Query
[source, cypher]
----
MATCH (a:Person)
WHERE a.name >= 'Peter'
RETURN a.name, a.age
----

The name and age values of nodes having a name property lexicographically greater than or equal to *'Peter'* are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.name+ | +a.age+
| +"Timothy"+ | +25+
| +"Peter"+ | +35+
2+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (a:Person)
WHERE a.name >= 'Peter'
RETURN a.name, a.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[composite-range]]
=== Composite range

Several inequalities can be used to construct a range.


.Query
[source, cypher]
----
MATCH (a:Person)
WHERE a.name > 'Andy' AND a.name < 'Timothy'
RETURN a.name, a.age
----

The name and age values of nodes having a name property lexicographically between *'Andy'* and *'Timothy'* are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.name+ | +a.age+
| +"Peter"+ | +35+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (a:Person)
WHERE a.name > 'Andy' AND a.name < 'Timothy'
RETURN a.name, a.age
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[pattern-element-predicates]]
=== Pattern element predicates

[[node-pattern-predicates]]
==== Node pattern predicates

`WHERE` can appear inside a node pattern in a `MATCH` clause or a pattern comprehension:


.Query
[source, cypher]
----
WITH 30 AS minAge
MATCH (a:Person WHERE a.name = 'Andy')-[:KNOWS]->(b:Person WHERE b.age > minAge)
RETURN b.name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +b.name+
| +"Peter"+
1+d|Rows: 1
|===

When used this way, predicates in `WHERE` can reference the node variable that the `WHERE` clause belongs to, but not other elements of the `MATCH` pattern.

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
WITH 30 AS minAge
MATCH (a:Person WHERE a.name = 'Andy')-[:KNOWS]->(b:Person WHERE b.age > minAge)
RETURN b.name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

The same rule applies to pattern comprehensions:


.Query
[source, cypher]
----
MATCH (a:Person {name: 'Andy'})
RETURN [(a)-->(b WHERE b:Person) | b.name] AS friends
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +friends+
| +["Peter","Timothy"]+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (andy:Swedish:Person {name: 'Andy', age: 36, belt: 'white'}),
(timothy:Person {name: 'Timothy', age: 25, address: 'Sweden/Malmo'}),
(peter:Person {name: 'Peter', age: 35, email: 'peter_n@example.com'}),
(andy)-[:KNOWS {since: 2012}]->(timothy),
(andy)-[:KNOWS {since: 1999}]->(peter),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (a:Person {name: 'Andy'})
RETURN [(a)-->(b WHERE b:Person) | b.name] AS friends
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

