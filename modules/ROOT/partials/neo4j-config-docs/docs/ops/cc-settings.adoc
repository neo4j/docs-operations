// tag::settings-reference-causal-clustering-settings[]
[[settings-reference-causal-clustering-settings]]
.Causal Clustering settings
ifndef::nonhtmloutput[]
[options="header"]
|===
|Name|Description
|<<cc-setting_causal_clustering.catch_up_client_inactivity_timeout,causal_clustering.catch_up_client_inactivity_timeout>>|The catch up protocol times out if the given duration elapses with no network activity.
|<<cc-setting_causal_clustering.catchup_batch_size,causal_clustering.catchup_batch_size>>|The maximum batch size when catching up (in unit of entries).
|<<cc-setting_causal_clustering.cluster_allow_reads_on_followers,causal_clustering.cluster_allow_reads_on_followers>>|Configure if the `dbms.routing.getRoutingTable()` procedure should include followers as read endpoints or return only read replicas.
|<<cc-setting_causal_clustering.cluster_allow_reads_on_leader,causal_clustering.cluster_allow_reads_on_leader>>|Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers.
|<<cc-setting_causal_clustering.cluster_binding_timeout,causal_clustering.cluster_binding_timeout>>|The time allowed for a database on a Neo4j server to either join a cluster or form a new cluster with the other Neo4j Core Servers provided by `causal_clustering.initial_discovery_members`.
|<<cc-setting_causal_clustering.cluster_topology_refresh,causal_clustering.cluster_topology_refresh>>|Time between scanning the cluster to refresh current server's view of topology.
|<<cc-setting_causal_clustering.command_applier_parallelism,causal_clustering.command_applier_parallelism>>|Limits amount of global threads for applying commands.
|<<cc-setting_causal_clustering.connect_randomly_to_server_group,causal_clustering.connect_randomly_to_server_group>>|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
|<<cc-setting_causal_clustering.delete_store_before_store_copy,causal_clustering.delete_store_before_store_copy>>|Deletes the old store (on cores and replicas) before performing a store copy (instead of deleting it after).
|<<cc-setting_causal_clustering.discovery_advertised_address,causal_clustering.discovery_advertised_address>>|Advertised cluster member discovery management communication.
|<<cc-setting_causal_clustering.discovery_listen_address,causal_clustering.discovery_listen_address>>|Host and port to bind the cluster member discovery management communication.
|<<cc-setting_causal_clustering.discovery_type,causal_clustering.discovery_type>>|Configure the discovery type used for cluster name resolution.
|<<cc-setting_causal_clustering.election_failure_detection_window,causal_clustering.election_failure_detection_window>>|The rate at which leader elections happen.
|<<cc-setting_causal_clustering.enable_pre_voting,causal_clustering.enable_pre_voting>>|Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members).
|<<cc-setting_causal_clustering.global_session_tracker_state_size,causal_clustering.global_session_tracker_state_size>>|The maximum file size before the global session tracker state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.handshake_timeout,causal_clustering.handshake_timeout>>|Time out for protocol negotiation handshake.
|<<cc-setting_causal_clustering.in_flight_cache.max_bytes,causal_clustering.in_flight_cache.max_bytes>>|The maximum number of bytes in the in-flight cache.
|<<cc-setting_causal_clustering.in_flight_cache.max_entries,causal_clustering.in_flight_cache.max_entries>>|The maximum number of entries in the in-flight cache.
|<<cc-setting_causal_clustering.in_flight_cache.type,causal_clustering.in_flight_cache.type>>|Type of in-flight cache.
|<<cc-setting_causal_clustering.initial_discovery_members,causal_clustering.initial_discovery_members>>|A comma-separated list of other members of the cluster to join.
|<<cc-setting_causal_clustering.join_catch_up_max_lag,causal_clustering.join_catch_up_max_lag>>|Maximum amount of lag accepted for a new follower to join the Raft group.
|<<cc-setting_causal_clustering.join_catch_up_timeout,causal_clustering.join_catch_up_timeout>>|Time out for a new member to catch up.
|<<cc-setting_causal_clustering.kubernetes.address,causal_clustering.kubernetes.address>>|Address for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.ca_crt,causal_clustering.kubernetes.ca_crt>>|File location of CA certificate for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.cluster_domain,causal_clustering.kubernetes.cluster_domain>>|Kubernetes cluster domain.
|<<cc-setting_causal_clustering.kubernetes.label_selector,causal_clustering.kubernetes.label_selector>>|LabelSelector for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.namespace,causal_clustering.kubernetes.namespace>>|File location of namespace for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.service_port_name,causal_clustering.kubernetes.service_port_name>>|Service port name for discovery for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.token,causal_clustering.kubernetes.token>>|File location of token for Kubernetes API.
|<<cc-setting_causal_clustering.last_applied_state_size,causal_clustering.last_applied_state_size>>|The maximum file size before the storage file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.leader_election_timeout,causal_clustering.leader_election_timeout>>|This setting is moved and enhanced into causal_clustering.leader_failure_detection_window and causal_clustering.election_failure_detection_window.
|<<cc-setting_causal_clustering.leader_failure_detection_window,causal_clustering.leader_failure_detection_window>>|The time window within which the loss of the leader is detected and the first re-election attempt is held.The window should be significantly larger than typical communication delays to make conflicts unlikely.
|<<cc-setting_causal_clustering.leadership_balancing,causal_clustering.leadership_balancing>>|Which strategy to use when transferring database leaderships around a cluster.
|<<cc-setting_causal_clustering.leadership_priority_group,causal_clustering.leadership_priority_group>>|The name of a server_group whose members should be prioritized as leaders.
|<<cc-setting_causal_clustering.load_balancing.plugin,causal_clustering.load_balancing.plugin>>|The load balancing plugin to use.
|<<cc-setting_causal_clustering.load_balancing.shuffle,causal_clustering.load_balancing.shuffle>>|Enables shuffling of the returned load balancing result.
|<<cc-setting_causal_clustering.log_shipping_max_lag,causal_clustering.log_shipping_max_lag>>|The maximum lag allowed before log shipping pauses (in unit of entries).
|<<cc-setting_causal_clustering.log_shipping_retry_timeout,causal_clustering.log_shipping_retry_timeout>>|Retry time for log shipping to followers after a stall.
|<<cc-setting_causal_clustering.max_raft_channels,causal_clustering.max_raft_channels>>|The maximum number of TCP channels between two nodes to operate the raft protocol.Each database gets allocated one channel, but a single channel can be used by more than one database.
|<<cc-setting_causal_clustering.middleware.logging.level,causal_clustering.middleware.logging.level>>|The level of middleware logging.
|<<cc-setting_causal_clustering.minimum_core_cluster_size_at_formation,causal_clustering.minimum_core_cluster_size_at_formation>>|Minimum number of Core machines initially required to form a cluster.
|<<cc-setting_causal_clustering.minimum_core_cluster_size_at_runtime,causal_clustering.minimum_core_cluster_size_at_runtime>>|The minimum size of the dynamically adjusted voting set (which only core members may be a part of).
|<<cc-setting_causal_clustering.multi_dc_license,causal_clustering.multi_dc_license>>|Enable multi-data center features.
|<<cc-setting_causal_clustering.protocol_implementations.catchup,causal_clustering.protocol_implementations.catchup>>|Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list.
|<<cc-setting_causal_clustering.protocol_implementations.compression,causal_clustering.protocol_implementations.compression>>|Network compression algorithms that this instance will allow in negotiation as a comma-separated list.
|<<cc-setting_causal_clustering.protocol_implementations.raft,causal_clustering.protocol_implementations.raft>>|Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list.
|<<cc-setting_causal_clustering.pull_interval,causal_clustering.pull_interval>>|Interval of pulling updates from cores.
|<<cc-setting_causal_clustering.raft_advertised_address,causal_clustering.raft_advertised_address>>|Advertised hostname/IP address and port for the RAFT server.
|<<cc-setting_causal_clustering.raft_handler_parallelism,causal_clustering.raft_handler_parallelism>>|Limits amount of global threads shared by raft groups for handling bathing of messages and timeout events.
|<<cc-setting_causal_clustering.raft_in_queue_max_batch_bytes,causal_clustering.raft_in_queue_max_batch_bytes>>|Largest batch processed by RAFT in bytes.
|<<cc-setting_causal_clustering.raft_in_queue_max_bytes,causal_clustering.raft_in_queue_max_bytes>>|Maximum number of bytes in the RAFT in-queue.
|<<cc-setting_causal_clustering.raft_listen_address,causal_clustering.raft_listen_address>>|Network interface and port for the RAFT server to listen on.
|<<cc-setting_causal_clustering.raft_log_entry_prefetch_buffer.max_entries,causal_clustering.raft_log_entry_prefetch_buffer.max_entries>>|The maximum number of entries in the raft log entry prefetch buffer.
|<<cc-setting_causal_clustering.raft_log_implementation,causal_clustering.raft_log_implementation>>|RAFT log implementation.
|<<cc-setting_causal_clustering.raft_log_prune_strategy,causal_clustering.raft_log_prune_strategy>>|RAFT log pruning strategy that determines which logs are to be pruned.
|<<cc-setting_causal_clustering.raft_log_pruning_frequency,causal_clustering.raft_log_pruning_frequency>>|RAFT log pruning frequency.
|<<cc-setting_causal_clustering.raft_log_reader_pool_size,causal_clustering.raft_log_reader_pool_size>>|RAFT log reader pool size.
|<<cc-setting_causal_clustering.raft_log_rotation_size,causal_clustering.raft_log_rotation_size>>|RAFT log rotation size.
|<<cc-setting_causal_clustering.raft_membership_state_size,causal_clustering.raft_membership_state_size>>|The maximum file size before the membership state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.raft_term_state_size,causal_clustering.raft_term_state_size>>|The maximum file size before the term state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.raft_vote_state_size,causal_clustering.raft_vote_state_size>>|The maximum file size before the vote state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.refuse_to_be_leader,causal_clustering.refuse_to_be_leader>>|Deprecated, use dbms.databases.default_to_read_only.
|<<cc-setting_causal_clustering.replicated_lease_state_size,causal_clustering.replicated_lease_state_size>>|The maximum file size before the replicated lease state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.replication_leader_await_timeout,causal_clustering.replication_leader_await_timeout>>|The duration for which the replicator will await a new leader.
|<<cc-setting_causal_clustering.replication_retry_timeout_base,causal_clustering.replication_retry_timeout_base>>|The initial timeout until replication is retried.
|<<cc-setting_causal_clustering.replication_retry_timeout_limit,causal_clustering.replication_retry_timeout_limit>>|The upper limit for the exponentially incremented retry timeout.
|<<cc-setting_causal_clustering.server_groups,causal_clustering.server_groups>>|A list of group names for the server used when configuring load balancing and replication policies.
|<<cc-setting_causal_clustering.state_machine_apply_max_batch_size,causal_clustering.state_machine_apply_max_batch_size>>|The maximum number of operations to be batched during applications of operations in the state machines.
|<<cc-setting_causal_clustering.state_machine_flush_window_size,causal_clustering.state_machine_flush_window_size>>|The number of operations to be processed before the state machines flush to disk.
|<<cc-setting_causal_clustering.status_throughput_window,causal_clustering.status_throughput_window>>|Sampling window for throughput estimate reported in the status endpoint.
|<<cc-setting_causal_clustering.store_copy_chunk_size,causal_clustering.store_copy_chunk_size>>|Store copy chunk size.
|<<cc-setting_causal_clustering.store_copy_max_retry_time_per_request,causal_clustering.store_copy_max_retry_time_per_request>>|Maximum retry time per request during store copy.
|<<cc-setting_causal_clustering.store_copy_parallelism,causal_clustering.store_copy_parallelism>>|Limits amount of global threads for store copy.
|<<cc-setting_causal_clustering.transaction_advertised_address,causal_clustering.transaction_advertised_address>>|Advertised hostname/IP address and port for the transaction shipping server.
|<<cc-setting_causal_clustering.transaction_listen_address,causal_clustering.transaction_listen_address>>|Network interface and port for the transaction shipping server to listen on.
|<<cc-setting_causal_clustering.unknown_address_logging_throttle,causal_clustering.unknown_address_logging_throttle>>|Throttle limit for logging unknown cluster member address.
|<<cc-setting_causal_clustering.upstream_selection_strategy,causal_clustering.upstream_selection_strategy>>|An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.
|<<cc-setting_causal_clustering.user_defined_upstream_strategy,causal_clustering.user_defined_upstream_strategy>>|Configuration of a user-defined upstream selection strategy.
|===
endif::nonhtmloutput[]

ifdef::nonhtmloutput[]
* <<cc-setting_causal_clustering.catch_up_client_inactivity_timeout,causal_clustering.catch_up_client_inactivity_timeout>>: The catch up protocol times out if the given duration elapses with no network activity.
* <<cc-setting_causal_clustering.catchup_batch_size,causal_clustering.catchup_batch_size>>: The maximum batch size when catching up (in unit of entries).
* <<cc-setting_causal_clustering.cluster_allow_reads_on_followers,causal_clustering.cluster_allow_reads_on_followers>>: Configure if the `dbms.routing.getRoutingTable()` procedure should include followers as read endpoints or return only read replicas.
* <<cc-setting_causal_clustering.cluster_allow_reads_on_leader,causal_clustering.cluster_allow_reads_on_leader>>: Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers.
* <<cc-setting_causal_clustering.cluster_binding_timeout,causal_clustering.cluster_binding_timeout>>: The time allowed for a database on a Neo4j server to either join a cluster or form a new cluster with the other Neo4j Core Servers provided by `causal_clustering.initial_discovery_members`.
* <<cc-setting_causal_clustering.cluster_topology_refresh,causal_clustering.cluster_topology_refresh>>: Time between scanning the cluster to refresh current server's view of topology.
* <<cc-setting_causal_clustering.command_applier_parallelism,causal_clustering.command_applier_parallelism>>: Limits amount of global threads for applying commands.
* <<cc-setting_causal_clustering.connect_randomly_to_server_group,causal_clustering.connect_randomly_to_server_group>>: Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
* <<cc-setting_causal_clustering.delete_store_before_store_copy,causal_clustering.delete_store_before_store_copy>>: Deletes the old store (on cores and replicas) before performing a store copy (instead of deleting it after).
* <<cc-setting_causal_clustering.discovery_advertised_address,causal_clustering.discovery_advertised_address>>: Advertised cluster member discovery management communication.
* <<cc-setting_causal_clustering.discovery_listen_address,causal_clustering.discovery_listen_address>>: Host and port to bind the cluster member discovery management communication.
* <<cc-setting_causal_clustering.discovery_type,causal_clustering.discovery_type>>: Configure the discovery type used for cluster name resolution.
* <<cc-setting_causal_clustering.election_failure_detection_window,causal_clustering.election_failure_detection_window>>: The rate at which leader elections happen.
* <<cc-setting_causal_clustering.enable_pre_voting,causal_clustering.enable_pre_voting>>: Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members).
* <<cc-setting_causal_clustering.global_session_tracker_state_size,causal_clustering.global_session_tracker_state_size>>: The maximum file size before the global session tracker state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.handshake_timeout,causal_clustering.handshake_timeout>>: Time out for protocol negotiation handshake.
* <<cc-setting_causal_clustering.in_flight_cache.max_bytes,causal_clustering.in_flight_cache.max_bytes>>: The maximum number of bytes in the in-flight cache.
* <<cc-setting_causal_clustering.in_flight_cache.max_entries,causal_clustering.in_flight_cache.max_entries>>: The maximum number of entries in the in-flight cache.
* <<cc-setting_causal_clustering.in_flight_cache.type,causal_clustering.in_flight_cache.type>>: Type of in-flight cache.
* <<cc-setting_causal_clustering.initial_discovery_members,causal_clustering.initial_discovery_members>>: A comma-separated list of other members of the cluster to join.
* <<cc-setting_causal_clustering.join_catch_up_max_lag,causal_clustering.join_catch_up_max_lag>>: Maximum amount of lag accepted for a new follower to join the Raft group.
* <<cc-setting_causal_clustering.join_catch_up_timeout,causal_clustering.join_catch_up_timeout>>: Time out for a new member to catch up.
* <<cc-setting_causal_clustering.kubernetes.address,causal_clustering.kubernetes.address>>: Address for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.ca_crt,causal_clustering.kubernetes.ca_crt>>: File location of CA certificate for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.cluster_domain,causal_clustering.kubernetes.cluster_domain>>: Kubernetes cluster domain.
* <<cc-setting_causal_clustering.kubernetes.label_selector,causal_clustering.kubernetes.label_selector>>: LabelSelector for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.namespace,causal_clustering.kubernetes.namespace>>: File location of namespace for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.service_port_name,causal_clustering.kubernetes.service_port_name>>: Service port name for discovery for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.token,causal_clustering.kubernetes.token>>: File location of token for Kubernetes API.
* <<cc-setting_causal_clustering.last_applied_state_size,causal_clustering.last_applied_state_size>>: The maximum file size before the storage file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.leader_election_timeout,causal_clustering.leader_election_timeout>>: This setting is moved and enhanced into causal_clustering.leader_failure_detection_window and causal_clustering.election_failure_detection_window.
* <<cc-setting_causal_clustering.leader_failure_detection_window,causal_clustering.leader_failure_detection_window>>: The time window within which the loss of the leader is detected and the first re-election attempt is held.The window should be significantly larger than typical communication delays to make conflicts unlikely.
* <<cc-setting_causal_clustering.leadership_balancing,causal_clustering.leadership_balancing>>: Which strategy to use when transferring database leaderships around a cluster.
* <<cc-setting_causal_clustering.leadership_priority_group,causal_clustering.leadership_priority_group>>: The name of a server_group whose members should be prioritized as leaders.
* <<cc-setting_causal_clustering.load_balancing.plugin,causal_clustering.load_balancing.plugin>>: The load balancing plugin to use.
* <<cc-setting_causal_clustering.load_balancing.shuffle,causal_clustering.load_balancing.shuffle>>: Enables shuffling of the returned load balancing result.
* <<cc-setting_causal_clustering.log_shipping_max_lag,causal_clustering.log_shipping_max_lag>>: The maximum lag allowed before log shipping pauses (in unit of entries).
* <<cc-setting_causal_clustering.log_shipping_retry_timeout,causal_clustering.log_shipping_retry_timeout>>: Retry time for log shipping to followers after a stall.
* <<cc-setting_causal_clustering.max_raft_channels,causal_clustering.max_raft_channels>>: The maximum number of TCP channels between two nodes to operate the raft protocol.Each database gets allocated one channel, but a single channel can be used by more than one database.
* <<cc-setting_causal_clustering.middleware.logging.level,causal_clustering.middleware.logging.level>>: The level of middleware logging.
* <<cc-setting_causal_clustering.minimum_core_cluster_size_at_formation,causal_clustering.minimum_core_cluster_size_at_formation>>: Minimum number of Core machines initially required to form a cluster.
* <<cc-setting_causal_clustering.minimum_core_cluster_size_at_runtime,causal_clustering.minimum_core_cluster_size_at_runtime>>: The minimum size of the dynamically adjusted voting set (which only core members may be a part of).
* <<cc-setting_causal_clustering.multi_dc_license,causal_clustering.multi_dc_license>>: Enable multi-data center features.
* <<cc-setting_causal_clustering.protocol_implementations.catchup,causal_clustering.protocol_implementations.catchup>>: Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list.
* <<cc-setting_causal_clustering.protocol_implementations.compression,causal_clustering.protocol_implementations.compression>>: Network compression algorithms that this instance will allow in negotiation as a comma-separated list.
* <<cc-setting_causal_clustering.protocol_implementations.raft,causal_clustering.protocol_implementations.raft>>: Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list.
* <<cc-setting_causal_clustering.pull_interval,causal_clustering.pull_interval>>: Interval of pulling updates from cores.
* <<cc-setting_causal_clustering.raft_advertised_address,causal_clustering.raft_advertised_address>>: Advertised hostname/IP address and port for the RAFT server.
* <<cc-setting_causal_clustering.raft_handler_parallelism,causal_clustering.raft_handler_parallelism>>: Limits amount of global threads shared by raft groups for handling bathing of messages and timeout events.
* <<cc-setting_causal_clustering.raft_in_queue_max_batch_bytes,causal_clustering.raft_in_queue_max_batch_bytes>>: Largest batch processed by RAFT in bytes.
* <<cc-setting_causal_clustering.raft_in_queue_max_bytes,causal_clustering.raft_in_queue_max_bytes>>: Maximum number of bytes in the RAFT in-queue.
* <<cc-setting_causal_clustering.raft_listen_address,causal_clustering.raft_listen_address>>: Network interface and port for the RAFT server to listen on.
* <<cc-setting_causal_clustering.raft_log_entry_prefetch_buffer.max_entries,causal_clustering.raft_log_entry_prefetch_buffer.max_entries>>: The maximum number of entries in the raft log entry prefetch buffer.
* <<cc-setting_causal_clustering.raft_log_implementation,causal_clustering.raft_log_implementation>>: RAFT log implementation.
* <<cc-setting_causal_clustering.raft_log_prune_strategy,causal_clustering.raft_log_prune_strategy>>: RAFT log pruning strategy that determines which logs are to be pruned.
* <<cc-setting_causal_clustering.raft_log_pruning_frequency,causal_clustering.raft_log_pruning_frequency>>: RAFT log pruning frequency.
* <<cc-setting_causal_clustering.raft_log_reader_pool_size,causal_clustering.raft_log_reader_pool_size>>: RAFT log reader pool size.
* <<cc-setting_causal_clustering.raft_log_rotation_size,causal_clustering.raft_log_rotation_size>>: RAFT log rotation size.
* <<cc-setting_causal_clustering.raft_membership_state_size,causal_clustering.raft_membership_state_size>>: The maximum file size before the membership state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.raft_term_state_size,causal_clustering.raft_term_state_size>>: The maximum file size before the term state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.raft_vote_state_size,causal_clustering.raft_vote_state_size>>: The maximum file size before the vote state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.refuse_to_be_leader,causal_clustering.refuse_to_be_leader>>: Deprecated, use dbms.databases.default_to_read_only.
* <<cc-setting_causal_clustering.replicated_lease_state_size,causal_clustering.replicated_lease_state_size>>: The maximum file size before the replicated lease state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.replication_leader_await_timeout,causal_clustering.replication_leader_await_timeout>>: The duration for which the replicator will await a new leader.
* <<cc-setting_causal_clustering.replication_retry_timeout_base,causal_clustering.replication_retry_timeout_base>>: The initial timeout until replication is retried.
* <<cc-setting_causal_clustering.replication_retry_timeout_limit,causal_clustering.replication_retry_timeout_limit>>: The upper limit for the exponentially incremented retry timeout.
* <<cc-setting_causal_clustering.server_groups,causal_clustering.server_groups>>: A list of group names for the server used when configuring load balancing and replication policies.
* <<cc-setting_causal_clustering.state_machine_apply_max_batch_size,causal_clustering.state_machine_apply_max_batch_size>>: The maximum number of operations to be batched during applications of operations in the state machines.
* <<cc-setting_causal_clustering.state_machine_flush_window_size,causal_clustering.state_machine_flush_window_size>>: The number of operations to be processed before the state machines flush to disk.
* <<cc-setting_causal_clustering.status_throughput_window,causal_clustering.status_throughput_window>>: Sampling window for throughput estimate reported in the status endpoint.
* <<cc-setting_causal_clustering.store_copy_chunk_size,causal_clustering.store_copy_chunk_size>>: Store copy chunk size.
* <<cc-setting_causal_clustering.store_copy_max_retry_time_per_request,causal_clustering.store_copy_max_retry_time_per_request>>: Maximum retry time per request during store copy.
* <<cc-setting_causal_clustering.store_copy_parallelism,causal_clustering.store_copy_parallelism>>: Limits amount of global threads for store copy.
* <<cc-setting_causal_clustering.transaction_advertised_address,causal_clustering.transaction_advertised_address>>: Advertised hostname/IP address and port for the transaction shipping server.
* <<cc-setting_causal_clustering.transaction_listen_address,causal_clustering.transaction_listen_address>>: Network interface and port for the transaction shipping server to listen on.
* <<cc-setting_causal_clustering.unknown_address_logging_throttle,causal_clustering.unknown_address_logging_throttle>>: Throttle limit for logging unknown cluster member address.
* <<cc-setting_causal_clustering.upstream_selection_strategy,causal_clustering.upstream_selection_strategy>>: An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.
* <<cc-setting_causal_clustering.user_defined_upstream_strategy,causal_clustering.user_defined_upstream_strategy>>: Configuration of a user-defined upstream selection strategy.
endif::nonhtmloutput[]


// end::settings-reference-causal-clustering-settings[]

[[cc-setting_causal_clustering.catch_up_client_inactivity_timeout]]
.causal_clustering.catch_up_client_inactivity_timeout
[cols="<1s,<4"]
|===
|Description
a|The catch up protocol times out if the given duration elapses with no network activity. Every message received by the client from the server extends the time out duration.
|Valid values
a|causal_clustering.catch_up_client_inactivity_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++10m+++
|===

[[cc-setting_causal_clustering.catchup_batch_size]]
.causal_clustering.catchup_batch_size
[cols="<1s,<4"]
|===
|Description
a|The maximum batch size when catching up (in unit of entries)
|Valid values
a|causal_clustering.catchup_batch_size, an integer
|Default value
m|+++64+++
|===

[[cc-setting_causal_clustering.cluster_allow_reads_on_followers]]
.causal_clustering.cluster_allow_reads_on_followers
[cols="<1s,<4"]
|===
|Description
a|Configure if the `dbms.routing.getRoutingTable()` procedure should include followers as read endpoints or return only read replicas. Note: if there are no read replicas in the cluster, followers are returned as read end points regardless the value of this setting. Defaults to true so that followers are available for read-only queries in a typical heterogeneous setup.
|Valid values
a|causal_clustering.cluster_allow_reads_on_followers, a boolean
|Default value
m|+++true+++
|===

[[cc-setting_causal_clustering.cluster_allow_reads_on_leader]]
.causal_clustering.cluster_allow_reads_on_leader
[cols="<1s,<4"]
|===
|Description
a|Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers. Note: leader is returned as read endpoint if no other member is present all.
|Valid values
a|causal_clustering.cluster_allow_reads_on_leader, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[cc-setting_causal_clustering.cluster_binding_timeout]]
.causal_clustering.cluster_binding_timeout
[cols="<1s,<4"]
|===
|Description
a|The time allowed for a database on a Neo4j server to either join a cluster or form a new cluster with the other Neo4j Core Servers provided by `<<config_causal_clustering.initial_discovery_members,causal_clustering.initial_discovery_members>>`.
|Valid values
a|causal_clustering.cluster_binding_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++10m+++
|===

[[cc-setting_causal_clustering.cluster_topology_refresh]]
.causal_clustering.cluster_topology_refresh
[cols="<1s,<4"]
|===
|Description
a|Time between scanning the cluster to refresh current server's view of topology.
|Valid values
a|causal_clustering.cluster_topology_refresh, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`) which is minimum `1s`
|Default value
m|+++5s+++
|===

[[cc-setting_causal_clustering.command_applier_parallelism]]
.causal_clustering.command_applier_parallelism
[cols="<1s,<4"]
|===
|Description
a|Limits amount of global threads for applying commands.
|Valid values
a|causal_clustering.command_applier_parallelism, an integer which is minimum `1`
|Default value
m|+++8+++
|===

[[cc-setting_causal_clustering.connect_randomly_to_server_group]]
.causal_clustering.connect_randomly_to_server_group
[cols="<1s,<4"]
|===
|Description
a|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`<<config_causal_clustering.upstream_selection_strategy,causal_clustering.upstream_selection_strategy>>`) includes the value `connect-randomly-to-server-group`.
|Valid values
a|causal_clustering.connect_randomly_to_server_group, a ',' separated list with elements of type 'a string identifying a Server Group'.
|Dynamic a|true
|Default value
m|++++++
|===

[[cc-setting_causal_clustering.delete_store_before_store_copy]]
.causal_clustering.delete_store_before_store_copy
[cols="<1s,<4"]
|===
|Description
a|Deletes the old store (on cores and replicas) before performing a store copy (instead of deleting it after).
|Valid values
a|causal_clustering.delete_store_before_store_copy, a boolean
|Default value
m|+++true+++
|===

[[cc-setting_causal_clustering.discovery_advertised_address]]
.causal_clustering.discovery_advertised_address
[cols="<1s,<4"]
|===
|Description
a|Advertised cluster member discovery management communication.
|Valid values
a|causal_clustering.discovery_advertised_address, a socket address in the format 'hostname:port', 'hostname' or ':port'. If missing port or hostname it is acquired from dbms.default_advertised_address
|Default value
m|+++:5000+++
|===

[[cc-setting_causal_clustering.discovery_listen_address]]
.causal_clustering.discovery_listen_address
[cols="<1s,<4"]
|===
|Description
a|Host and port to bind the cluster member discovery management communication.
|Valid values
a|causal_clustering.discovery_listen_address, a socket address in the format 'hostname:port', 'hostname' or ':port'. If missing port or hostname it is acquired from dbms.default_listen_address
|Default value
m|+++:5000+++
|===

[[cc-setting_causal_clustering.discovery_type]]
.causal_clustering.discovery_type
[cols="<1s,<4"]
|===
|Description
a|Configure the discovery type used for cluster name resolution.
|Valid values
a|causal_clustering.discovery_type, one of [DNS, LIST, SRV, K8S] which depends on dbms.mode. If dbms.mode one of `[CORE, READ_REPLICA]` then it may require different settings depending on the discovery type: `DNS requires [causal_clustering.initial_discovery_members], LIST requires [causal_clustering.initial_discovery_members], SRV requires [causal_clustering.initial_discovery_members], K8S requires [causal_clustering.kubernetes.label_selector, causal_clustering.kubernetes.service_port_name]` otherwise it depends on dbms.mode. If dbms.mode one of `[SINGLE]` then it depends on dbms.clustering.enable. If dbms.clustering.enable is `true` then it may require different settings depending on the discovery type: `DNS requires [causal_clustering.initial_discovery_members], LIST requires [causal_clustering.initial_discovery_members], SRV requires [causal_clustering.initial_discovery_members], K8S requires [causal_clustering.kubernetes.label_selector, causal_clustering.kubernetes.service_port_name]` otherwise it is unconstrained. otherwise it is unconstrained..
|Default value
m|+++LIST+++
|===

[[cc-setting_causal_clustering.election_failure_detection_window]]
.causal_clustering.election_failure_detection_window
[cols="<1s,<4"]
|===
|Description
a|The rate at which leader elections happen. Note that due to election conflicts it might take several attempts to find a leader. The window should be significantly larger than typical communication delays to make conflicts unlikely.
|Valid values
a|causal_clustering.election_failure_detection_window, a duration-range <min-max> (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++3s-6s+++
|===

[[cc-setting_causal_clustering.enable_pre_voting]]
.causal_clustering.enable_pre_voting
[cols="<1s,<4"]
|===
|Description
a|Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members)
|Valid values
a|causal_clustering.enable_pre_voting, a boolean
|Default value
m|+++true+++
|===

[[cc-setting_causal_clustering.global_session_tracker_state_size]]
.causal_clustering.global_session_tracker_state_size
[cols="<1s,<4"]
|===
|Description
a|The maximum file size before the global session tracker state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.global_session_tracker_state_size, an integer
|Default value
m|+++1000+++
|===

[[cc-setting_causal_clustering.handshake_timeout]]
.causal_clustering.handshake_timeout
[cols="<1s,<4"]
|===
|Description
a|Time out for protocol negotiation handshake. This configuration is applicable to: `Raft` (communication between `CORE` instances only), `Catchup` (communication between any instances: `CORE` -> `CORE`, `RR` -> `CORE`, `RR` -> `RR`, `CORE` -> `RR`, including `RR` -> `SINGLE` in a replica-only cluster). `Backup` (communication between any instance and a backup client that lives in the `neo4j-admin` command, such as `BackupClient` -> `SINGLE`, `BackupClient` -> `CORE`, `BackupClient` -> `RR`).
|Valid values
a|causal_clustering.handshake_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++20s+++
|===

[[cc-setting_causal_clustering.in_flight_cache.max_bytes]]
.causal_clustering.in_flight_cache.max_bytes
[cols="<1s,<4"]
|===
|Description
a|The maximum number of bytes in the in-flight cache. This parameter limits the amount of memory that can be consumed by cache. If the bytes limit is reached, cache size will be limited even if max_entries is not exceeded.
|Valid values
a|causal_clustering.in_flight_cache.max_bytes, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`)
|Default value
m|+++2.00GiB+++
|===

[[cc-setting_causal_clustering.in_flight_cache.max_entries]]
.causal_clustering.in_flight_cache.max_entries
[cols="<1s,<4"]
|===
|Description
a|The maximum number of entries in the in-flight cache. Increasing size will require more memory but might improve performance in high load situations.
|Valid values
a|causal_clustering.in_flight_cache.max_entries, an integer
|Default value
m|+++1024+++
|===

[[cc-setting_causal_clustering.in_flight_cache.type]]
.causal_clustering.in_flight_cache.type
[cols="<1s,<4"]
|===
|Description
a|Type of in-flight cache. CONSECUTIVE should be used for production instances, NONE will disable cache which might be useful in specific support cases. UNBOUNDED is for internal use only.
|Valid values
a|causal_clustering.in_flight_cache.type, one of [NONE, CONSECUTIVE, UNBOUNDED]
|Default value
m|+++CONSECUTIVE+++
|===

[[cc-setting_causal_clustering.initial_discovery_members]]
.causal_clustering.initial_discovery_members
[cols="<1s,<4"]
|===
|Description
a|A comma-separated list of other members of the cluster to join.
|Valid values
a|causal_clustering.initial_discovery_members, a ',' separated list with elements of type 'a socket address in the format 'hostname:port', 'hostname' or ':port''.
|===

[[cc-setting_causal_clustering.join_catch_up_max_lag]]
.causal_clustering.join_catch_up_max_lag
[cols="<1s,<4"]
|===
|Description
a|Maximum amount of lag accepted for a new follower to join the Raft group.
|Valid values
a|causal_clustering.join_catch_up_max_lag, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++10s+++
|===

[[cc-setting_causal_clustering.join_catch_up_timeout]]
.causal_clustering.join_catch_up_timeout
[cols="<1s,<4"]
|===
|Description
a|Time out for a new member to catch up.
|Valid values
a|causal_clustering.join_catch_up_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++10m+++
|===

[[cc-setting_causal_clustering.kubernetes.address]]
.causal_clustering.kubernetes.address
[cols="<1s,<4"]
|===
|Description
a|Address for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.address, a socket address in the format 'hostname:port', 'hostname' or ':port'
|Default value
m|+++kubernetes.default.svc:443+++
|===

[[cc-setting_causal_clustering.kubernetes.ca_crt]]
.causal_clustering.kubernetes.ca_crt
[cols="<1s,<4"]
|===
|Description
a|File location of CA certificate for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.ca_crt, a path
|Default value
m|+++/var/run/secrets/kubernetes.io/serviceaccount/ca.crt+++
|===

[[cc-setting_causal_clustering.kubernetes.cluster_domain]]
.causal_clustering.kubernetes.cluster_domain
[cols="<1s,<4"]
|===
|Description
a|Kubernetes cluster domain.
|Valid values
a|causal_clustering.kubernetes.cluster_domain, a string
|Default value
m|+++cluster.local+++
|===

[[cc-setting_causal_clustering.kubernetes.label_selector]]
.causal_clustering.kubernetes.label_selector
[cols="<1s,<4"]
|===
|Description
a|LabelSelector for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.label_selector, a string
|===

[[cc-setting_causal_clustering.kubernetes.namespace]]
.causal_clustering.kubernetes.namespace
[cols="<1s,<4"]
|===
|Description
a|File location of namespace for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.namespace, a path
|Default value
m|+++/var/run/secrets/kubernetes.io/serviceaccount/namespace+++
|===

[[cc-setting_causal_clustering.kubernetes.service_port_name]]
.causal_clustering.kubernetes.service_port_name
[cols="<1s,<4"]
|===
|Description
a|Service port name for discovery for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.service_port_name, a string
|===

[[cc-setting_causal_clustering.kubernetes.token]]
.causal_clustering.kubernetes.token
[cols="<1s,<4"]
|===
|Description
a|File location of token for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.token, a path
|Default value
m|+++/var/run/secrets/kubernetes.io/serviceaccount/token+++
|===

[[cc-setting_causal_clustering.last_applied_state_size]]
.causal_clustering.last_applied_state_size
[cols="<1s,<4"]
|===
|Description
a|The maximum file size before the storage file is rotated (in unit of entries)
|Valid values
a|causal_clustering.last_applied_state_size, an integer
|Default value
m|+++1000+++
|===

[[cc-setting_causal_clustering.leader_election_timeout]]
.causal_clustering.leader_election_timeout
[cols="<1s,<4"]
|===
|Description
a|This setting is moved and enhanced into <<config_causal_clustering.leader_failure_detection_window,causal_clustering.leader_failure_detection_window>> and <<config_causal_clustering.election_failure_detection_window,causal_clustering.election_failure_detection_window>>.
|Valid values
a|causal_clustering.leader_election_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++7s+++
|Deprecated
a|The `causal_clustering.leader_election_timeout` configuration setting has been deprecated.
|===

[[cc-setting_causal_clustering.leader_failure_detection_window]]
.causal_clustering.leader_failure_detection_window
[cols="<1s,<4"]
|===
|Description
a|The time window within which the loss of the leader is detected and the first re-election attempt is held.The window should be significantly larger than typical communication delays to make conflicts unlikely.
|Valid values
a|causal_clustering.leader_failure_detection_window, a duration-range <min-max> (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++20s-23s+++
|===

[[cc-setting_causal_clustering.leadership_balancing]]
.causal_clustering.leadership_balancing
[cols="<1s,<4"]
|===
|Description
a|Which strategy to use when transferring database leaderships around a cluster. This can be one of `equal_balancing` or `no_balancing`. `equal_balancing` automatically ensures that each Core server holds the leader role for an equal number of databases.`no_balancing` prevents any automatic balancing of the leader role.Note that if a `leadership_priority_group` is specified for a given database, the value of this setting will be ignored for that database.
|Valid values
a|causal_clustering.leadership_balancing, one of [NO_BALANCING, EQUAL_BALANCING]
|Default value
m|+++EQUAL_BALANCING+++
|===

[[cc-setting_causal_clustering.leadership_priority_group]]
.causal_clustering.leadership_priority_group
[cols="<1s,<4"]
|===
|Description
a|The name of a server_group whose members should be prioritized as leaders. This does not guarantee that members of this group will be leader at all times, but the cluster will attempt to transfer leadership to such a member when possible. If a database is specified using `causal_clustering.leadership_priority_group`.<database> the specified priority group will apply to that database only. If no database is specified that group will be the default and apply to all databases which have no priority group explicitly set. Using this setting will disable leadership balancing.
|Valid values
a|causal_clustering.leadership_priority_group, a string identifying a Server Group
|Default value
m|++++++
|===

[[cc-setting_causal_clustering.load_balancing.plugin]]
.causal_clustering.load_balancing.plugin
[cols="<1s,<4"]
|===
|Description
a|The load balancing plugin to use.
|Valid values
a|causal_clustering.load_balancing.plugin, a string which depends on dbms.mode. If dbms.mode one of `[CORE]` then it specified load balancer plugin exist. otherwise it is unconstrained.
|Default value
m|+++server_policies+++
|===

[[cc-setting_causal_clustering.load_balancing.shuffle]]
.causal_clustering.load_balancing.shuffle
[cols="<1s,<4"]
|===
|Description
a|Enables shuffling of the returned load balancing result.
|Valid values
a|causal_clustering.load_balancing.shuffle, a boolean
|Default value
m|+++true+++
|===

[[cc-setting_causal_clustering.log_shipping_max_lag]]
.causal_clustering.log_shipping_max_lag
[cols="<1s,<4"]
|===
|Description
a|The maximum lag allowed before log shipping pauses (in unit of entries)
|Valid values
a|causal_clustering.log_shipping_max_lag, an integer
|Default value
m|+++256+++
|===

[[cc-setting_causal_clustering.log_shipping_retry_timeout]]
.causal_clustering.log_shipping_retry_timeout
[cols="<1s,<4"]
|===
|Description
a|Retry time for log shipping to followers after a stall.
|Valid values
a|causal_clustering.log_shipping_retry_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++5s+++
|===

[[cc-setting_causal_clustering.max_raft_channels]]
.causal_clustering.max_raft_channels
[cols="<1s,<4"]
|===
|Description
a|The maximum number of TCP channels between two nodes to operate the raft protocol.Each database gets allocated one channel, but a single channel can be used by more than one database.
|Valid values
a|causal_clustering.max_raft_channels, an integer
|Default value
m|+++8+++
|===

[[cc-setting_causal_clustering.middleware.logging.level]]
.causal_clustering.middleware.logging.level
[cols="<1s,<4"]
|===
|Description
a|The level of middleware logging.
|Valid values
a|causal_clustering.middleware.logging.level, one of [DEBUG, INFO, WARN, ERROR, NONE]
|Default value
m|+++WARN+++
|===

[[cc-setting_causal_clustering.minimum_core_cluster_size_at_formation]]
.causal_clustering.minimum_core_cluster_size_at_formation
[cols="<1s,<4"]
|===
|Description
a|Minimum number of Core machines initially required to form a cluster. The cluster will form when at least this many Core members have discovered each other.
|Valid values
a|causal_clustering.minimum_core_cluster_size_at_formation, an integer which is minimum `2`
|Default value
m|+++3+++
|===

[[cc-setting_causal_clustering.minimum_core_cluster_size_at_runtime]]
.causal_clustering.minimum_core_cluster_size_at_runtime
[cols="<1s,<4"]
|===
|Description
a|The minimum size of the dynamically adjusted voting set (which only core members may be a part of). Adjustments to the voting set happen automatically as the availability of core members changes, due to explicit operations such as starting or stopping a member, or unintended issues such as network partitions. Note that this dynamic scaling of the voting set is generally desirable as under some circumstances it can increase the number of instance failures which may be tolerated. A majority of the voting set must be available before voting in or out members.
|Valid values
a|causal_clustering.minimum_core_cluster_size_at_runtime, an integer which is minimum `2` and depends on dbms.mode. If dbms.mode one of `[CORE]` then it Must be set less than or equal to value of 'causal_clustering.minimum_core_cluster_size_at_formation'  otherwise it is unconstrained.
|Default value
m|+++3+++
|===

[[cc-setting_causal_clustering.multi_dc_license]]
.causal_clustering.multi_dc_license
[cols="<1s,<4"]
|===
|Description
a|Enable multi-data center features. Requires appropriate licensing.
|Valid values
a|causal_clustering.multi_dc_license, a boolean
|Default value
m|+++false+++
|===

[[cc-setting_causal_clustering.protocol_implementations.catchup]]
.causal_clustering.protocol_implementations.catchup
[cols="<1s,<4"]
|===
|Description
a|Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions. Example value: "1.1, 1.2, 2.1, 2.2"
|Valid values
a|causal_clustering.protocol_implementations.catchup, a ',' separated list with elements of type 'an application protocol version'.
|Default value
m|++++++
|===

[[cc-setting_causal_clustering.protocol_implementations.compression]]
.causal_clustering.protocol_implementations.compression
[cols="<1s,<4"]
|===
|Description
a|Network compression algorithms that this instance will allow in negotiation as a comma-separated list. Listed in descending order of preference for incoming connections. An empty list implies no compression. For outgoing connections this merely specifies the allowed set of algorithms and the preference of the  remote peer will be used for making the decision. Allowable values: [Gzip, Snappy, Snappy_validating, LZ4, LZ4_high_compression, LZ_validating, LZ4_high_compression_validating]
|Valid values
a|causal_clustering.protocol_implementations.compression, a ',' separated list with elements of type 'a string'.
|Default value
m|++++++
|===

[[cc-setting_causal_clustering.protocol_implementations.raft]]
.causal_clustering.protocol_implementations.raft
[cols="<1s,<4"]
|===
|Description
a|Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions. Example value: "1.0, 1.3, 2.0, 2.1"
|Valid values
a|causal_clustering.protocol_implementations.raft, a ',' separated list with elements of type 'an application protocol version'.
|Default value
m|++++++
|===

[[cc-setting_causal_clustering.pull_interval]]
.causal_clustering.pull_interval
[cols="<1s,<4"]
|===
|Description
a|Interval of pulling updates from cores.
|Valid values
a|causal_clustering.pull_interval, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++1s+++
|===

[[cc-setting_causal_clustering.raft_advertised_address]]
.causal_clustering.raft_advertised_address
[cols="<1s,<4"]
|===
|Description
a|Advertised hostname/IP address and port for the RAFT server.
|Valid values
a|causal_clustering.raft_advertised_address, a socket address in the format 'hostname:port', 'hostname' or ':port'. If missing port or hostname it is acquired from dbms.default_advertised_address
|Default value
m|+++:7000+++
|===

[[cc-setting_causal_clustering.raft_handler_parallelism]]
.causal_clustering.raft_handler_parallelism
[cols="<1s,<4"]
|===
|Description
a|Limits amount of global threads shared by raft groups for handling bathing of messages and timeout events.
|Valid values
a|causal_clustering.raft_handler_parallelism, an integer which is minimum `1`
|Default value
m|+++8+++
|===

[[cc-setting_causal_clustering.raft_in_queue_max_batch_bytes]]
.causal_clustering.raft_in_queue_max_batch_bytes
[cols="<1s,<4"]
|===
|Description
a|Largest batch processed by RAFT in bytes.
|Valid values
a|causal_clustering.raft_in_queue_max_batch_bytes, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`)
|Default value
m|+++8.00MiB+++
|===

[[cc-setting_causal_clustering.raft_in_queue_max_bytes]]
.causal_clustering.raft_in_queue_max_bytes
[cols="<1s,<4"]
|===
|Description
a|Maximum number of bytes in the RAFT in-queue.
|Valid values
a|causal_clustering.raft_in_queue_max_bytes, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`)
|Default value
m|+++2.00GiB+++
|===

[[cc-setting_causal_clustering.raft_listen_address]]
.causal_clustering.raft_listen_address
[cols="<1s,<4"]
|===
|Description
a|Network interface and port for the RAFT server to listen on.
|Valid values
a|causal_clustering.raft_listen_address, a socket address in the format 'hostname:port', 'hostname' or ':port'. If missing port or hostname it is acquired from dbms.default_listen_address
|Default value
m|+++:7000+++
|===

[[cc-setting_causal_clustering.raft_log_entry_prefetch_buffer.max_entries]]
.causal_clustering.raft_log_entry_prefetch_buffer.max_entries
[cols="<1s,<4"]
|===
|Description
a|The maximum number of entries in the raft log entry prefetch buffer.
|Valid values
a|causal_clustering.raft_log_entry_prefetch_buffer.max_entries, an integer
|Default value
m|+++1024+++
|===

[[cc-setting_causal_clustering.raft_log_implementation]]
.causal_clustering.raft_log_implementation
[cols="<1s,<4"]
|===
|Description
a|RAFT log implementation.
|Valid values
a|causal_clustering.raft_log_implementation, a string
|Default value
m|+++SEGMENTED+++
|===

[[cc-setting_causal_clustering.raft_log_prune_strategy]]
.causal_clustering.raft_log_prune_strategy
[cols="<1s,<4"]
|===
|Description
a|RAFT log pruning strategy that determines which logs are to be pruned. Neo4j only prunes log entries up to the last applied index, which guarantees that logs are only marked for pruning once the transactions within are safely copied over to the local transaction logs and safely committed by a majority of cluster members. Possible values are a byte size or a number of transactions (e.g., 200K txs).
|Valid values
a|causal_clustering.raft_log_prune_strategy, a string
|Default value
m|+++1g size+++
|===

[[cc-setting_causal_clustering.raft_log_pruning_frequency]]
.causal_clustering.raft_log_pruning_frequency
[cols="<1s,<4"]
|===
|Description
a|RAFT log pruning frequency.
|Valid values
a|causal_clustering.raft_log_pruning_frequency, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++10m+++
|===

[[cc-setting_causal_clustering.raft_log_reader_pool_size]]
.causal_clustering.raft_log_reader_pool_size
[cols="<1s,<4"]
|===
|Description
a|RAFT log reader pool size.
|Valid values
a|causal_clustering.raft_log_reader_pool_size, an integer
|Default value
m|+++8+++
|===

[[cc-setting_causal_clustering.raft_log_rotation_size]]
.causal_clustering.raft_log_rotation_size
[cols="<1s,<4"]
|===
|Description
a|RAFT log rotation size.
|Valid values
a|causal_clustering.raft_log_rotation_size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `1.00KiB`
|Default value
m|+++250.00MiB+++
|===

[[cc-setting_causal_clustering.raft_membership_state_size]]
.causal_clustering.raft_membership_state_size
[cols="<1s,<4"]
|===
|Description
a|The maximum file size before the membership state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.raft_membership_state_size, an integer
|Default value
m|+++1000+++
|===

[[cc-setting_causal_clustering.raft_term_state_size]]
.causal_clustering.raft_term_state_size
[cols="<1s,<4"]
|===
|Description
a|The maximum file size before the term state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.raft_term_state_size, an integer
|Default value
m|+++1000+++
|===

[[cc-setting_causal_clustering.raft_vote_state_size]]
.causal_clustering.raft_vote_state_size
[cols="<1s,<4"]
|===
|Description
a|The maximum file size before the vote state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.raft_vote_state_size, an integer
|Default value
m|+++1000+++
|===

[[cc-setting_causal_clustering.refuse_to_be_leader]]
.causal_clustering.refuse_to_be_leader
[cols="<1s,<4"]
|===
|Description
a|Deprecated, use dbms.databases.default_to_read_only.
|Valid values
a|causal_clustering.refuse_to_be_leader, a boolean
|Default value
m|+++false+++
|Deprecated
a|The `causal_clustering.refuse_to_be_leader` configuration setting has been deprecated.
|===

[[cc-setting_causal_clustering.replicated_lease_state_size]]
.causal_clustering.replicated_lease_state_size
[cols="<1s,<4"]
|===
|Description
a|The maximum file size before the replicated lease state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.replicated_lease_state_size, an integer
|Default value
m|+++1000+++
|===

[[cc-setting_causal_clustering.replication_leader_await_timeout]]
.causal_clustering.replication_leader_await_timeout
[cols="<1s,<4"]
|===
|Description
a|The duration for which the replicator will await a new leader.
|Valid values
a|causal_clustering.replication_leader_await_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++10s+++
|===

[[cc-setting_causal_clustering.replication_retry_timeout_base]]
.causal_clustering.replication_retry_timeout_base
[cols="<1s,<4"]
|===
|Description
a|The initial timeout until replication is retried. The timeout will increase exponentially.
|Valid values
a|causal_clustering.replication_retry_timeout_base, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++10s+++
|===

[[cc-setting_causal_clustering.replication_retry_timeout_limit]]
.causal_clustering.replication_retry_timeout_limit
[cols="<1s,<4"]
|===
|Description
a|The upper limit for the exponentially incremented retry timeout.
|Valid values
a|causal_clustering.replication_retry_timeout_limit, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++1m+++
|===

[[cc-setting_causal_clustering.server_groups]]
.causal_clustering.server_groups
[cols="<1s,<4"]
|===
|Description
a|A list of group names for the server used when configuring load balancing and replication policies.
|Valid values
a|causal_clustering.server_groups, a ',' separated list with elements of type 'a string identifying a Server Group'.
|Dynamic a|true
|Default value
m|++++++
|===

[[cc-setting_causal_clustering.state_machine_apply_max_batch_size]]
.causal_clustering.state_machine_apply_max_batch_size
[cols="<1s,<4"]
|===
|Description
a|The maximum number of operations to be batched during applications of operations in the state machines.
|Valid values
a|causal_clustering.state_machine_apply_max_batch_size, an integer
|Default value
m|+++16+++
|===

[[cc-setting_causal_clustering.state_machine_flush_window_size]]
.causal_clustering.state_machine_flush_window_size
[cols="<1s,<4"]
|===
|Description
a|The number of operations to be processed before the state machines flush to disk.
|Valid values
a|causal_clustering.state_machine_flush_window_size, an integer
|Default value
m|+++4096+++
|===

[[cc-setting_causal_clustering.status_throughput_window]]
.causal_clustering.status_throughput_window
[cols="<1s,<4"]
|===
|Description
a|Sampling window for throughput estimate reported in the status endpoint.
|Valid values
a|causal_clustering.status_throughput_window, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`) which is in the range `1s` to `5m`
|Default value
m|+++5s+++
|===

[[cc-setting_causal_clustering.store_copy_chunk_size]]
.causal_clustering.store_copy_chunk_size
[cols="<1s,<4"]
|===
|Description
a|Store copy chunk size.
|Valid values
a|causal_clustering.store_copy_chunk_size, an integer which is in the range `4096` to `1048576`
|Default value
m|+++32768+++
|===

[[cc-setting_causal_clustering.store_copy_max_retry_time_per_request]]
.causal_clustering.store_copy_max_retry_time_per_request
[cols="<1s,<4"]
|===
|Description
a|Maximum retry time per request during store copy. Regular store files and indexes are downloaded in separate requests during store copy. This configures the maximum time failed requests are allowed to resend.
|Valid values
a|causal_clustering.store_copy_max_retry_time_per_request, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++20m+++
|===

[[cc-setting_causal_clustering.store_copy_parallelism]]
.causal_clustering.store_copy_parallelism
[cols="<1s,<4"]
|===
|Description
a|Limits amount of global threads for store copy.
|Valid values
a|causal_clustering.store_copy_parallelism, an integer which is minimum `1`
|Default value
m|+++8+++
|===

[[cc-setting_causal_clustering.transaction_advertised_address]]
.causal_clustering.transaction_advertised_address
[cols="<1s,<4"]
|===
|Description
a|Advertised hostname/IP address and port for the transaction shipping server.
|Valid values
a|causal_clustering.transaction_advertised_address, a socket address in the format 'hostname:port', 'hostname' or ':port'. If missing port or hostname it is acquired from dbms.default_advertised_address
|Default value
m|+++:6000+++
|===

[[cc-setting_causal_clustering.transaction_listen_address]]
.causal_clustering.transaction_listen_address
[cols="<1s,<4"]
|===
|Description
a|Network interface and port for the transaction shipping server to listen on. Please note that it is also possible to run the backup client against this port so always limit access to it via the firewall and configure an ssl policy.
|Valid values
a|causal_clustering.transaction_listen_address, a socket address in the format 'hostname:port', 'hostname' or ':port'. If missing port or hostname it is acquired from dbms.default_listen_address
|Default value
m|+++:6000+++
|===

[[cc-setting_causal_clustering.unknown_address_logging_throttle]]
.causal_clustering.unknown_address_logging_throttle
[cols="<1s,<4"]
|===
|Description
a|Throttle limit for logging unknown cluster member address.
|Valid values
a|causal_clustering.unknown_address_logging_throttle, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Default value
m|+++10s+++
|===

[[cc-setting_causal_clustering.upstream_selection_strategy]]
.causal_clustering.upstream_selection_strategy
[cols="<1s,<4"]
|===
|Description
a|An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.
|Valid values
a|causal_clustering.upstream_selection_strategy, a ',' separated list with elements of type 'a string'.
|Default value
m|+++default+++
|===

[[cc-setting_causal_clustering.user_defined_upstream_strategy]]
.causal_clustering.user_defined_upstream_strategy
[cols="<1s,<4"]
|===
|Description
a|Configuration of a user-defined upstream selection strategy. The user-defined strategy is used if the list of strategies (`<<config_causal_clustering.upstream_selection_strategy,causal_clustering.upstream_selection_strategy>>`) includes the value `user_defined`.
|Valid values
a|causal_clustering.user_defined_upstream_strategy, a string
|Default value
m|++++++
|===

