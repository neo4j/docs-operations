// tag::reference-dynamic-settings-reference[]
[[reference-dynamic-settings-reference]]
.Dynamic settings reference
ifndef::nonhtmloutput[]
[options="header"]
|===
|Name|Description
|<<config_causal_clustering.cluster_allow_reads_on_leader,causal_clustering.cluster_allow_reads_on_leader>>|Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers.
|<<config_causal_clustering.connect_randomly_to_server_group,causal_clustering.connect_randomly_to_server_group>>|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
|<<config_causal_clustering.server_groups,causal_clustering.server_groups>>|A list of group names for the server used when configuring load balancing and replication policies.
|<<config_dbms.allow_single_automatic_upgrade,dbms.allow_single_automatic_upgrade>>|Whether to allow a system graph upgrade to happen automatically in single instance mode (dbms.mode=SINGLE).
|<<config_dbms.allow_upgrade,dbms.allow_upgrade>>|Whether to allow a store upgrade in case the current version of the database starts against an older version of the store.
|<<config_dbms.checkpoint.iops.limit,dbms.checkpoint.iops.limit>>|Limit the number of IOs the background checkpoint process will consume per second.
|<<config_dbms.logs.debug.level,dbms.logs.debug.level>>|Debug log level threshold.
|<<config_dbms.logs.query.allocation_logging_enabled,dbms.logs.query.allocation_logging_enabled>>|Log allocated bytes for the executed queries being logged.
|<<config_dbms.logs.query.early_raw_logging_enabled,dbms.logs.query.early_raw_logging_enabled>>|Log query text and parameters without obfuscating passwords.
|<<config_dbms.logs.query.enabled,dbms.logs.query.enabled>>|Log executed queries.
|<<config_dbms.logs.query.page_logging_enabled,dbms.logs.query.page_logging_enabled>>|Log page hits and page faults for the executed queries being logged.
|<<config_dbms.logs.query.parameter_full_entities,dbms.logs.query.parameter_full_entities>>|Log complete parameter entities including id, labels or relationship type, and properties.
|<<config_dbms.logs.query.parameter_logging_enabled,dbms.logs.query.parameter_logging_enabled>>|Log parameters for the executed queries being logged.
|<<config_dbms.logs.query.rotation.keep_number,dbms.logs.query.rotation.keep_number>>|Maximum number of history files for the query log.
|<<config_dbms.logs.query.rotation.size,dbms.logs.query.rotation.size>>|The file size in bytes at which the query log will auto-rotate.
|<<config_dbms.logs.query.runtime_logging_enabled,dbms.logs.query.runtime_logging_enabled>>|Logs which runtime that was used to run the query.
|<<config_dbms.logs.query.threshold,dbms.logs.query.threshold>>|If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO.
|<<config_dbms.logs.query.time_logging_enabled,dbms.logs.query.time_logging_enabled>>|Log detailed time information for the executed queries being logged, such as `(planning: 92, waiting: 0)`.
|<<config_dbms.memory.pagecache.flush.buffer.enabled,dbms.memory.pagecache.flush.buffer.enabled>>|Page cache can be configured to use a temporal buffer for flushing purposes.
|<<config_dbms.memory.pagecache.flush.buffer.size_in_pages,dbms.memory.pagecache.flush.buffer.size_in_pages>>|Page cache can be configured to use a temporal buffer for flushing purposes.
|<<config_dbms.memory.transaction.database_max_size,dbms.memory.transaction.database_max_size>>|Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_dbms.memory.transaction.global_max_size,dbms.memory.transaction.global_max_size>>|Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_dbms.memory.transaction.max_size,dbms.memory.transaction.max_size>>|Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_dbms.track_query_allocation,dbms.track_query_allocation>>|Enables or disables tracking of how many bytes are allocated by the execution of a query.
|<<config_dbms.track_query_cpu_time,dbms.track_query_cpu_time>>|Enables or disables tracking of how much time a query spends actively executing on the CPU.
|<<config_dbms.transaction.concurrent.maximum,dbms.transaction.concurrent.maximum>>|The maximum number of concurrently running transactions.
|<<config_dbms.transaction.sampling.percentage,dbms.transaction.sampling.percentage>>|Transaction sampling percentage.
|<<config_dbms.transaction.timeout,dbms.transaction.timeout>>|The maximum time interval of a transaction within which it should be completed.
|<<config_dbms.transaction.tracing.level,dbms.transaction.tracing.level>>|Transaction creation tracing level.
|<<config_dbms.tx_log.preallocate,dbms.tx_log.preallocate>>|Specify if Neo4j should try to preallocate logical log file in advance.
|<<config_dbms.tx_log.rotation.retention_policy,dbms.tx_log.rotation.retention_policy>>|Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
|<<config_dbms.tx_log.rotation.size,dbms.tx_log.rotation.size>>|Specifies at which file size the logical log will auto-rotate.
|<<config_dbms.upgrade_max_processors,dbms.upgrade_max_processors>>|Max number of processors used when upgrading the store.
|<<config_fabric.routing.servers,fabric.routing.servers>>|A comma-separated list of Fabric instances that form a routing group.
|===
endif::nonhtmloutput[]

ifdef::nonhtmloutput[]
* <<config_causal_clustering.cluster_allow_reads_on_leader,causal_clustering.cluster_allow_reads_on_leader>>: Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers.
* <<config_causal_clustering.connect_randomly_to_server_group,causal_clustering.connect_randomly_to_server_group>>: Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
* <<config_causal_clustering.server_groups,causal_clustering.server_groups>>: A list of group names for the server used when configuring load balancing and replication policies.
* <<config_dbms.allow_single_automatic_upgrade,dbms.allow_single_automatic_upgrade>>: Whether to allow a system graph upgrade to happen automatically in single instance mode (dbms.mode=SINGLE).
* <<config_dbms.allow_upgrade,dbms.allow_upgrade>>: Whether to allow a store upgrade in case the current version of the database starts against an older version of the store.
* <<config_dbms.checkpoint.iops.limit,dbms.checkpoint.iops.limit>>: Limit the number of IOs the background checkpoint process will consume per second.
* <<config_dbms.logs.debug.level,dbms.logs.debug.level>>: Debug log level threshold.
* <<config_dbms.logs.query.allocation_logging_enabled,dbms.logs.query.allocation_logging_enabled>>: Log allocated bytes for the executed queries being logged.
* <<config_dbms.logs.query.early_raw_logging_enabled,dbms.logs.query.early_raw_logging_enabled>>: Log query text and parameters without obfuscating passwords.
* <<config_dbms.logs.query.enabled,dbms.logs.query.enabled>>: Log executed queries.
* <<config_dbms.logs.query.page_logging_enabled,dbms.logs.query.page_logging_enabled>>: Log page hits and page faults for the executed queries being logged.
* <<config_dbms.logs.query.parameter_full_entities,dbms.logs.query.parameter_full_entities>>: Log complete parameter entities including id, labels or relationship type, and properties.
* <<config_dbms.logs.query.parameter_logging_enabled,dbms.logs.query.parameter_logging_enabled>>: Log parameters for the executed queries being logged.
* <<config_dbms.logs.query.rotation.keep_number,dbms.logs.query.rotation.keep_number>>: Maximum number of history files for the query log.
* <<config_dbms.logs.query.rotation.size,dbms.logs.query.rotation.size>>: The file size in bytes at which the query log will auto-rotate.
* <<config_dbms.logs.query.runtime_logging_enabled,dbms.logs.query.runtime_logging_enabled>>: Logs which runtime that was used to run the query.
* <<config_dbms.logs.query.threshold,dbms.logs.query.threshold>>: If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO.
* <<config_dbms.logs.query.time_logging_enabled,dbms.logs.query.time_logging_enabled>>: Log detailed time information for the executed queries being logged, such as `(planning: 92, waiting: 0)`.
* <<config_dbms.memory.pagecache.flush.buffer.enabled,dbms.memory.pagecache.flush.buffer.enabled>>: Page cache can be configured to use a temporal buffer for flushing purposes.
* <<config_dbms.memory.pagecache.flush.buffer.size_in_pages,dbms.memory.pagecache.flush.buffer.size_in_pages>>: Page cache can be configured to use a temporal buffer for flushing purposes.
* <<config_dbms.memory.transaction.database_max_size,dbms.memory.transaction.database_max_size>>: Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
* <<config_dbms.memory.transaction.global_max_size,dbms.memory.transaction.global_max_size>>: Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
* <<config_dbms.memory.transaction.max_size,dbms.memory.transaction.max_size>>: Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
* <<config_dbms.track_query_allocation,dbms.track_query_allocation>>: Enables or disables tracking of how many bytes are allocated by the execution of a query.
* <<config_dbms.track_query_cpu_time,dbms.track_query_cpu_time>>: Enables or disables tracking of how much time a query spends actively executing on the CPU.
* <<config_dbms.transaction.concurrent.maximum,dbms.transaction.concurrent.maximum>>: The maximum number of concurrently running transactions.
* <<config_dbms.transaction.sampling.percentage,dbms.transaction.sampling.percentage>>: Transaction sampling percentage.
* <<config_dbms.transaction.timeout,dbms.transaction.timeout>>: The maximum time interval of a transaction within which it should be completed.
* <<config_dbms.transaction.tracing.level,dbms.transaction.tracing.level>>: Transaction creation tracing level.
* <<config_dbms.tx_log.preallocate,dbms.tx_log.preallocate>>: Specify if Neo4j should try to preallocate logical log file in advance.
* <<config_dbms.tx_log.rotation.retention_policy,dbms.tx_log.rotation.retention_policy>>: Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
* <<config_dbms.tx_log.rotation.size,dbms.tx_log.rotation.size>>: Specifies at which file size the logical log will auto-rotate.
* <<config_dbms.upgrade_max_processors,dbms.upgrade_max_processors>>: Max number of processors used when upgrading the store.
* <<config_fabric.routing.servers,fabric.routing.servers>>: A comma-separated list of Fabric instances that form a routing group.
endif::nonhtmloutput[]


// end::reference-dynamic-settings-reference[]

[[config_causal_clustering.cluster_allow_reads_on_leader]]
.causal_clustering.cluster_allow_reads_on_leader
[cols="<1s,<4"]
|===
|Description
a|Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers. Note: leader is returned as read endpoint if no other member is present all.
|Valid values
a|causal_clustering.cluster_allow_reads_on_leader, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_causal_clustering.connect_randomly_to_server_group]]
.causal_clustering.connect_randomly_to_server_group
[cols="<1s,<4"]
|===
|Description
a|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`causal_clustering.upstream_selection_strategy`) includes the value `connect-randomly-to-server-group`.
|Valid values
a|causal_clustering.connect_randomly_to_server_group, a ',' separated list with elements of type 'a string identifying a Server Group'.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_causal_clustering.server_groups]]
.causal_clustering.server_groups
[cols="<1s,<4"]
|===
|Description
a|A list of group names for the server used when configuring load balancing and replication policies.
|Valid values
a|causal_clustering.server_groups, a ',' separated list with elements of type 'a string identifying a Server Group'.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.allow_single_automatic_upgrade]]
.dbms.allow_single_automatic_upgrade
[cols="<1s,<4"]
|===
|Description
a|Whether to allow a system graph upgrade to happen automatically in single instance mode (dbms.mode=SINGLE). Default is true. In clustering environments no automatic upgrade will happen (dbms.mode=CORE or dbms.mode=READ_REPLICA). If set to false, or when in a clustering environment, it is necessary to call the procedure `dbms.upgrade()` to complete the upgrade.
|Valid values
a|dbms.allow_single_automatic_upgrade, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_dbms.allow_upgrade]]
.dbms.allow_upgrade
[cols="<1s,<4"]
|===
|Description
a|Whether to allow a store upgrade in case the current version of the database starts against an older version of the store.
|Valid values
a|dbms.allow_upgrade, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.checkpoint.iops.limit]]
.dbms.checkpoint.iops.limit
[cols="<1s,<4"]
|===
|Description
a|Limit the number of IOs the background checkpoint process will consume per second. This setting is advisory, is ignored in Neo4j Community Edition, and is followed to best effort in Enterprise Edition. An IO is in this case a 8 KiB (mostly sequential) write. Limiting the write IO in this way will leave more bandwidth in the IO subsystem to service random-read IOs, which is important for the response time of queries when the database cannot fit entirely in memory. The only drawback of this setting is that longer checkpoint times may lead to slightly longer recovery times in case of a database or system crash. A lower number means lower IO pressure, and consequently longer checkpoint times. Set this to -1 to disable the IOPS limit and remove the limitation entirely; this will let the checkpointer flush data as fast as the hardware will go. Removing the setting, or commenting it out, will set the default value of 600.
|Valid values
a|dbms.checkpoint.iops.limit, an integer
|Dynamic a|true
|Default value
m|+++600+++
|===

[[config_dbms.logs.debug.level]]
.dbms.logs.debug.level
[cols="<1s,<4"]
|===
|Description
a|Debug log level threshold.
|Valid values
a|dbms.logs.debug.level, one of [DEBUG, INFO, WARN, ERROR, NONE]
|Dynamic a|true
|Default value
m|+++INFO+++
|===

[[config_dbms.logs.query.allocation_logging_enabled]]
.dbms.logs.query.allocation_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log allocated bytes for the executed queries being logged. The logged number is cumulative over the duration of the query, i.e. for memory intense or long-running queries the value may be larger than the current memory allocation. Requires `<<config_dbms.track_query_allocation,dbms.track_query_allocation>>=true`
|Valid values
a|dbms.logs.query.allocation_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_dbms.logs.query.early_raw_logging_enabled]]
.dbms.logs.query.early_raw_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log query text and parameters without obfuscating passwords. This allows queries to be logged earlier before parsing starts.
|Valid values
a|dbms.logs.query.early_raw_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.logs.query.enabled]]
.dbms.logs.query.enabled
[cols="<1s,<4"]
|===
|Description
a|Log executed queries. Valid values are `OFF`, `INFO`, or `VERBOSE`.

`OFF`::  no logging.
`INFO`:: log queries at the end of execution, that take longer than the configured threshold, `<<config_dbms.logs.query.threshold,dbms.logs.query.threshold>>`.
`VERBOSE`:: log queries at the start and end of execution, regardless of `<<config_dbms.logs.query.threshold,dbms.logs.query.threshold>>`.

Log entries are by default written to the file __query.log__ located in the Logs directory. This feature is available in the Neo4j Enterprise Edition.
|Valid values
a|dbms.logs.query.enabled, one of [OFF, INFO, VERBOSE]
|Dynamic a|true
|Default value
m|+++VERBOSE+++
|===

[[config_dbms.logs.query.page_logging_enabled]]
.dbms.logs.query.page_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log page hits and page faults for the executed queries being logged.
|Valid values
a|dbms.logs.query.page_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.logs.query.parameter_full_entities]]
.dbms.logs.query.parameter_full_entities
[cols="<1s,<4"]
|===
|Description
a|Log complete parameter entities including id, labels or relationship type, and properties. If false, only the entity id will be logged. This only takes effect if `<<config_dbms.logs.query.parameter_logging_enabled,dbms.logs.query.parameter_logging_enabled>> = true`.
|Valid values
a|dbms.logs.query.parameter_full_entities, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.logs.query.parameter_logging_enabled]]
.dbms.logs.query.parameter_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log parameters for the executed queries being logged.
|Valid values
a|dbms.logs.query.parameter_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_dbms.logs.query.rotation.keep_number]]
.dbms.logs.query.rotation.keep_number
[cols="<1s,<4"]
|===
|Description
a|Maximum number of history files for the query log.
|Valid values
a|dbms.logs.query.rotation.keep_number, an integer which is minimum `1`
|Dynamic a|true
|Default value
m|+++7+++
|===

[[config_dbms.logs.query.rotation.size]]
.dbms.logs.query.rotation.size
[cols="<1s,<4"]
|===
|Description
a|The file size in bytes at which the query log will auto-rotate. If set to zero then no rotation will occur. Accepts a binary suffix `k`, `m` or `g`.
|Valid values
a|dbms.logs.query.rotation.size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is in the range `0B` to `8388608.00TiB`
|Dynamic a|true
|Default value
m|+++20.00MiB+++
|===

[[config_dbms.logs.query.runtime_logging_enabled]]
.dbms.logs.query.runtime_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Logs which runtime that was used to run the query.
|Valid values
a|dbms.logs.query.runtime_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_dbms.logs.query.threshold]]
.dbms.logs.query.threshold
[cols="<1s,<4"]
|===
|Description
a|If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO. Defaults to 0 seconds, that is all queries are logged.
|Valid values
a|dbms.logs.query.threshold, a duration (Valid units are: 'ns', 'μs', 'ms', 's', 'm', 'h' and 'd'; default unit is 's')
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_dbms.logs.query.time_logging_enabled]]
.dbms.logs.query.time_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log detailed time information for the executed queries being logged, such as `(planning: 92, waiting: 0)`.
|Valid values
a|dbms.logs.query.time_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.memory.pagecache.flush.buffer.enabled]]
.dbms.memory.pagecache.flush.buffer.enabled
[cols="<1s,<4"]
|===
|Description
a|Page cache can be configured to use a temporal buffer for flushing purposes. It is used to combine, if possible, sequence of several cache pages into one bigger buffer to minimize the number of individual IOPS performed and better utilization of available I/O resources, especially when those are restricted.
|Valid values
a|dbms.memory.pagecache.flush.buffer.enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.memory.pagecache.flush.buffer.size_in_pages]]
.dbms.memory.pagecache.flush.buffer.size_in_pages
[cols="<1s,<4"]
|===
|Description
a|Page cache can be configured to use a temporal buffer for flushing purposes. It is used to combine, if possible, sequence of several cache pages into one bigger buffer to minimize the number of individual IOPS performed and better utilization of available I/O resources, especially when those are restricted. Use this setting to configure individual file flush buffer size in pages (8KiB). To be able to utilize this buffer during page cache flushing, buffered flush should be enabled.
|Valid values
a|dbms.memory.pagecache.flush.buffer.size_in_pages, an integer which is in the range `1` to `512`
|Dynamic a|true
|Default value
m|+++128+++
|===

[[config_dbms.memory.transaction.database_max_size]]
.dbms.memory.transaction.database_max_size
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'unlimited'.
|Valid values
a|dbms.memory.transaction.database_max_size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `10.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_dbms.memory.transaction.global_max_size]]
.dbms.memory.transaction.global_max_size
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'unlimited'.
|Valid values
a|dbms.memory.transaction.global_max_size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `10.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_dbms.memory.transaction.max_size]]
.dbms.memory.transaction.max_size
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'largest possible value'. When `dbms.mode=SINGLE` this is 'unlimited'. When `dbms.mode=CORE` or `dbms.mode=READ_REPLICA` this is '2G'.
|Valid values
a|dbms.memory.transaction.max_size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `1.00MiB` or is `0B` and depends on dbms.mode. If dbms.mode is `CORE` or is `READ_REPLICA` then it is maximum `2.00GiB` otherwise it is unconstrained.
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_dbms.track_query_allocation]]
.dbms.track_query_allocation
[cols="<1s,<4"]
|===
|Description
a|Enables or disables tracking of how many bytes are allocated by the execution of a query. If enabled, calling `dbms.listQueries` will display the allocated bytes. This can also be logged in the query log by using `<<config_dbms.logs.query.allocation_logging_enabled,dbms.logs.query.allocation_logging_enabled>>`.
|Valid values
a|dbms.track_query_allocation, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_dbms.track_query_cpu_time]]
.dbms.track_query_cpu_time
[cols="<1s,<4"]
|===
|Description
a|Enables or disables tracking of how much time a query spends actively executing on the CPU. Calling `dbms.listQueries` will display the time. This can also be logged in the query log by using `<<config_dbms.logs.query.time_logging_enabled,dbms.logs.query.time_logging_enabled>>`.
|Valid values
a|dbms.track_query_cpu_time, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.transaction.concurrent.maximum]]
.dbms.transaction.concurrent.maximum
[cols="<1s,<4"]
|===
|Description
a|The maximum number of concurrently running transactions. If set to 0, limit is disabled.
|Valid values
a|dbms.transaction.concurrent.maximum, an integer
|Dynamic a|true
|Default value
m|+++1000+++
|===

[[config_dbms.transaction.sampling.percentage]]
.dbms.transaction.sampling.percentage
[cols="<1s,<4"]
|===
|Description
a|Transaction sampling percentage.
|Valid values
a|dbms.transaction.sampling.percentage, an integer which is in the range `1` to `100`
|Dynamic a|true
|Default value
m|+++5+++
|===

[[config_dbms.transaction.timeout]]
.dbms.transaction.timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum time interval of a transaction within which it should be completed.
|Valid values
a|dbms.transaction.timeout, a duration (Valid units are: 'ns', 'μs', 'ms', 's', 'm', 'h' and 'd'; default unit is 's')
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_dbms.transaction.tracing.level]]
.dbms.transaction.tracing.level
[cols="<1s,<4"]
|===
|Description
a|Transaction creation tracing level.
|Valid values
a|dbms.transaction.tracing.level, one of [DISABLED, SAMPLE, ALL]
|Dynamic a|true
|Default value
m|+++DISABLED+++
|===

[[config_dbms.tx_log.preallocate]]
.dbms.tx_log.preallocate
[cols="<1s,<4"]
|===
|Description
a|Specify if Neo4j should try to preallocate logical log file in advance.
|Valid values
a|dbms.tx_log.preallocate, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_dbms.tx_log.rotation.retention_policy]]
.dbms.tx_log.rotation.retention_policy
[cols="<1s,<4"]
|===
|Description
a|Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
|Valid values
a|dbms.tx_log.rotation.retention_policy, a string which matches the pattern `^(true{vbar}keep_all{vbar}false{vbar}keep_none{vbar}(\d+[KkMmGg]?( (files{vbar}size{vbar}txs{vbar}entries{vbar}hours{vbar}days))))$` (Must be `true` or `keep_all`, `false` or `keep_none`, or of format `<number><optional unit> <type>`. Valid units are `K`, `M` and `G`. Valid types are `files`, `size`, `txs`, `entries`, `hours` and `days`. For example, `100M size` will limit logical log space on disk to 100MB per database,and `200K txs` will limit the number of transactions kept to 200 000 per database.)
|Dynamic a|true
|Default value
m|+++7 days+++
|===

[[config_dbms.tx_log.rotation.size]]
.dbms.tx_log.rotation.size
[cols="<1s,<4"]
|===
|Description
a|Specifies at which file size the logical log will auto-rotate. Minimum accepted value is 128 KiB.
|Valid values
a|dbms.tx_log.rotation.size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `128.00KiB`
|Dynamic a|true
|Default value
m|+++250.00MiB+++
|===

[[config_dbms.upgrade_max_processors]]
.dbms.upgrade_max_processors
[cols="<1s,<4"]
|===
|Description
a|Max number of processors used when upgrading the store. Defaults to the number of processors available to the JVM. There is a certain amount of minimum threads needed so for that reason there is no lower bound for this value. For optimal performance this value shouldn't be greater than the number of available processors.
|Valid values
a|dbms.upgrade_max_processors, an integer which is minimum `0`
|Dynamic a|true
|Default value
m|+++0+++
|===

[[config_fabric.routing.servers]]
.fabric.routing.servers
[cols="<1s,<4"]
|===
|Description
a|A comma-separated list of Fabric instances that form a routing group. A driver will route transactions to available routing group members.
A Fabric instance is represented by its Bolt connector address.
|Valid values
a|fabric.routing.servers, a ',' separated list with elements of type 'a socket address'.
|Dynamic a|true
|===

