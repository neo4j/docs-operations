// tag::settings-reference-causal-clustering-settings[]
[[settings-reference-causal-clustering-settings]]
.Causal Clustering settings
ifndef::nonhtmloutput[]
[options="header"]
|===
|Name|Description
|<<cc-setting_causal_clustering.array_block_id_allocation_size,causal_clustering.array_block_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of ARRAY_BLOCK IDs.
|<<cc-setting_causal_clustering.catch_up_client_inactivity_timeout,causal_clustering.catch_up_client_inactivity_timeout>>|The catch up protocol times out if the given duration elapses with no network activity.
|<<cc-setting_causal_clustering.catchup_batch_size,causal_clustering.catchup_batch_size>>|The maximum batch size when catching up (in unit of entries).
|<<cc-setting_causal_clustering.cluster_allow_reads_on_followers,causal_clustering.cluster_allow_reads_on_followers>>|Configure if the `dbms.cluster.routing.getServers()` procedure should include followers as read endpoints or return only read replicas.
|<<cc-setting_causal_clustering.cluster_binding_timeout,causal_clustering.cluster_binding_timeout>>|The time allowed after the Causal Clustering components start for a Neo4j Core Server to either join a cluster or form a new cluster with the other Neo4j Core Servers provided by `causal_clustering.initial_discovery_members`.
|<<cc-setting_causal_clustering.cluster_routing_ttl,causal_clustering.cluster_routing_ttl>>|How long drivers should cache the data from the `dbms.cluster.routing.getServers()` procedure.
|<<cc-setting_causal_clustering.cluster_topology_refresh,causal_clustering.cluster_topology_refresh>>|Time between scanning the cluster to refresh current server's view of topology.
|<<cc-setting_causal_clustering.connect-randomly-to-server-group,causal_clustering.connect-randomly-to-server-group>>|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
|<<cc-setting_causal_clustering.database,causal_clustering.database>>|The name of the database being hosted by this server instance.
|<<cc-setting_causal_clustering.disable_middleware_logging,causal_clustering.disable_middleware_logging>>|Prevents the network middleware from dumping its own logs.
|<<cc-setting_causal_clustering.discovery_advertised_address,causal_clustering.discovery_advertised_address>>|Advertised cluster member discovery management communication.
|<<cc-setting_causal_clustering.discovery_listen_address,causal_clustering.discovery_listen_address>>|Host and port to bind the cluster member discovery management communication.
|<<cc-setting_causal_clustering.discovery_type,causal_clustering.discovery_type>>|Configure the discovery type used for cluster name resolution.
|<<cc-setting_causal_clustering.enable_pre_voting,causal_clustering.enable_pre_voting>>|Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members).
|<<cc-setting_causal_clustering.expected_core_cluster_size,causal_clustering.expected_core_cluster_size>>|Expected number of Core machines in the cluster before startup.
|<<cc-setting_causal_clustering.global_session_tracker_state_size,causal_clustering.global_session_tracker_state_size>>|The maximum file size before the global session tracker state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.handshake_timeout,causal_clustering.handshake_timeout>>|Time out for protocol negotiation handshake.
|<<cc-setting_causal_clustering.id_alloc_state_size,causal_clustering.id_alloc_state_size>>|The maximum file size before the ID allocation file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.in_flight_cache.max_bytes,causal_clustering.in_flight_cache.max_bytes>>|The maximum number of bytes in the in-flight cache.
|<<cc-setting_causal_clustering.in_flight_cache.max_entries,causal_clustering.in_flight_cache.max_entries>>|The maximum number of entries in the in-flight cache.
|<<cc-setting_causal_clustering.in_flight_cache.type,causal_clustering.in_flight_cache.type>>|Type of in-flight cache.
|<<cc-setting_causal_clustering.initial_discovery_members,causal_clustering.initial_discovery_members>>|A comma-separated list of other members of the cluster to join.
|<<cc-setting_causal_clustering.join_catch_up_timeout,causal_clustering.join_catch_up_timeout>>|Time out for a new member to catch up.
|<<cc-setting_causal_clustering.kubernetes.address,causal_clustering.kubernetes.address>>|Address for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.ca_crt,causal_clustering.kubernetes.ca_crt>>|File location of CA certificate for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.label_selector,causal_clustering.kubernetes.label_selector>>|LabelSelector for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.namespace,causal_clustering.kubernetes.namespace>>|File location of namespace for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.service_port_name,causal_clustering.kubernetes.service_port_name>>|Service port name for discovery for Kubernetes API.
|<<cc-setting_causal_clustering.kubernetes.token,causal_clustering.kubernetes.token>>|File location of token for Kubernetes API.
|<<cc-setting_causal_clustering.label_token_id_allocation_size,causal_clustering.label_token_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN IDs.
|<<cc-setting_causal_clustering.label_token_name_id_allocation_size,causal_clustering.label_token_name_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN_NAME IDs.
|<<cc-setting_causal_clustering.last_applied_state_size,causal_clustering.last_applied_state_size>>|The maximum file size before the storage file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.leader_election_timeout,causal_clustering.leader_election_timeout>>|The time limit within which a new leader election will occur if no messages are received.
|<<cc-setting_causal_clustering.load_balancing.config,causal_clustering.load_balancing.config>>|The configuration must be valid for the configured plugin and usually existsunder matching subkeys, e.g.
|<<cc-setting_causal_clustering.load_balancing.plugin,causal_clustering.load_balancing.plugin>>|The load balancing plugin to use.
|<<cc-setting_causal_clustering.load_balancing.shuffle,causal_clustering.load_balancing.shuffle>>|Enables shuffling of the returned load balancing result.
|<<cc-setting_causal_clustering.log_shipping_max_lag,causal_clustering.log_shipping_max_lag>>|The maximum lag allowed before log shipping pauses (in unit of entries).
|<<cc-setting_causal_clustering.middleware_logging.level,causal_clustering.middleware_logging.level>>|The level of middleware logging.
|<<cc-setting_causal_clustering.minimum_core_cluster_size_at_formation,causal_clustering.minimum_core_cluster_size_at_formation>>|Minimum number of Core machines initially required to form a cluster.
|<<cc-setting_causal_clustering.minimum_core_cluster_size_at_runtime,causal_clustering.minimum_core_cluster_size_at_runtime>>|The minimum size of the dynamically adjusted voting set (which only core members may be a part of).
|<<cc-setting_causal_clustering.multi_dc_license,causal_clustering.multi_dc_license>>|Enable multi-data center features.
|<<cc-setting_causal_clustering.neostore_block_id_allocation_size,causal_clustering.neostore_block_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of NEOSTORE_BLOCK IDs.
|<<cc-setting_causal_clustering.node_id_allocation_size,causal_clustering.node_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of NODE IDs.
|<<cc-setting_causal_clustering.node_labels_id_allocation_size,causal_clustering.node_labels_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of NODE_LABELS IDs.
|<<cc-setting_causal_clustering.property_id_allocation_size,causal_clustering.property_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of PROPERTY IDs.
|<<cc-setting_causal_clustering.property_key_token_id_allocation_size,causal_clustering.property_key_token_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN IDs.
|<<cc-setting_causal_clustering.property_key_token_name_id_allocation_size,causal_clustering.property_key_token_name_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN_NAME IDs.
|<<cc-setting_causal_clustering.protocol_implementations.catchup,causal_clustering.protocol_implementations.catchup>>|Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list.
|<<cc-setting_causal_clustering.protocol_implementations.compression,causal_clustering.protocol_implementations.compression>>|Network compression algorithms that this instance will allow in negotiation as a comma-separated list.
|<<cc-setting_causal_clustering.protocol_implementations.raft,causal_clustering.protocol_implementations.raft>>|Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list.
|<<cc-setting_causal_clustering.pull_interval,causal_clustering.pull_interval>>|Interval of pulling updates from cores.
|<<cc-setting_causal_clustering.raft_advertised_address,causal_clustering.raft_advertised_address>>|Advertised hostname/IP address and port for the RAFT server.
|<<cc-setting_causal_clustering.raft_in_queue_max_batch_bytes,causal_clustering.raft_in_queue_max_batch_bytes>>|Largest batch processed by RAFT in bytes.
|<<cc-setting_causal_clustering.raft_in_queue_max_bytes,causal_clustering.raft_in_queue_max_bytes>>|Maximum number of bytes in the RAFT in-queue.
|<<cc-setting_causal_clustering.raft_listen_address,causal_clustering.raft_listen_address>>|Network interface and port for the RAFT server to listen on.
|<<cc-setting_causal_clustering.raft_log_implementation,causal_clustering.raft_log_implementation>>|RAFT log implementation.
|<<cc-setting_causal_clustering.raft_log_prune_strategy,causal_clustering.raft_log_prune_strategy>>|RAFT log pruning strategy.
|<<cc-setting_causal_clustering.raft_log_pruning_frequency,causal_clustering.raft_log_pruning_frequency>>|RAFT log pruning frequency.
|<<cc-setting_causal_clustering.raft_log_reader_pool_size,causal_clustering.raft_log_reader_pool_size>>|RAFT log reader pool size.
|<<cc-setting_causal_clustering.raft_log_rotation_size,causal_clustering.raft_log_rotation_size>>|RAFT log rotation size.
|<<cc-setting_causal_clustering.raft_membership_state_size,causal_clustering.raft_membership_state_size>>|The maximum file size before the membership state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.raft_term_state_size,causal_clustering.raft_term_state_size>>|The maximum file size before the term state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.raft_vote_state_size,causal_clustering.raft_vote_state_size>>|The maximum file size before the vote state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.read_replica_time_to_live,causal_clustering.read_replica_time_to_live>>|Time To Live before read replica is considered unavailable.
|<<cc-setting_causal_clustering.reconnection_backoff,causal_clustering.reconnection_backoff>>|Minimum time between connection attempts.
|<<cc-setting_causal_clustering.refuse_to_be_leader,causal_clustering.refuse_to_be_leader>>|Prevents the current instance from volunteering to become Raft leader.
|<<cc-setting_causal_clustering.relationship_group_id_allocation_size,causal_clustering.relationship_group_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_GROUP IDs.
|<<cc-setting_causal_clustering.relationship_id_allocation_size,causal_clustering.relationship_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP IDs.
|<<cc-setting_causal_clustering.relationship_type_token_id_allocation_size,causal_clustering.relationship_type_token_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN IDs.
|<<cc-setting_causal_clustering.relationship_type_token_name_id_allocation_size,causal_clustering.relationship_type_token_name_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN_NAME IDs.
|<<cc-setting_causal_clustering.replicated_lock_token_state_size,causal_clustering.replicated_lock_token_state_size>>|The maximum file size before the replicated lock token state file is rotated (in unit of entries).
|<<cc-setting_causal_clustering.replication_retry_timeout_base,causal_clustering.replication_retry_timeout_base>>|The initial timeout until replication is retried.
|<<cc-setting_causal_clustering.replication_retry_timeout_limit,causal_clustering.replication_retry_timeout_limit>>|The upper limit for the exponentially incremented retry timeout.
|<<cc-setting_causal_clustering.schema_id_allocation_size,causal_clustering.schema_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of SCHEMA IDs.
|<<cc-setting_causal_clustering.server_groups,causal_clustering.server_groups>>|A list of group names for the server used when configuring load balancing and replication policies.
|<<cc-setting_causal_clustering.ssl_policy,causal_clustering.ssl_policy>>|Name of the SSL policy to be used by the clustering, as defined under the dbms.ssl.policy.* settings.
|<<cc-setting_causal_clustering.state_machine_apply_max_batch_size,causal_clustering.state_machine_apply_max_batch_size>>|The maximum number of operations to be batched during applications of operations in the state machines.
|<<cc-setting_causal_clustering.state_machine_flush_window_size,causal_clustering.state_machine_flush_window_size>>|The number of operations to be processed before the state machines flush to disk.
|<<cc-setting_causal_clustering.store_copy_max_retry_time_per_request,causal_clustering.store_copy_max_retry_time_per_request>>|Maximum retry time per request during store copy.
|<<cc-setting_causal_clustering.string_block_id_allocation_size,causal_clustering.string_block_id_allocation_size>>|The size of the ID allocation requests Core servers will make when they run out of STRING_BLOCK IDs.
|<<cc-setting_causal_clustering.transaction_advertised_address,causal_clustering.transaction_advertised_address>>|Advertised hostname/IP address and port for the transaction shipping server.
|<<cc-setting_causal_clustering.transaction_listen_address,causal_clustering.transaction_listen_address>>|Network interface and port for the transaction shipping server to listen on.
|<<cc-setting_causal_clustering.unknown_address_logging_throttle,causal_clustering.unknown_address_logging_throttle>>|Throttle limit for logging unknown cluster member address.
|<<cc-setting_causal_clustering.upstream_selection_strategy,causal_clustering.upstream_selection_strategy>>|An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.
|<<cc-setting_causal_clustering.user_defined_upstream_strategy,causal_clustering.user_defined_upstream_strategy>>|Configuration of a user-defined upstream selection strategy.
|===
endif::nonhtmloutput[]

ifdef::nonhtmloutput[]
* <<cc-setting_causal_clustering.array_block_id_allocation_size,causal_clustering.array_block_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of ARRAY_BLOCK IDs.
* <<cc-setting_causal_clustering.catch_up_client_inactivity_timeout,causal_clustering.catch_up_client_inactivity_timeout>>: The catch up protocol times out if the given duration elapses with no network activity.
* <<cc-setting_causal_clustering.catchup_batch_size,causal_clustering.catchup_batch_size>>: The maximum batch size when catching up (in unit of entries).
* <<cc-setting_causal_clustering.cluster_allow_reads_on_followers,causal_clustering.cluster_allow_reads_on_followers>>: Configure if the `dbms.cluster.routing.getServers()` procedure should include followers as read endpoints or return only read replicas.
* <<cc-setting_causal_clustering.cluster_binding_timeout,causal_clustering.cluster_binding_timeout>>: The time allowed after the Causal Clustering components start for a Neo4j Core Server to either join a cluster or form a new cluster with the other Neo4j Core Servers provided by `causal_clustering.initial_discovery_members`.
* <<cc-setting_causal_clustering.cluster_routing_ttl,causal_clustering.cluster_routing_ttl>>: How long drivers should cache the data from the `dbms.cluster.routing.getServers()` procedure.
* <<cc-setting_causal_clustering.cluster_topology_refresh,causal_clustering.cluster_topology_refresh>>: Time between scanning the cluster to refresh current server's view of topology.
* <<cc-setting_causal_clustering.connect-randomly-to-server-group,causal_clustering.connect-randomly-to-server-group>>: Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
* <<cc-setting_causal_clustering.database,causal_clustering.database>>: The name of the database being hosted by this server instance.
* <<cc-setting_causal_clustering.disable_middleware_logging,causal_clustering.disable_middleware_logging>>: Prevents the network middleware from dumping its own logs.
* <<cc-setting_causal_clustering.discovery_advertised_address,causal_clustering.discovery_advertised_address>>: Advertised cluster member discovery management communication.
* <<cc-setting_causal_clustering.discovery_listen_address,causal_clustering.discovery_listen_address>>: Host and port to bind the cluster member discovery management communication.
* <<cc-setting_causal_clustering.discovery_type,causal_clustering.discovery_type>>: Configure the discovery type used for cluster name resolution.
* <<cc-setting_causal_clustering.enable_pre_voting,causal_clustering.enable_pre_voting>>: Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members).
* <<cc-setting_causal_clustering.expected_core_cluster_size,causal_clustering.expected_core_cluster_size>>: Expected number of Core machines in the cluster before startup.
* <<cc-setting_causal_clustering.global_session_tracker_state_size,causal_clustering.global_session_tracker_state_size>>: The maximum file size before the global session tracker state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.handshake_timeout,causal_clustering.handshake_timeout>>: Time out for protocol negotiation handshake.
* <<cc-setting_causal_clustering.id_alloc_state_size,causal_clustering.id_alloc_state_size>>: The maximum file size before the ID allocation file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.in_flight_cache.max_bytes,causal_clustering.in_flight_cache.max_bytes>>: The maximum number of bytes in the in-flight cache.
* <<cc-setting_causal_clustering.in_flight_cache.max_entries,causal_clustering.in_flight_cache.max_entries>>: The maximum number of entries in the in-flight cache.
* <<cc-setting_causal_clustering.in_flight_cache.type,causal_clustering.in_flight_cache.type>>: Type of in-flight cache.
* <<cc-setting_causal_clustering.initial_discovery_members,causal_clustering.initial_discovery_members>>: A comma-separated list of other members of the cluster to join.
* <<cc-setting_causal_clustering.join_catch_up_timeout,causal_clustering.join_catch_up_timeout>>: Time out for a new member to catch up.
* <<cc-setting_causal_clustering.kubernetes.address,causal_clustering.kubernetes.address>>: Address for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.ca_crt,causal_clustering.kubernetes.ca_crt>>: File location of CA certificate for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.label_selector,causal_clustering.kubernetes.label_selector>>: LabelSelector for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.namespace,causal_clustering.kubernetes.namespace>>: File location of namespace for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.service_port_name,causal_clustering.kubernetes.service_port_name>>: Service port name for discovery for Kubernetes API.
* <<cc-setting_causal_clustering.kubernetes.token,causal_clustering.kubernetes.token>>: File location of token for Kubernetes API.
* <<cc-setting_causal_clustering.label_token_id_allocation_size,causal_clustering.label_token_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN IDs.
* <<cc-setting_causal_clustering.label_token_name_id_allocation_size,causal_clustering.label_token_name_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN_NAME IDs.
* <<cc-setting_causal_clustering.last_applied_state_size,causal_clustering.last_applied_state_size>>: The maximum file size before the storage file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.leader_election_timeout,causal_clustering.leader_election_timeout>>: The time limit within which a new leader election will occur if no messages are received.
* <<cc-setting_causal_clustering.load_balancing.config,causal_clustering.load_balancing.config>>: The configuration must be valid for the configured plugin and usually existsunder matching subkeys, e.g.
* <<cc-setting_causal_clustering.load_balancing.plugin,causal_clustering.load_balancing.plugin>>: The load balancing plugin to use.
* <<cc-setting_causal_clustering.load_balancing.shuffle,causal_clustering.load_balancing.shuffle>>: Enables shuffling of the returned load balancing result.
* <<cc-setting_causal_clustering.log_shipping_max_lag,causal_clustering.log_shipping_max_lag>>: The maximum lag allowed before log shipping pauses (in unit of entries).
* <<cc-setting_causal_clustering.middleware_logging.level,causal_clustering.middleware_logging.level>>: The level of middleware logging.
* <<cc-setting_causal_clustering.minimum_core_cluster_size_at_formation,causal_clustering.minimum_core_cluster_size_at_formation>>: Minimum number of Core machines initially required to form a cluster.
* <<cc-setting_causal_clustering.minimum_core_cluster_size_at_runtime,causal_clustering.minimum_core_cluster_size_at_runtime>>: The minimum size of the dynamically adjusted voting set (which only core members may be a part of).
* <<cc-setting_causal_clustering.multi_dc_license,causal_clustering.multi_dc_license>>: Enable multi-data center features.
* <<cc-setting_causal_clustering.neostore_block_id_allocation_size,causal_clustering.neostore_block_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of NEOSTORE_BLOCK IDs.
* <<cc-setting_causal_clustering.node_id_allocation_size,causal_clustering.node_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of NODE IDs.
* <<cc-setting_causal_clustering.node_labels_id_allocation_size,causal_clustering.node_labels_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of NODE_LABELS IDs.
* <<cc-setting_causal_clustering.property_id_allocation_size,causal_clustering.property_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of PROPERTY IDs.
* <<cc-setting_causal_clustering.property_key_token_id_allocation_size,causal_clustering.property_key_token_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN IDs.
* <<cc-setting_causal_clustering.property_key_token_name_id_allocation_size,causal_clustering.property_key_token_name_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN_NAME IDs.
* <<cc-setting_causal_clustering.protocol_implementations.catchup,causal_clustering.protocol_implementations.catchup>>: Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list.
* <<cc-setting_causal_clustering.protocol_implementations.compression,causal_clustering.protocol_implementations.compression>>: Network compression algorithms that this instance will allow in negotiation as a comma-separated list.
* <<cc-setting_causal_clustering.protocol_implementations.raft,causal_clustering.protocol_implementations.raft>>: Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list.
* <<cc-setting_causal_clustering.pull_interval,causal_clustering.pull_interval>>: Interval of pulling updates from cores.
* <<cc-setting_causal_clustering.raft_advertised_address,causal_clustering.raft_advertised_address>>: Advertised hostname/IP address and port for the RAFT server.
* <<cc-setting_causal_clustering.raft_in_queue_max_batch_bytes,causal_clustering.raft_in_queue_max_batch_bytes>>: Largest batch processed by RAFT in bytes.
* <<cc-setting_causal_clustering.raft_in_queue_max_bytes,causal_clustering.raft_in_queue_max_bytes>>: Maximum number of bytes in the RAFT in-queue.
* <<cc-setting_causal_clustering.raft_listen_address,causal_clustering.raft_listen_address>>: Network interface and port for the RAFT server to listen on.
* <<cc-setting_causal_clustering.raft_log_implementation,causal_clustering.raft_log_implementation>>: RAFT log implementation.
* <<cc-setting_causal_clustering.raft_log_prune_strategy,causal_clustering.raft_log_prune_strategy>>: RAFT log pruning strategy.
* <<cc-setting_causal_clustering.raft_log_pruning_frequency,causal_clustering.raft_log_pruning_frequency>>: RAFT log pruning frequency.
* <<cc-setting_causal_clustering.raft_log_reader_pool_size,causal_clustering.raft_log_reader_pool_size>>: RAFT log reader pool size.
* <<cc-setting_causal_clustering.raft_log_rotation_size,causal_clustering.raft_log_rotation_size>>: RAFT log rotation size.
* <<cc-setting_causal_clustering.raft_membership_state_size,causal_clustering.raft_membership_state_size>>: The maximum file size before the membership state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.raft_term_state_size,causal_clustering.raft_term_state_size>>: The maximum file size before the term state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.raft_vote_state_size,causal_clustering.raft_vote_state_size>>: The maximum file size before the vote state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.read_replica_time_to_live,causal_clustering.read_replica_time_to_live>>: Time To Live before read replica is considered unavailable.
* <<cc-setting_causal_clustering.reconnection_backoff,causal_clustering.reconnection_backoff>>: Minimum time between connection attempts.
* <<cc-setting_causal_clustering.refuse_to_be_leader,causal_clustering.refuse_to_be_leader>>: Prevents the current instance from volunteering to become Raft leader.
* <<cc-setting_causal_clustering.relationship_group_id_allocation_size,causal_clustering.relationship_group_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_GROUP IDs.
* <<cc-setting_causal_clustering.relationship_id_allocation_size,causal_clustering.relationship_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP IDs.
* <<cc-setting_causal_clustering.relationship_type_token_id_allocation_size,causal_clustering.relationship_type_token_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN IDs.
* <<cc-setting_causal_clustering.relationship_type_token_name_id_allocation_size,causal_clustering.relationship_type_token_name_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN_NAME IDs.
* <<cc-setting_causal_clustering.replicated_lock_token_state_size,causal_clustering.replicated_lock_token_state_size>>: The maximum file size before the replicated lock token state file is rotated (in unit of entries).
* <<cc-setting_causal_clustering.replication_retry_timeout_base,causal_clustering.replication_retry_timeout_base>>: The initial timeout until replication is retried.
* <<cc-setting_causal_clustering.replication_retry_timeout_limit,causal_clustering.replication_retry_timeout_limit>>: The upper limit for the exponentially incremented retry timeout.
* <<cc-setting_causal_clustering.schema_id_allocation_size,causal_clustering.schema_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of SCHEMA IDs.
* <<cc-setting_causal_clustering.server_groups,causal_clustering.server_groups>>: A list of group names for the server used when configuring load balancing and replication policies.
* <<cc-setting_causal_clustering.ssl_policy,causal_clustering.ssl_policy>>: Name of the SSL policy to be used by the clustering, as defined under the dbms.ssl.policy.* settings.
* <<cc-setting_causal_clustering.state_machine_apply_max_batch_size,causal_clustering.state_machine_apply_max_batch_size>>: The maximum number of operations to be batched during applications of operations in the state machines.
* <<cc-setting_causal_clustering.state_machine_flush_window_size,causal_clustering.state_machine_flush_window_size>>: The number of operations to be processed before the state machines flush to disk.
* <<cc-setting_causal_clustering.store_copy_max_retry_time_per_request,causal_clustering.store_copy_max_retry_time_per_request>>: Maximum retry time per request during store copy.
* <<cc-setting_causal_clustering.string_block_id_allocation_size,causal_clustering.string_block_id_allocation_size>>: The size of the ID allocation requests Core servers will make when they run out of STRING_BLOCK IDs.
* <<cc-setting_causal_clustering.transaction_advertised_address,causal_clustering.transaction_advertised_address>>: Advertised hostname/IP address and port for the transaction shipping server.
* <<cc-setting_causal_clustering.transaction_listen_address,causal_clustering.transaction_listen_address>>: Network interface and port for the transaction shipping server to listen on.
* <<cc-setting_causal_clustering.unknown_address_logging_throttle,causal_clustering.unknown_address_logging_throttle>>: Throttle limit for logging unknown cluster member address.
* <<cc-setting_causal_clustering.upstream_selection_strategy,causal_clustering.upstream_selection_strategy>>: An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.
* <<cc-setting_causal_clustering.user_defined_upstream_strategy,causal_clustering.user_defined_upstream_strategy>>: Configuration of a user-defined upstream selection strategy.
endif::nonhtmloutput[]


// end::settings-reference-causal-clustering-settings[]

[[cc-setting_causal_clustering.array_block_id_allocation_size]]
.causal_clustering.array_block_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of ARRAY_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.array_block_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.catch_up_client_inactivity_timeout]]
.causal_clustering.catch_up_client_inactivity_timeout
[cols="<1h,<4"]
|===
|Description
a|The catch up protocol times out if the given duration elapses with no network activity. Every message received by the client from the server extends the time out duration.
|Valid values
a|causal_clustering.catch_up_client_inactivity_timeout is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|600s
|===

[[cc-setting_causal_clustering.catchup_batch_size]]
.causal_clustering.catchup_batch_size
[cols="<1h,<4"]
|===
|Description
a|The maximum batch size when catching up (in unit of entries)
|Valid values
a|causal_clustering.catchup_batch_size is an integer
|Default value
m|64
|===

[[cc-setting_causal_clustering.cluster_allow_reads_on_followers]]
.causal_clustering.cluster_allow_reads_on_followers
[cols="<1h,<4"]
|===
|Description
a|Configure if the `dbms.cluster.routing.getServers()` procedure should include followers as read endpoints or return only read replicas. Note: if there are no read replicas in the cluster, followers are returned as read end points regardless the value of this setting. Defaults to true so that followers are available for read-only queries in a typical heterogeneous setup.
|Valid values
a|causal_clustering.cluster_allow_reads_on_followers is a boolean
|Default value
m|true
|===

[[cc-setting_causal_clustering.cluster_binding_timeout]]
.causal_clustering.cluster_binding_timeout
[cols="<1h,<4"]
|===
|Description
a|The time allowed after the Causal Clustering components start for a Neo4j Core Server to either join a cluster or form a new cluster with the other Neo4j Core Servers provided by `<<config_causal_clustering.initial_discovery_members,causal_clustering.initial_discovery_members>>`.
|Valid values
a|causal_clustering.cluster_binding_timeout is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|300s
|===

[[cc-setting_causal_clustering.cluster_routing_ttl]]
.causal_clustering.cluster_routing_ttl
[cols="<1h,<4"]
|===
|Description
a|How long drivers should cache the data from the `dbms.cluster.routing.getServers()` procedure.
|Valid values
a|causal_clustering.cluster_routing_ttl is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's') which is minimum `PT1S`
|Default value
m|300s
|===

[[cc-setting_causal_clustering.cluster_topology_refresh]]
.causal_clustering.cluster_topology_refresh
[cols="<1h,<4"]
|===
|Description
a|Time between scanning the cluster to refresh current server's view of topology.
|Valid values
a|causal_clustering.cluster_topology_refresh is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's') which is minimum `PT1S`
|Default value
m|5s
|===

[[cc-setting_causal_clustering.connect-randomly-to-server-group]]
.causal_clustering.connect-randomly-to-server-group
[cols="<1h,<4"]
|===
|Description
a|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`<<config_causal_clustering.upstream_selection_strategy,causal_clustering.upstream_selection_strategy>>`) includes the value `connect-randomly-to-server-group`. 
|Valid values
a|causal_clustering.connect-randomly-to-server-group is a list separated by "," where items are a string
|Default value
m|[]
|===

[[cc-setting_causal_clustering.database]]
.causal_clustering.database
[cols="<1h,<4"]
|===
|Description
a|The name of the database being hosted by this server instance. This configuration setting may be safely ignored unless deploying a multicluster. Instances may be allocated to distinct sub-clusters by assigning them distinct database names using this setting. For instance if you had 6 instances you could form 2 sub-clusters by assigning half the database name "foo", half the name "bar". The setting value must match exactly between members of the same sub-cluster. This setting is a one-off: once an instance is configured with a database name it may not be changed in future without using neo4j-admin unbind.
|Valid values
a|causal_clustering.database is a string
|Default value
m|default
|===

[[cc-setting_causal_clustering.disable_middleware_logging]]
.causal_clustering.disable_middleware_logging
[cols="<1h,<4"]
|===
|Description
a|Prevents the network middleware from dumping its own logs. Defaults to true.
|Valid values
a|causal_clustering.disable_middleware_logging is a boolean
|Default value
m|true
|===

[[cc-setting_causal_clustering.discovery_advertised_address]]
.causal_clustering.discovery_advertised_address
[cols="<1h,<4"]
|===
|Description
a|Advertised cluster member discovery management communication.
|Valid values
a|an advertised socket address
|Default value
m|localhost:5000
|===

[[cc-setting_causal_clustering.discovery_listen_address]]
.causal_clustering.discovery_listen_address
[cols="<1h,<4"]
|===
|Description
a|Host and port to bind the cluster member discovery management communication.
|Valid values
a|a listen socket address
|Default value
m|127.0.0.1:5000
|===

[[cc-setting_causal_clustering.discovery_type]]
.causal_clustering.discovery_type
[cols="<1h,<4"]
|===
|Description
a|Configure the discovery type used for cluster name resolution.
|Valid values
a|causal_clustering.discovery_type is one of `DNS`, `LIST`, `SRV`, `K8S`
|Default value
m|LIST
|===

[[cc-setting_causal_clustering.enable_pre_voting]]
.causal_clustering.enable_pre_voting
[cols="<1h,<4"]
|===
|Description
a|Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members)
|Valid values
a|causal_clustering.enable_pre_voting is a boolean
|Default value
m|false
|===

[[cc-setting_causal_clustering.expected_core_cluster_size]]
.causal_clustering.expected_core_cluster_size
[cols="<1h,<4"]
|===
|Description
a|Expected number of Core machines in the cluster before startup.
|Valid values
a|causal_clustering.expected_core_cluster_size is an integer
|Default value
m|3
|Deprecated
a|The `causal_clustering.expected_core_cluster_size` configuration setting has been deprecated.
|Replaced by
a|<<config_causal_clustering.minimum_core_cluster_size_at_formation,causal_clustering.minimum_core_cluster_size_at_formation>>, <<config_causal_clustering.minimum_core_cluster_size_at_runtime,causal_clustering.minimum_core_cluster_size_at_runtime>>
|===

[[cc-setting_causal_clustering.global_session_tracker_state_size]]
.causal_clustering.global_session_tracker_state_size
[cols="<1h,<4"]
|===
|Description
a|The maximum file size before the global session tracker state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.global_session_tracker_state_size is an integer
|Default value
m|1000
|===

[[cc-setting_causal_clustering.handshake_timeout]]
.causal_clustering.handshake_timeout
[cols="<1h,<4"]
|===
|Description
a|Time out for protocol negotiation handshake.
|Valid values
a|causal_clustering.handshake_timeout is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|20s
|===

[[cc-setting_causal_clustering.id_alloc_state_size]]
.causal_clustering.id_alloc_state_size
[cols="<1h,<4"]
|===
|Description
a|The maximum file size before the ID allocation file is rotated (in unit of entries)
|Valid values
a|causal_clustering.id_alloc_state_size is an integer
|Default value
m|1000
|===

[[cc-setting_causal_clustering.in_flight_cache.max_bytes]]
.causal_clustering.in_flight_cache.max_bytes
[cols="<1h,<4"]
|===
|Description
a|The maximum number of bytes in the in-flight cache.
|Valid values
a|causal_clustering.in_flight_cache.max_bytes is a byte size (valid multipliers are `k`, `m`, `g`, `K`, `M`, `G`)
|Default value
m|2147483648
|===

[[cc-setting_causal_clustering.in_flight_cache.max_entries]]
.causal_clustering.in_flight_cache.max_entries
[cols="<1h,<4"]
|===
|Description
a|The maximum number of entries in the in-flight cache.
|Valid values
a|causal_clustering.in_flight_cache.max_entries is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.in_flight_cache.type]]
.causal_clustering.in_flight_cache.type
[cols="<1h,<4"]
|===
|Description
a|Type of in-flight cache.
|Valid values
a|causal_clustering.in_flight_cache.type is one of `NONE`, `CONSECUTIVE`, `UNBOUNDED`
|Default value
m|CONSECUTIVE
|===

[[cc-setting_causal_clustering.initial_discovery_members]]
.causal_clustering.initial_discovery_members
[cols="<1h,<4"]
|===
|Description
a|A comma-separated list of other members of the cluster to join.
|Valid values
a|causal_clustering.initial_discovery_members is a list separated by "," where items are an advertised socket address
|===

[[cc-setting_causal_clustering.join_catch_up_timeout]]
.causal_clustering.join_catch_up_timeout
[cols="<1h,<4"]
|===
|Description
a|Time out for a new member to catch up.
|Valid values
a|causal_clustering.join_catch_up_timeout is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|600s
|===

[[cc-setting_causal_clustering.kubernetes.address]]
.causal_clustering.kubernetes.address
[cols="<1h,<4"]
|===
|Description
a|Address for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.address is an advertised socket address
|Default value
m|kubernetes.default.svc:443
|===

[[cc-setting_causal_clustering.kubernetes.ca_crt]]
.causal_clustering.kubernetes.ca_crt
[cols="<1h,<4"]
|===
|Description
a|File location of CA certificate for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.ca_crt is a path
|Default value
m|/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
|===

[[cc-setting_causal_clustering.kubernetes.label_selector]]
.causal_clustering.kubernetes.label_selector
[cols="<1h,<4"]
|===
|Description
a|LabelSelector for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.label_selector is a string
|===

[[cc-setting_causal_clustering.kubernetes.namespace]]
.causal_clustering.kubernetes.namespace
[cols="<1h,<4"]
|===
|Description
a|File location of namespace for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.namespace is a path
|Default value
m|/var/run/secrets/kubernetes.io/serviceaccount/namespace
|===

[[cc-setting_causal_clustering.kubernetes.service_port_name]]
.causal_clustering.kubernetes.service_port_name
[cols="<1h,<4"]
|===
|Description
a|Service port name for discovery for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.service_port_name is a string
|===

[[cc-setting_causal_clustering.kubernetes.token]]
.causal_clustering.kubernetes.token
[cols="<1h,<4"]
|===
|Description
a|File location of token for Kubernetes API.
|Valid values
a|causal_clustering.kubernetes.token is a path
|Default value
m|/var/run/secrets/kubernetes.io/serviceaccount/token
|===

[[cc-setting_causal_clustering.label_token_id_allocation_size]]
.causal_clustering.label_token_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.label_token_id_allocation_size is an integer
|Default value
m|32
|===

[[cc-setting_causal_clustering.label_token_name_id_allocation_size]]
.causal_clustering.label_token_name_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.label_token_name_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.last_applied_state_size]]
.causal_clustering.last_applied_state_size
[cols="<1h,<4"]
|===
|Description
a|The maximum file size before the storage file is rotated (in unit of entries)
|Valid values
a|causal_clustering.last_applied_state_size is an integer
|Default value
m|1000
|===

[[cc-setting_causal_clustering.leader_election_timeout]]
.causal_clustering.leader_election_timeout
[cols="<1h,<4"]
|===
|Description
a|The time limit within which a new leader election will occur if no messages are received.
|Valid values
a|causal_clustering.leader_election_timeout is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|7s
|===

[[cc-setting_causal_clustering.load_balancing.config]]
.causal_clustering.load_balancing.config
[cols="<1h,<4"]
|===
|Description
a|The configuration must be valid for the configured plugin and usually existsunder matching subkeys, e.g. ..config.server_policies.*This is just a top-level placeholder for the plugin-specific configuration.
|Valid values
a|causal_clustering.load_balancing.config is a string
|Default value
m|
|===

[[cc-setting_causal_clustering.load_balancing.plugin]]
.causal_clustering.load_balancing.plugin
[cols="<1h,<4"]
|===
|Description
a|The load balancing plugin to use.
|Valid values
a|causal_clustering.load_balancing.plugin is a string
|Default value
m|server_policies
|===

[[cc-setting_causal_clustering.load_balancing.shuffle]]
.causal_clustering.load_balancing.shuffle
[cols="<1h,<4"]
|===
|Description
a|Enables shuffling of the returned load balancing result.
|Valid values
a|causal_clustering.load_balancing.shuffle is a boolean
|Default value
m|true
|===

[[cc-setting_causal_clustering.log_shipping_max_lag]]
.causal_clustering.log_shipping_max_lag
[cols="<1h,<4"]
|===
|Description
a|The maximum lag allowed before log shipping pauses (in unit of entries)
|Valid values
a|causal_clustering.log_shipping_max_lag is an integer
|Default value
m|256
|===

[[cc-setting_causal_clustering.middleware_logging.level]]
.causal_clustering.middleware_logging.level
[cols="<1h,<4"]
|===
|Description
a|The level of middleware logging.
|Valid values
a|causal_clustering.middleware_logging.level is an integer
|Default value
m|500
|===

[[cc-setting_causal_clustering.minimum_core_cluster_size_at_formation]]
.causal_clustering.minimum_core_cluster_size_at_formation
[cols="<1h,<4"]
|===
|Description
a|Minimum number of Core machines initially required to form a cluster. The cluster will form when at least this many Core members have discovered each other.
|Valid values
a|causal_clustering.minimum_core_cluster_size_at_formation is an integer which is minimum `2`
|Default value
m|3
|===

[[cc-setting_causal_clustering.minimum_core_cluster_size_at_runtime]]
.causal_clustering.minimum_core_cluster_size_at_runtime
[cols="<1h,<4"]
|===
|Description
a|The minimum size of the dynamically adjusted voting set (which only core members may be a part of). Adjustments to the voting set happen automatically as the availability of core members changes, due to explicit operations such as starting or stopping a member, or unintended issues such as network partitions. Note that this dynamic scaling of the voting set is generally desirable as under some circumstances it can increase the number of instance failures which may be tolerated. A majority of the voting set must be available before voting in or out members.
|Valid values
a|causal_clustering.minimum_core_cluster_size_at_runtime is an integer which is minimum `2`
|Default value
m|3
|===

[[cc-setting_causal_clustering.multi_dc_license]]
.causal_clustering.multi_dc_license
[cols="<1h,<4"]
|===
|Description
a|Enable multi-data center features. Requires appropriate licensing.
|Valid values
a|causal_clustering.multi_dc_license is a boolean
|Default value
m|false
|===

[[cc-setting_causal_clustering.neostore_block_id_allocation_size]]
.causal_clustering.neostore_block_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of NEOSTORE_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.neostore_block_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.node_id_allocation_size]]
.causal_clustering.node_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of NODE IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.node_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.node_labels_id_allocation_size]]
.causal_clustering.node_labels_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of NODE_LABELS IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.node_labels_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.property_id_allocation_size]]
.causal_clustering.property_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of PROPERTY IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.property_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.property_key_token_id_allocation_size]]
.causal_clustering.property_key_token_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.property_key_token_id_allocation_size is an integer
|Default value
m|32
|===

[[cc-setting_causal_clustering.property_key_token_name_id_allocation_size]]
.causal_clustering.property_key_token_name_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.property_key_token_name_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.protocol_implementations.catchup]]
.causal_clustering.protocol_implementations.catchup
[cols="<1h,<4"]
|===
|Description
a|Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions.
|Valid values
a|causal_clustering.protocol_implementations.catchup is a list separated by "," where items are an integer
|Default value
m|[]
|===

[[cc-setting_causal_clustering.protocol_implementations.compression]]
.causal_clustering.protocol_implementations.compression
[cols="<1h,<4"]
|===
|Description
a|Network compression algorithms that this instance will allow in negotiation as a comma-separated list. Listed in descending order of preference for incoming connections. An empty list implies no compression. For outgoing connections this merely specifies the allowed set of algorithms and the preference of the  remote peer will be used for making the decision. Allowable values: [Gzip,Snappy,Snappy_validating,LZ4,LZ4_high_compression,LZ_validating,LZ4_high_compression_validating]
|Valid values
a|causal_clustering.protocol_implementations.compression is a list separated by "," where items are a string
|Default value
m|[]
|===

[[cc-setting_causal_clustering.protocol_implementations.raft]]
.causal_clustering.protocol_implementations.raft
[cols="<1h,<4"]
|===
|Description
a|Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions.
|Valid values
a|causal_clustering.protocol_implementations.raft is a list separated by "," where items are an integer
|Default value
m|[]
|===

[[cc-setting_causal_clustering.pull_interval]]
.causal_clustering.pull_interval
[cols="<1h,<4"]
|===
|Description
a|Interval of pulling updates from cores.
|Valid values
a|causal_clustering.pull_interval is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|1s
|===

[[cc-setting_causal_clustering.raft_advertised_address]]
.causal_clustering.raft_advertised_address
[cols="<1h,<4"]
|===
|Description
a|Advertised hostname/IP address and port for the RAFT server.
|Valid values
a|an advertised socket address
|Default value
m|localhost:7000
|===

[[cc-setting_causal_clustering.raft_in_queue_max_batch_bytes]]
.causal_clustering.raft_in_queue_max_batch_bytes
[cols="<1h,<4"]
|===
|Description
a|Largest batch processed by RAFT in bytes.
|Valid values
a|causal_clustering.raft_in_queue_max_batch_bytes is a byte size (valid multipliers are `k`, `m`, `g`, `K`, `M`, `G`)
|Default value
m|8388608
|===

[[cc-setting_causal_clustering.raft_in_queue_max_bytes]]
.causal_clustering.raft_in_queue_max_bytes
[cols="<1h,<4"]
|===
|Description
a|Maximum number of bytes in the RAFT in-queue.
|Valid values
a|causal_clustering.raft_in_queue_max_bytes is a byte size (valid multipliers are `k`, `m`, `g`, `K`, `M`, `G`)
|Default value
m|2147483648
|===

[[cc-setting_causal_clustering.raft_listen_address]]
.causal_clustering.raft_listen_address
[cols="<1h,<4"]
|===
|Description
a|Network interface and port for the RAFT server to listen on.
|Valid values
a|a listen socket address
|Default value
m|127.0.0.1:7000
|===

[[cc-setting_causal_clustering.raft_log_implementation]]
.causal_clustering.raft_log_implementation
[cols="<1h,<4"]
|===
|Description
a|RAFT log implementation.
|Valid values
a|causal_clustering.raft_log_implementation is a string
|Default value
m|SEGMENTED
|===

[[cc-setting_causal_clustering.raft_log_prune_strategy]]
.causal_clustering.raft_log_prune_strategy
[cols="<1h,<4"]
|===
|Description
a|RAFT log pruning strategy.
|Valid values
a|causal_clustering.raft_log_prune_strategy is a string
|Default value
m|1g size
|===

[[cc-setting_causal_clustering.raft_log_pruning_frequency]]
.causal_clustering.raft_log_pruning_frequency
[cols="<1h,<4"]
|===
|Description
a|RAFT log pruning frequency.
|Valid values
a|causal_clustering.raft_log_pruning_frequency is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|600s
|===

[[cc-setting_causal_clustering.raft_log_reader_pool_size]]
.causal_clustering.raft_log_reader_pool_size
[cols="<1h,<4"]
|===
|Description
a|RAFT log reader pool size.
|Valid values
a|causal_clustering.raft_log_reader_pool_size is an integer
|Default value
m|8
|===

[[cc-setting_causal_clustering.raft_log_rotation_size]]
.causal_clustering.raft_log_rotation_size
[cols="<1h,<4"]
|===
|Description
a|RAFT log rotation size.
|Valid values
a|causal_clustering.raft_log_rotation_size is a byte size (valid multipliers are `k`, `m`, `g`, `K`, `M`, `G`) which is minimum `1024`
|Default value
m|262144000
|===

[[cc-setting_causal_clustering.raft_membership_state_size]]
.causal_clustering.raft_membership_state_size
[cols="<1h,<4"]
|===
|Description
a|The maximum file size before the membership state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.raft_membership_state_size is an integer
|Default value
m|1000
|===

[[cc-setting_causal_clustering.raft_term_state_size]]
.causal_clustering.raft_term_state_size
[cols="<1h,<4"]
|===
|Description
a|The maximum file size before the term state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.raft_term_state_size is an integer
|Default value
m|1000
|===

[[cc-setting_causal_clustering.raft_vote_state_size]]
.causal_clustering.raft_vote_state_size
[cols="<1h,<4"]
|===
|Description
a|The maximum file size before the vote state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.raft_vote_state_size is an integer
|Default value
m|1000
|===

[[cc-setting_causal_clustering.read_replica_time_to_live]]
.causal_clustering.read_replica_time_to_live
[cols="<1h,<4"]
|===
|Description
a|Time To Live before read replica is considered unavailable.
|Valid values
a|causal_clustering.read_replica_time_to_live is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's') which is minimum `PT1M`
|Default value
m|60s
|===

[[cc-setting_causal_clustering.reconnection_backoff]]
.causal_clustering.reconnection_backoff
[cols="<1h,<4"]
|===
|Description
a|Minimum time between connection attempts.
|Valid values
a|causal_clustering.reconnection_backoff is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|5s
|===

[[cc-setting_causal_clustering.refuse_to_be_leader]]
.causal_clustering.refuse_to_be_leader
[cols="<1h,<4"]
|===
|Description
a|Prevents the current instance from volunteering to become Raft leader. Defaults to false, and should only be used in exceptional circumstances by expert users. Using this can result in reduced availability for the cluster.
|Valid values
a|causal_clustering.refuse_to_be_leader is a boolean
|Default value
m|false
|===

[[cc-setting_causal_clustering.relationship_group_id_allocation_size]]
.causal_clustering.relationship_group_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_GROUP IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.relationship_group_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.relationship_id_allocation_size]]
.causal_clustering.relationship_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.relationship_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.relationship_type_token_id_allocation_size]]
.causal_clustering.relationship_type_token_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.relationship_type_token_id_allocation_size is an integer
|Default value
m|32
|===

[[cc-setting_causal_clustering.relationship_type_token_name_id_allocation_size]]
.causal_clustering.relationship_type_token_name_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.relationship_type_token_name_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.replicated_lock_token_state_size]]
.causal_clustering.replicated_lock_token_state_size
[cols="<1h,<4"]
|===
|Description
a|The maximum file size before the replicated lock token state file is rotated (in unit of entries)
|Valid values
a|causal_clustering.replicated_lock_token_state_size is an integer
|Default value
m|1000
|===

[[cc-setting_causal_clustering.replication_retry_timeout_base]]
.causal_clustering.replication_retry_timeout_base
[cols="<1h,<4"]
|===
|Description
a|The initial timeout until replication is retried. The timeout will increase exponentially.
|Valid values
a|causal_clustering.replication_retry_timeout_base is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|10s
|===

[[cc-setting_causal_clustering.replication_retry_timeout_limit]]
.causal_clustering.replication_retry_timeout_limit
[cols="<1h,<4"]
|===
|Description
a|The upper limit for the exponentially incremented retry timeout.
|Valid values
a|causal_clustering.replication_retry_timeout_limit is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|60s
|===

[[cc-setting_causal_clustering.schema_id_allocation_size]]
.causal_clustering.schema_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of SCHEMA IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.schema_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.server_groups]]
.causal_clustering.server_groups
[cols="<1h,<4"]
|===
|Description
a|A list of group names for the server used when configuring load balancing and replication policies.
|Valid values
a|causal_clustering.server_groups is a list separated by "," where items are a string
|Default value
m|[]
|===

[[cc-setting_causal_clustering.ssl_policy]]
.causal_clustering.ssl_policy
[cols="<1h,<4"]
|===
|Description
a|Name of the SSL policy to be used by the clustering, as defined under the dbms.ssl.policy.* settings. If no policy is configured then the communication will not be secured.
|Valid values
a|causal_clustering.ssl_policy is a string
|===

[[cc-setting_causal_clustering.state_machine_apply_max_batch_size]]
.causal_clustering.state_machine_apply_max_batch_size
[cols="<1h,<4"]
|===
|Description
a|The maximum number of operations to be batched during applications of operations in the state machines.
|Valid values
a|causal_clustering.state_machine_apply_max_batch_size is an integer
|Default value
m|16
|===

[[cc-setting_causal_clustering.state_machine_flush_window_size]]
.causal_clustering.state_machine_flush_window_size
[cols="<1h,<4"]
|===
|Description
a|The number of operations to be processed before the state machines flush to disk.
|Valid values
a|causal_clustering.state_machine_flush_window_size is an integer
|Default value
m|4096
|===

[[cc-setting_causal_clustering.store_copy_max_retry_time_per_request]]
.causal_clustering.store_copy_max_retry_time_per_request
[cols="<1h,<4"]
|===
|Description
a|Maximum retry time per request during store copy. Regular store files and indexes are downloaded in separate requests during store copy. This configures the maximum time failed requests are allowed to resend. 
|Valid values
a|causal_clustering.store_copy_max_retry_time_per_request is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|1200s
|===

[[cc-setting_causal_clustering.string_block_id_allocation_size]]
.causal_clustering.string_block_id_allocation_size
[cols="<1h,<4"]
|===
|Description
a|The size of the ID allocation requests Core servers will make when they run out of STRING_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.
|Valid values
a|causal_clustering.string_block_id_allocation_size is an integer
|Default value
m|1024
|===

[[cc-setting_causal_clustering.transaction_advertised_address]]
.causal_clustering.transaction_advertised_address
[cols="<1h,<4"]
|===
|Description
a|Advertised hostname/IP address and port for the transaction shipping server.
|Valid values
a|an advertised socket address
|Default value
m|localhost:6000
|===

[[cc-setting_causal_clustering.transaction_listen_address]]
.causal_clustering.transaction_listen_address
[cols="<1h,<4"]
|===
|Description
a|Network interface and port for the transaction shipping server to listen on. Please note that it is also possible to run the backup client against this port so always limit access to it via the firewall and configure an ssl policy.
|Valid values
a|a listen socket address
|Default value
m|127.0.0.1:6000
|===

[[cc-setting_causal_clustering.unknown_address_logging_throttle]]
.causal_clustering.unknown_address_logging_throttle
[cols="<1h,<4"]
|===
|Description
a|Throttle limit for logging unknown cluster member address.
|Valid values
a|causal_clustering.unknown_address_logging_throttle is a duration (Valid units are: 'ms', 's', 'm' and 'h'; default unit is 's')
|Default value
m|10s
|===

[[cc-setting_causal_clustering.upstream_selection_strategy]]
.causal_clustering.upstream_selection_strategy
[cols="<1h,<4"]
|===
|Description
a|An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.
|Valid values
a|causal_clustering.upstream_selection_strategy is a list separated by "," where items are a string
|Default value
m|[default]
|===

[[cc-setting_causal_clustering.user_defined_upstream_strategy]]
.causal_clustering.user_defined_upstream_strategy
[cols="<1h,<4"]
|===
|Description
a|Configuration of a user-defined upstream selection strategy. The user-defined strategy is used if the list of strategies (`<<config_causal_clustering.upstream_selection_strategy,causal_clustering.upstream_selection_strategy>>`) includes the value `user_defined`. 
|Valid values
a|causal_clustering.user_defined_upstream_strategy is a string
|Default value
m|
|===

