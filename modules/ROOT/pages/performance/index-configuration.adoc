[[index-configuration]]
= Index configuration
:description: How to configure indexes to enhance performance in search, and to enable full-text search.

This page describes how to configure Neo4j indexes to enhance search performance and enable full-text search.
The supported index types are:

* xref:performance/index-configuration.adoc#index-configuration-btree[B-tree]
* xref:performance/index-configuration.adoc#index-configuration-text[Text]
* xref:performance/index-configuration.adoc#index-configuration-fulltext[Full-text]
* xref:performance/index-configuration.adoc#index-configuration-token-lookup[Token lookup]

All four types of indexes can be created and dropped using Cypher, and they can also all be used to index both nodes and relationships.
The token lookup index is the only index present by default in the database.

B-tree, text, and full-text indexes provide a mapping from a property value to an entity (node or relationship).
Token lookup indexes are different and provide a mapping from labels to nodes or relationship types to relationships instead of between properties and entities.

Users are not required to know the difference between the various indexes to use them since Cypher’s query planner decides which index to use in which situation.

For further details on creating, querying and dropping indexes, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance] and link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-full-text-search[Cypher Manual -> Indexes to support full-text search].

The type of an index can be identified according to the following table:

[options="header", cols="a,m,m"]
|===
| Index type            | Cypher command          | Core API
| B-tree index          | SHOW BTREE INDEXES      | org.neo4j.graphdb.schema.IndexType#BTREE
| Text index            | SHOW EXT INDEXES        | org.neo4j.graphdb.schema.IndexType#TEXT
| Full-text index       | SHOW FULLTEXT INDEXES   | org.neo4j.graphdb.schema.IndexType#FULLTEXT
| Token lookup index    | SHOW LOOKUP INDEXES     | org.neo4j.graphdb.schema.IndexType#LOOKUP
|===


[role=deprecated]
[[index-configuration-btree]]
== B-tree indexes

B-tree indexes are deprecated, partially replaced for now, and will be fully replaced in 5.0 by the xref:performance/index-configuration.adoc#future-indexes[future indexes].
In 4.4, B-tree indexes are still the correct alternative, except when the `lucene+native-3.0` provider is used.
A new xref:performance/index-configuration.adoc#index-configuration-text[text index] type has been introduced to handle the case `lucene+native-3.0` covered for single property strings.

B-tree indexes are suitable for exact lookups on all types of values, range scans, full scans, and prefix searches.
They can be backed by two different index providers, `native-btree-1.0` and `lucene+native-3.0`.
If not explicitly set, `native-btree-1.0` is used.


[[index-configuration-btree-limitations]]
=== Limitations

B-tree indexes have some limitations that can be worked around by using text indexes or the deprecated index provider `lucene+native-3.0` instead.

[[index-configuration-btree-limitations-contains-ends-with]]
==== Limitations for queries using `CONTAINS` and `ENDS WITH`

The index provider `native-btree-1.0` has limited support for `ENDS WITH` and `CONTAINS` queries.
These queries are not able to do an optimized search as per queries that use `STARTS WITH`, `=`, and `<>`.
Instead, the index result is a stream of an index scan with filtering.

`ENDS WITH` and `CONTAINS` queries are natively supported by text indexes, and these types of queries are handled by a text index in a more performant way than a B-tree index.
Even though the deprecated index provider `lucene+native-3.0` can also be used for these queries, it provides no extra value over a text index and it will be removed in 5.0.
[NOTE]
====
`lucene+native-3.0` and text indexes only support `ENDS WITH` and `CONTAINS` for single property strings.
====

* For details about execution plans, refer to  link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/execution-plans[Cypher Manual -> Execution plans].
* For details about string operators, refer to  link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/syntax/operators#query-operators-comparison[Cypher Manual -> Operators].


[[index-configuration-btree-limitations-key-sizes]]
==== Limitations on key size

The index provider `native-btree-1.0` has a key size limit of approximately 8kB.

If a transaction exceeds this limit for any of its changes, it will fail before committing any changes.
If the limit is reached during index population, the resulting index will be in a failed state and cannot be used for any queries.

In such a situation, you can use the index provider `lucene+native-3.0`.
This provider has a key size limit for single property strings of approximately 32kB.


[[index-configuration-btree-limitations-workarounds]]
==== Workarounds to address limitations

To work around problems with key size or performance issues related to `ENDS WITH` or `CONTAINS`, you can use the text index type or the deprecated index provider `lucene+native-3.0`.
However, it only works for single-property string indexes.

*Creating a text index* is recommended to work around key size or performance issues.
For details on the syntax for creating a text index, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance].
For more information about text indexes see xref:performance/index-configuration.adoc#index-configuration-text[Text indexes].

Alternatively, you can use one of the following methods:

* [deprecated]#_Use `lucene+native-3.0` in the `OPTIONS` clause in the `CREATE` command._#
+
Note that this option uses the `lucene+native-3.0` index provider, which is deprecated and will be removed in a future release.
+
The Cypher commands for index creation, unique property constraint creation, and node key creation contain an optional `OPTIONS` clause, which can be used to specify the index provider.
+
For details on indexes, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance].
For further information on constraints, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints].
* [deprecated]#_Use a built-in procedure._#
+
Note that this option uses deprecated built-in procedures that will be removed in a future release.
These have been replaced with the Cypher commands in Option 1.
+
The built-in procedures `db.createIndex`, `db.createUniquePropertyConstraint`, and `db.createNodeKey` can be used to specify the index provider on index creation, unique property constraint creation, and node key creation.
+
For details on constraints, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints], and for more information on built-in procedures, see xref:reference/procedures.adoc[Procedures].
* [deprecated]#_Change the config._#
+
Note that this option uses the index setting `dbms.index.default_schema_provider`, which has been deprecated and will be removed in a future release.
It will be a fully internal concern which index provider an index uses.

. Configure the setting `dbms.index.default_schema_provider` to the one required.
. Restart Neo4j.
. Drop and recreate the relevant index.
. Change `dbms.index.default_schema_provider` back to the original value.
. Restart Neo4j.

+
The recommended way to set an index provider for an index is to use the `OPTIONS` clause for index creation, unique property constraint creation, and node key creation.
For more information, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance] and link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints].


[[index-configuration-btree-migration]]
=== Index migration

When upgrading a 3.5 store to 4.4.34, all indexes are upgraded to the latest index version and rebuilt automatically, except for those previously using Lucene for single-property strings.
They have been upgraded to a fallback version that uses Lucene for those properties.
Note that they still need to be rebuilt.
For more information, see link:{neo4j-docs-base-uri}/upgrade-migration-guide/current/version-4/migration/neo4j-indexes/[Upgrade and Migration Guide -> Neo4j indexes].


[[index-configuration-btree-procedures]]
=== Procedures to create an index and index-backed constraint

Indexes and constraints are best created using the optional `OPTIONS` clause of the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}//indexes-for-search-performance/#administration-indexes-examples[`CREATE` Cypher command].
Alternatively, you can create them via the deprecated procedures described in the following example:

The following procedures provide the option to specify both index provider and index settings (optional).
Note that settings keys need to be escaped with back-ticks if they contain dots.

.Use `db.createIndex` procedure to create an index and specify the index provider and settings
====

[source, cypher]
----
CALL db.createIndex("MyIndex", ["Person"], ["name"], "native-btree-1.0", {`spatial.cartesian.max`: [100.0,100.0], `spatial.cartesian.min`: [-100.0,-100.0]})
----
====

.Use procedures to create an index and an index-backed constraint without specifying the setting map
====

If a settings map is not provided, the settings are picked up from the xref:configuration/neo4j-conf.adoc[Neo4j config file], the same way as when creating an index or constraint through Cypher.

.Use `db.createIndex` to create an index without specifying the setting map
[source, cypher]
----
CALL db.createIndex("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----

.Use `db.createUniquePropertyConstraint` to create a node property uniqueness constraint without specifying the setting map
[source, cypher]
----
CALL db.createUniquePropertyConstraint("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----

.Use `db.createNodeKey` to create node key constraint without specifying the setting map
[source, cypher]
----
CALL db.createNodeKey("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----
====


[[index-configuration-text]]
== Text indexes

Text indexes are a type of single-property index and only index properties with string values, unlike B-tree indexes.
They are specifically designed to deal with `ENDS WITH` or `CONTAINS` queries efficiently.
They are used through Cypher and support a smaller set of string queries.
Even though text indexes support other text queries, `ENDS WITH` or `CONTAINS` queries are the only ones for which this index type provides an advantage over a B-tree index.

For more information, refer to link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/query-tuning/indexes[Cypher Manual -> Query Tuning -> The use of indexes] and link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance].

[[index-configuration-text-limitations]]
=== Limitations

Text indexes only index single property strings.
If the property to index can contain several value types, but string-specific queries are also performed, it is possible to have both a B-tree and a text index on the same schema.

The index has a key size limit for single property strings of around 32kB.
If a transaction reaches the key size limit for one or more of its changes, that transaction fails before committing any changes.
If the limit is reached during index population, the resulting index is in a failed state, and as such is not usable for any queries.


[[index-configuration-fulltext]]
== Full-text indexes

Full-text indexes are optimized for indexing and searching text.
They make it possible to write queries that match the _contents_ of indexed string properties.
In other words, they are used for queries that demand an understanding of language and only index string data.
They must also be queried explicitly via procedures, as Cypher does not make plans that rely on them.

An example of a use case for full-text indexes is parsing a book for a specific term and taking advantage of the knowledge that the book is written in a certain language.
The use of an _analyzer_ for that language enables the exclusion of words that are not relevant for the search (for example, _"if"_ and _"and"_) and includes conjugations of words that are.

Another use case example is indexing the various address fields and text data in a corpus of emails.
Indexing this data using the `email` analyzer makes it possible to find all emails sent from, to, or about an email account.

In contrast to B-tree and text indexes, full-text indexes are queried using built-in procedures.
They are, however, created and dropped using Cypher.
The use of full-text indexes does require familiarity with how they operate.


Full-text indexes are powered by the http://lucene.apache.org/[Apache Lucene] indexing and search library.
A full description of how to create and use full-text indexes is provided in the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-full-text-search/[Cypher Manual -> Indexes to support full-text search].


[[index-configuration-fulltext-configuration]]
=== Configuration

The following options are available for configuring full-text indexes.
For a complete list of Neo4j procedures, see link:{neo4j-docs-base-uri}/operations-manual/{page-version}/reference/procedures/[Operations Manual -> Procedures].

`dbms.index.fulltext.default_analyzer`::
The default analyzer for full-text indexes.
This setting takes effect when creating an index and is remembered as an index-specific setting.
+
The list of possible analyzers is available through the `db.index.fulltext.listAvailableAnalyzers()` Cypher procedure.
+
Unless otherwise specified, the default analyzer is standard-no-stop-words, the same as the StandardAnalyzer from Lucene, except no stop-words are filtered out.

`dbms.index.fulltext.eventually_consistent`::
Used to declare whether full-text indexes should be eventually consistent or not.
This setting only has effect when a full-text index is created and is remembered as an index-specific setting from then on.
+
Indexes usually are fully consistent, and the committing of a transaction returns once both the store and the indexes are updated.
On the other hand, eventually_consistent full-text indexes are not updated as part of the commit; instead, their updates are queued up and applied in a background thread.
This means there can be a short delay between committing a change and the change becoming visible via any eventually consistent full-text indexes.
This delay is just an artefact of the queueing and is usually relatively small since.
Eventually, consistent indexes are updated "as soon as possible".
+
This is turned off by default, and full-text indexes are fully consistent.

`dbms.index.fulltext.eventually_consistent_index_update_queue_max_length`::
Eventually_consistent full-text indexes have their updates queued up and applied in a background thread, and this setting determines the maximum size of that update queue.
If the maximum queue size is reached, the commit transactions block and wait until there is more room in the queue before adding more updates.
+
This setting applies to all eventually_consistent full-text indexes, and they all use the same queue.
Due to considerations regarding heap space usage, the maximum queue length must be at least 1 index update and no more than 50 million.
+
The default maximum queue length is 10.000 index updates.

[[index-configuration-token-lookup]]
== Token lookup indexes

Token lookup indexes, as the name suggests, are used to look up nodes with a specific label or relationships of a specific type.
A token lookup index is always created over all labels or relationship types, respectively, and hence, a database can only have a maximum of two token lookup indexes—one for nodes and one for relationships.

Token lookup indexes are introduced in 4.3, and whereas the relationship type lookup index is a new concept, the node label lookup index is not.
The latter evolved from the label scan store, which has existed in various forms for a long time.
The node label lookup index provides the same functionality as the former label scan store. Still, it has additional features common to all indexes, such as the ability to be created and dropped using a non-blocking population.

[[index-configuration-token-lookup-use-and-significance]]
=== Use and significance

Token lookup indexes are the most important indexes that can be present in a database.
They are essential for both Cypher queries and Core API operations.
More importantly, their presence significantly speeds up the population of other indexes: the node label lookup index for node B-tree and full-text indexes and the relationship type lookup index for the corresponding relationship indexes.

The node label lookup index is essential for queries that match a node by one or more labels.
It can be used even when matching labels and properties of a node if no suitable B-tree indexes are available.
This is essential, considering that no B-tree indexes are defined by default.
In other words, a node label lookup index is often the best approach to a query that matches labels unless the user has defined a more appropriate B-tree index.
Accordingly, the relationship type lookup index does the same for relationships and their types.

Most queries are executed by matching nodes and expanding their relationships, and hence, the node label lookup index is slightly more significant than the relationship type lookup index.

Since these indexes are important for both query execution and index population, they should be carefully considered before being dropped.

Node and relationship type lookup indexes are present by default in all databases created in 4.3 and onwards.


[[index-configuration-token-lookup-upgrade]]
=== Databases created before 4.3

By default, databases created before 4.3 get only a node label lookup index when used in a DBMS of version 4.3 or later.
This is to preserve the backward compatibility and performance characteristics of such databases.

Such databases can get a relationship-type lookup index by explicitly creating it through Cypher if needed.


[NOTE]
====
Creating a relationship-type lookup index on a large database can take significant time, as all relationships must be scanned when populating such an index.
====

When used in a Neo4j 4.3 or later, databases created before 4.3 automatically get a node label lookup index. This index is created by converting the former label scan store and naming it `__org_neo4j_schema_index_label_scan_store_converted_to_token_index`.
This index name is reserved from 4.3 onwards, and an error is returned if you attempt to create a user-defined index with this name.
Similarly, in the unlikely situation when an index with such a name exists in a previous version, it must be dropped and recreated with a different name before upgrading to 4.3.

The following table summarizes which token lookup indexes and label scan stores are present by default in various versions.
Note that the table represents only the default indexes and that the relationship type lookup index can be created explicitly through Cypher if needed.

[options="header"]
|===
| Database created 2+<| before 4.3          | from 4.3
| Neo4j version | < 4.3          2+<| >= 4.3
| Label scan store | yes | no | no
| Node label lookup index  | no | yes | yes
| Relationship type lookup index  | no | no | yes
|===

[[future-indexes]]
== Future indexes

Two new index types, range and point index, will be introduced in 5.0.
They will, together with the text index, replace the deprecated B-tree indexes.

Like the B-tree index, the range index will index all types of values and be good for exact lookups on all types of values, range scans,
full scans, and prefix searches.
The difference is that the range index will not support spatial queries and therefore will not have the same config options.
It will still index the point values to support full scans, but if spatial queries are needed, a point index should be created.

The point index is a highly specialized single-property index that is optimized for spatial queries.
It only indexes point values and exact lookups are the only non-spatial query it supports.

These indexes can be created on the same combination of property and label/relationship type if the functionality of both is needed.

It is possible to create and drop these index types, but they cannot be used in queries yet.
They are introduced now to allow a smoother migration to 5.0 later.
See link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance#indexes-future-indexes[Cypher Manual -> Indexes for search performance -> Future indexes] for the new syntax.
