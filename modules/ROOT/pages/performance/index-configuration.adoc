[[index-configuration]]
= Index configuration
:description: How to configure indexes to enhance performance in search, and to enable full-text search.


[[index-configuration-introduction]]
== Introduction

In Neo4j there are three different index types: xref:performance/index-configuration.adoc#index-configuration-btree[b-tree], xref:performance/index-configuration.adoc#index-configuration-fulltext[full-text],
and xref:performance/index-configuration.adoc#index-configuration-token-lookup[token lookup].

All three types of indexes can be created and dropped using Cypher and they can also all be used to index both nodes and relationships.
The token lookup index is the only index present by default in the database.

B-tree and full-text indexes provide mapping from a property value to an entity (node or relationship).
Token lookup indexes are different and provide mapping from labels to nodes or from relationship types to relationships instead of between properties and entities.

Users are not required to know the difference between the various indexes in order to use them, since the Cypher query planner decides which index should be used in which situation.

For more information on the different index types, refer to link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance] and link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-full-text-search[Cypher Manual -> Indexes to support full-text search].

// For details on creating, using and dropping b-tree indexes, see <<cypher-manual#administration-indexes-search-performance, Cypher Manual -> Indexes>>.


.Supported index types
[options="header", cols="a,m,m"]
|===
| Index type            | Cypher command          | Core API
| B-tree index          | SHOW BTREE INDEXES      | org.neo4j.graphdb.schema.IndexType#BTREE
| Full-text index       | SHOW FULLTEXT INDEXES   | org.neo4j.graphdb.schema.IndexType#FULLTEXT
| Token lookup index    | SHOW LOOKUP INDEXES     | org.neo4j.graphdb.schema.IndexType#LOOKUP
|===


[[index-configuration-btree]]
== B-tree indexes

B-tree indexes are good for exact lookups on all types of values, range scans, full scans, and prefix searches.
They can be backed by two different index providers, `native-btree-1.0` and `lucene+native-3.0`.
If not explicitly set, `native-btree-1.0` is used.


[[index-configuration-btree-limitations]]
=== Limitations

There are a few limitations for b-tree indexes, listed below together with suggested workarounds.


[[index-configuration-btree-limitations-contains-ends-with]]
==== Limitations for queries  using `CONTAINS` and `ENDS WITH`

The index provider `native-btree-1.0` has limited support for `ENDS WITH` and `CONTAINS` queries.
These queries are not able to do an optimized search as per queries that use `STARTS WITH`, `=`, and `<>`.
Instead, the index result is a stream of an index scan with filtering.

In the future, `ENDS WITH` and `CONTAINS` queries will be supported with full-text indexes, but for now the index provider `lucene+native-3.0` can be used instead.
Please note that `lucene+native-3.0` only has support for `ENDS WITH` and `CONTAINS` for single property strings.

* For details about execution plans, refer to  link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/execution-plans[Cypher Manual -> Execution plans].
* For details about string operators, refer to  link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/syntax/operators#query-operators-comparison[Cypher Manual -> Operators].


[[index-configuration-btree-limitations-key-sizes]]
==== Limitations on key size

The index provider `native-btree-1.0` has a key size limit of approximately 8kB.

If a transaction exceeds this limit for any of its changes, it will fail before committing any changes.
If the limit is reached during index population, the resulting index will be in a failed state and cannot be used for any queries.

In such a situation, you can use the index provider `lucene+native-3.0`.
This provider has a key size limit for single property strings of approximately 32kB.


[[index-configuration-btree-limitations-workarounds]]
==== Workarounds to address limitations

To work around problems with key size, or performance issues related to `ENDS WITH` or `CONTAINS`, you can use the index provider `lucene+native-3.0`.
This only works for single-property string indexes.

This can be done using either of the following methods:

Option 1. Use the `OPTIONS` clause with the `CREATE` command (recommended)::
The Cypher commands for index creation, unique property constraint creation, and node key creation contain an optional `OPTIONS` clause.
This clause can be used to specify an index provider.
+
For details on indexes, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance].
For details on constraints, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints].


Option 2. Use a built-in procedure label:deprecated[]::
Please note that this option uses built-in procedures that have been deprecated, and will be removed in a future release.
These have been replaced with the Cypher commands in Option 1.
+
The built-in procedures `db.createIndex`, `db.createUniquePropertyConstraint`, and `db.createNodeKey` can be used to specify the index provider on index creation, unique property constraint creation, and node key creation.
+
For details on constraints, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints], and for more information on built-in procedures, see xref:reference/procedures.adoc[Procedures].


Option 3. Change the config label:deprecated[]::
Please note that this option uses the index setting `dbms.index.default_schema_provider`, which has been deprecated and will be removed in a future release.
It will be a fully internal concern which index provider an index is using.
+
. Configure the setting `dbms.index.default_schema_provider` to the one required.
. Restart Neo4j.
. Drop and recreate the relevant index.
. Change `dbms.index.default_schema_provider` back to the original value.
. Restart Neo4j.
+
The recommended way to set an index provider for an index is to use the `OPTIONS` clause for index creation, unique property constraint creation, and node key creation.
For more information, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance] and link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints].

[[index-configuration-btree-migration]]
=== Index migration

When upgrading a 3.5 store to {neo4j-version-exact}, all indexes are upgraded to the latest index version and rebuilt automatically, except for those previously using Lucene for single-property strings.
They have been upgraded to a fallback version that uses Lucene for those properties.
Note that they still need to be rebuilt.

For more information, see link:{neo4j-docs-base-uri}/upgrade-migration-guide/current/migration/index-upgrade/[Upgrade and Migration Guide -> Neo4j indexes].

[[index-configuration-btree-procedures]]
=== Procedures to create an index and index-backed constraint

label:deprecated[]

Indexes and constraints are best created through link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher] but can still be created through the deprecated procedures described in the example below.
Index provider and index settings can both be specified using the optional `OPTIONS` clause for the Cypher commands.

The following procedures provide the option to specify both index provider and index settings (optional).
Note that settings keys need to be escaped with back-ticks if they contain dots.

.Use `db.createIndex` procedure to create an index and specify the index provider and settings
====

[source, cypher]
----
CALL db.createIndex("MyIndex", ["Person"], ["name"], "native-btree-1.0", {`spatial.cartesian.max`: [100.0,100.0], `spatial.cartesian.min`: [-100.0,-100.0]})
----
====

.Use procedures to create an index and an index-backed constraint without specifying the setting map
====

If a settings map is not provided, the settings are picked up from the xref:configuration/neo4j-conf.adoc[Neo4j config file], the same way as when creating an index or constraint through Cypher.

.Use `db.createIndex` to create an index without specifying the setting map
[source, cypher]
----
CALL db.createIndex("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----

.Use `db.createUniquePropertyConstraint` to create a node property uniqueness constraint without specifying the setting map
[source, cypher]
----
CALL db.createUniquePropertyConstraint("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----

.Use `db.createNodeKey` to create node key constraint without specifying the setting map
[source, cypher]
----
CALL db.createNodeKey("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----
====


[[index-configuration-fulltext]]
== Full-text indexes

Full-text indexes are optimized for indexing and searching text.
They make it possible to write queries that match the _contents_ of indexed string properties.
In other words, they are used for queries that demand an understanding of language and only index string data.
They must also be queried explicitly via procedures, as Cypher does not make plans that rely on them.

An example of a use case for full-text indexes is parsing a book for a specific term and taking advantage of the knowledge that the book is written in a certain language.
The use of an _analyzer_ for that language enables the exclusion of words that are not relevant for the search (for example, _"if"_ and _"and"_) and includes conjugations of words that are.

Another use case example is indexing the various address fields and text data in a corpus of emails.
Indexing this data using the `email` analyzer makes it possible to find all emails sent from, to, or about an email account.

In contrast to B-tree and text indexes, full-text indexes are queried using built-in procedures.
They are, however, created and dropped using Cypher.
The use of full-text indexes does require familiarity with how they operate.


Full-text indexes are powered by the http://lucene.apache.org/[Apache Lucene] indexing and search library.
A full description of how to create and use full-text indexes is provided in the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-full-text-search/[Cypher Manual -> Indexes to support full-text search].


[[index-configuration-fulltext-configuration]]
=== Configuration

The following options are available for configuring full-text indexes.
For a complete list of Neo4j procedures, see link:{neo4j-docs-base-uri}/operations-manual/{page-version}/reference/procedures/[Operations Manual -> Procedures].

`dbms.index.fulltext.default_analyzer`::
The default analyzer for full-text indexes.
This setting takes effect when creating an index and is remembered as an index-specific setting.
+
The list of possible analyzers is available through the `db.index.fulltext.listAvailableAnalyzers()` Cypher procedure.
+
Unless otherwise specified, the default analyzer is standard-no-stop-words, the same as the StandardAnalyzer from Lucene, except no stop-words are filtered out.

`dbms.index.fulltext.eventually_consistent`::
Used to declare whether full-text indexes should be eventually consistent or not.
This setting only has effect when a full-text index is created and is remembered as an index-specific setting from then on.
+
Indexes usually are fully consistent, and the committing of a transaction returns once both the store and the indexes are updated.
On the other hand, eventually consistent full-text indexes are not updated as part of the commit; instead, their updates are queued up and applied in a background thread.
This means there can be a short delay between committing a change and the change becoming visible via any eventually consistent full-text indexes.
This delay is just an artefact of the queueing and is usually relatively small since.
Eventually, consistent indexes are updated "as soon as possible".
+
This is turned off by default, and full-text indexes are fully consistent.

`dbms.index.fulltext.eventually_consistent_index_update_queue_max_length`::
Eventually consistent full-text indexes have their updates queued up and applied in a background thread, and this setting determines the maximum size of that update queue.
If the maximum queue size is reached, the commit transactions block and wait until there is more room in the queue before adding more updates.
+
This setting applies to all eventually consistent full-text indexes, and they all use the same queue.
Due to considerations regarding heap space usage, the maximum queue length must be at least 1 index update and no more than 50 million.
+
The default maximum queue length is 10.000 index updates.

[[index-configuration-token-lookup]]
== Token lookup indexes

Token lookup indexes, as the name suggests, are used to look up nodes with a specific label or relationships of a specific type.
A token lookup index is always created over all labels or relationship types, respectively, and hence, a database can only have a maximum of two token lookup indexes — one for nodes and one for relationships.

Token lookup indexes are introduced in 4.3, and whereas the relationship type lookup index is a new concept, the node label lookup index is not.
The latter evolved from the label scan store, which has existed in various forms for a long time.
The node label lookup index provides the same functionality as the former label scan store.
Still, it has additional features common to all indexes, such as the ability to be created and dropped using a non-blocking population.

[[index-configuration-token-lookup-use-and-significance]]
=== Use and significance

Token lookup indexes are the most important indexes that can be present in a database.
They are essential for both Cypher queries and Core API operations.
More importantly, their presence significantly speeds up the population of other indexes: the node label lookup index for node B-tree and full-text indexes and the relationship type lookup index for the corresponding relationship indexes.

The node label lookup index is essential for queries that match a node by one or more labels.
It can be used even when matching labels and properties of a node if no suitable B-tree indexes are available.
This is essential, considering that no B-tree indexes are defined by default.
In other words, a node label lookup index is often the best approach to a query that matches labels unless the user has defined a more appropriate B-tree index.
Accordingly, the relationship type lookup index does the same for relationships and their types.

Most queries are executed by matching nodes and expanding their relationships, and hence, the node label lookup index is slightly more significant than the relationship type lookup index.

Since these indexes are important for both query execution and index population, they should be carefully considered before being dropped.

Node and relationship type lookup indexes are present by default in all databases created in 4.3 and onwards.


[[index-configuration-token-lookup-upgrade]]
=== Databases created before version 4.3

By default, databases created before 4.3 get only a node label lookup index when used in a DBMS of version 4.3 or later.
This is to preserve the backward compatibility and performance characteristics of such databases.

Such databases can get a relationship-type lookup index by explicitly creating it through Cypher if needed.

If needed, such databases can also get a relationship type lookup index by creating it explicitly using Cypher.

[NOTE]
====
Creating a relationship-type lookup index on a large database can take significant time, as all relationships must be scanned when populating such an index.
====

When used in a Neo4j 4.3 or later, databases created before 4.3 automatically get a node label lookup index. This index is created by converting the former label scan store and naming it `__org_neo4j_schema_index_label_scan_store_converted_to_token_index`.
This index name is reserved from 4.3 onwards, and an error is returned if you attempt to create a user-defined index with this name.
Similarly, in the unlikely situation when an index with such a name exists in a previous version, it must be dropped and recreated with a different name before upgrading to 4.3.

The following table summarizes which token lookup indexes and label scan stores are present by default in various versions.
Note that the table represents only the default indexes and that the relationship type lookup index can be created explicitly through Cypher if needed.

[options="header" cols=4]
|===
| Token lookup index
| Databases created before Neo4j 4.3
| Databases upgraded to Neo4j 4.3
| Databases created in Neo4j 4.3 and onwards

| Label scan store
| yes
| no
| no

| Node label lookup index
| no
| yes (automatic conversion)
| yes

| Relationship type lookup index
| no
| yes (using Cypher)
| yes
|===
