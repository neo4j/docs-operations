[[index-configuration]]
= Index configuration
:description: How to configure indexes to enhance performance in search, and to enable full-text search. 


[[index-configuration-introduction]]
== Introduction

In Neo4j there are three different index types: xref:performance/index-configuration.adoc#index-configuration-btree[b-tree], xref:performance/index-configuration.adoc#index-configuration-fulltext[full-text],
and xref:performance/index-configuration.adoc#index-configuration-token-lookup[token lookup].

All three types of indexes can be created and dropped using Cypher and they can also all be used to index both nodes and relationships.
The token lookup index is the only index present by default in the database.

B-tree and full-text indexes provide mapping from a property value to an entity (node or relationship).
Token lookup indexes are different and provide mapping from labels to nodes or from relationship types to relationships instead of between properties and entities.

Users are not required to know the difference between the various indexes in order to use them, since the Cypher query planner decides which index should be used in which situation.

For more information on the different index types, refer to link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance] and link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-full-text-search[Cypher Manual -> Indexes to support full-text search].

// For details on creating, using and dropping b-tree indexes, see <<cypher-manual#administration-indexes-search-performance, Cypher Manual -> Indexes>>.


.Supported index types
[options="header", cols="a,m,m"]
|===
| Index type            | Cypher command          | Core API
| B-tree index          | SHOW INDEXES#BTREE      | org.neo4j.graphdb.schema.IndexType#BTREE
| Full-text index       | SHOW INDEXES#FULLTEXT   | org.neo4j.graphdb.schema.IndexType#FULLTEXT
| Token lookup index    | SHOW INDEXES#LOOKUP     | org.neo4j.graphdb.schema.IndexType#LOOKUP
|===


[[index-configuration-btree]]
== B-tree indexes

B-tree indexes are good for exact lookups on all types of values, range scans, full scans, and prefix searches.
They can be backed by two different index providers, `native-btree-1.0` and `lucene+native-3.0`.
If not explicitly set, `native-btree-1.0` is used.


[[index-configuration-btree-limitations]]
=== Limitations

There are a few limitations for b-tree indexes, listed below together with suggested workarounds.


[[index-configuration-btree-limitations-contains-ends-with]]
==== Limitations for queries  using `CONTAINS` and `ENDS WITH`

The index provider `native-btree-1.0` has limited support for `ENDS WITH` and `CONTAINS` queries.
These queries are not able to do an optimized search as per queries that use `STARTS WITH`, `=`, and `<>`.
Instead, the index result is a stream of an index scan with filtering.

In the future, `ENDS WITH` and `CONTAINS` queries will be supported with full-text indexes, but for now the index provider `lucene+native-3.0` can be used instead.
Please note that `lucene+native-3.0` only has support for `ENDS WITH` and `CONTAINS` for single property strings.

* For details about execution plans, refer to  link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/execution-plans[Cypher Manual -> Execution plans].
* For details about string operators, refer to  link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/syntax/operators#query-operators-comparison[Cypher Manual -> Operators].


[[index-configuration-btree-limitations-key-sizes]]
==== Limitations on key size

The index provider `native-btree-1.0` has a key size limit of around 8kB.

If a transaction reaches the key size limit for one or more of its changes, that transaction fails before committing any changes.
If the limit is reached during index population, the resulting index is in a failed state, and as such is not usable for any queries.

If this is an issue, you can use the index provider `lucene+native-3.0` instead.
This provider has a key size limit for single property strings of around 32kB.


[[index-configuration-btree-limitations-workarounds]]
==== Workarounds to address limitations

To work around problems with key size, or performance issues related to `ENDS WITH` or `CONTAINS`, you can use the index provider `lucene+native-3.0`.
This only works for single-property string indexes.

This can be done using either of the following methods:

Option 1. Use the `OPTIONS` clause with the `CREATE` command (recommended)::
The Cypher commands for index creation, unique property constraint creation, and node key creation contain an optional `OPTIONS` clause.
This clause can be used to specify an index provider.
+
For details on indexes, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance].
For details on constraints, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints].


Option 2. Use a built-in procedure label:deprecated[]::
Please note that this option uses built-in procedures that have been deprecated, and will be removed in a future release.
These have been replaced with the Cypher commands in Option 1.
+
The built-in procedures `db.createIndex`, `db.createUniquePropertyConstraint`, and `db.createNodeKey` can be used to specify index provider on index creation, unique property constraint creation, and node key creation.
+
For details on constraints, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints], and for more information on built-in procedures, see xref:reference/procedures.adoc[Procedures].


Option 3. Change the config label:deprecated[]::
Please note that this option uses the index setting `dbms.index.default_schema_provider`, which has been deprecated and will be removed in a future release.
It will be a fully internal concern which index provider an index is using.
+
. Configure the setting `dbms.index.default_schema_provider` to the one required.
. Restart Neo4j.
. Drop and recreate the relevant index.
. Change `dbms.index.default_schema_provider` back to the original value.
. Restart Neo4j.
+
The recommended way to set an index provider for an index is to use the `OPTIONS` clause for index creation, unique property constraint creation, and node key creation.
+
For more information, see link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher Manual -> Indexes for search performance] and link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/constraints[Cypher manual -> Constraints].

[[index-configuration-btree-migration]]
=== Index migration

When upgrading a 3.5 store to {neo4j-version-exact}, all indexes are upgraded to the latest index version, and rebuilt automatically, except for the indexes that use Lucene for single-property strings.
They are upgraded to a fallback version, which uses Lucene for those properties.
Note that they still need to be rebuilt.

For more information, see link:{neo4j-docs-base-uri}/upgrade-migration-guide/current/migration/index-upgrade/[Upgrade and Migration Guide -> Neo4j indexes].

[[index-configuration-btree-procedures]]
=== Procedures to create index and index backed constraint

label:deprecated[]

Indexes and constraints are best created through link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes-for-search-performance[Cypher] but can still be created through the deprecated procedures described in the example below.
Index provider and index settings can both be specified using the optional `OPTIONS` clause for the Cypher commands.

.Example of procedures to create index and index backed constraint
====
The following procedures provide the option to specify both index provider and index settings (optional).
Note that settings keys need to be escaped with back-ticks if they contain dots.

Use `db.createIndex` procedure to create an index:

[source, cypher]
----
CALL db.createIndex("MyIndex", ["Person"], ["name"], "native-btree-1.0", {`spatial.cartesian.max`: [100.0,100.0], `spatial.cartesian.min`: [-100.0,-100.0]})
----

If a settings map is not provided, the settings are picked up from the xref:configuration/neo4j-conf.adoc[Neo4j config file], the same way as when creating an index or constraint through Cypher.

[source, cypher]
----
CALL db.createIndex("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----

Use `db.createUniquePropertyConstraint` to create a node property uniqueness constraint (the example is without settings map, left out for abbreviation):

[source, cypher]
----
CALL db.createUniquePropertyConstraint("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----

Use `db.createNodeKey` to create node key constraint (the example is without settings map, left out for abbreviation):

[source, cypher]
----
CALL db.createNodeKey("MyIndex", ["Person"], ["name"], "native-btree-1.0")
----
====


[[index-configuration-fulltext]]
== Full-text indexes

Full-text indexes are optimized for indexing and searching text.
They make it possible to write queries that match within the _contents_ of indexed string properties.
In other words, they are used for queries that demand an understanding of language and they only index string data.
They must also be queried explicitly via procedures, as Cypher does not make plans that rely on them.

An example of a use case for full-text indexes is parsing a book for a certain term and taking advantage of the knowledge that the book is written in a certain language.
The use of an _analyzer_ for that language enables the exclusion of words that are not relevant for the search (e.g. _if_ and _and_), and include conjugations of words that are.

Another use case example is indexing the various address fields and text data in a corpus of emails.
Indexing this data using the `email` analyzer makes it possible to find all emails that are sent from, or to, or mentions, an email account.

In contrast to b-tree indexes, full-text indexes are queried using built-in procedures.
They are however created and dropped using Cypher.
The use of full-text indexes does require familiarity with how the indexes operate.

Full-text indexes are powered by the http://lucene.apache.org/[Apache Lucene] indexing and search library.
A full description on how to create and use full-text indexes is provided in the link:{neo4j-docs-base-uri}/cypher-manual/{neo4j-version}/indexes-for-full-text-search/[Cypher Manual -> Indexes to support full-text search].


[[index-configuration-fulltext-configuration]]
=== Configuration

The following options are available for configuring full-text indexes:

`dbms.index.fulltext.default_analyzer`::
The name of the analyzer that the full-text indexes should use by default.
This setting only has effect when a full-text index is created and is remembered as an index-specific setting from then on.
+
The list of possible analyzers is available through the `db.index.fulltext.listAvailableAnalyzers()` Cypher procedure.
+
Unless otherwise specified, the default analyzer is `standard-no-stop-words`, which is the same as the `StandardAnalyzer` from Lucene, except no stop-words are filtered out.

`dbms.index.fulltext.eventually_consistent`::
Used to declare whether full-text indexes should be eventually consistent, or not.
This setting only has an effect when a full-text index is created and is remembered as an index-specific setting from then on.
+
Indexes are normally fully consistent, and the committing of a transaction does not return until both the store and the indexes have been updated.
Eventually consistent full-text indexes, on the other hand, are not updated as part of a commit but instead, have their updates queued up and applied in a background thread.
This means that there can be a short delay between committing a change and that change becoming visible via any eventually consistent full-text indexes.
This delay is just an artifact of the queueing, and is usually quite small since eventually consistent indexes are updated "as soon as possible".
+
By default, this is turned off, and full-text indexes are fully consistent.

`dbms.index.fulltext.eventually_consistent_index_update_queue_max_length`::
Eventually consistent full-text indexes have their updates queued up and applied in a background thread, and this setting determines the maximum size of that update queue.
If the maximum queue size is reached, then committing transactions block and wait until there is more room in the queue, before adding more updates to it.
+
This setting applies to all eventually consistent full-text indexes, and they all use the same queue.
The maximum queue length must be at least 1 index update and no more than 50 million due to heap space usage considerations.
+
The default maximum queue length is 10.000 index updates.

[[index-configuration-token-lookup]]
== Token lookup indexes

Token lookup indexes, as the name suggests, are used to look up nodes with a specific label or relationships of a specific type.
A token lookup index sampling is run on all labels or relationship types, respectively, and hence there can only be a maximum of two token lookup indexes in a database - one for nodes and one for relationships.

Token lookup indexes are introduced in 4.3 and whereas relationship type lookup index is a new concept, node label lookup index is not.
The latter evolved from the label scan store, which has been present in various forms for a long time.
Node label lookup index provides the same functionality as the former label scan store with some additional features, such as to be created and dropped using a non-blocking population.

[[index-configuration-token-lookup-use-and-significance]]
=== Use and significance

Token lookup indexes are the most important indexes that can be present in a database.
They are essential for both Cypher queries and Core API operations.
More importantly, their presence speeds up the population of other indexes significantly, node label lookup index for node b-tree and full-text indexes and relationship type lookup index for the corresponding relationship indexes.

The node label lookup index is important for queries that match a node by one or more labels.
It can also be used for matching the labels and properties of a node when no suitable b-tree indexes are available.
This is essential, considering that b-tree indexes are not defined by default.
In other words, a node label lookup index is often the best way to approach a query that matches labels, unless the user has defined a more appropriate b-tree index.
Accordingly, the relationship type lookup index does the same for relationships and their types.

Most queries are executed by matching nodes and expanding their relationships.
Therefore, the node label lookup index is slightly more significant than the relationship type lookup index.

Since these indexes are important for both query execution and index population, a lot of consideration should be taken before dropping them.

Both node and relationship type lookup indexes are present by default in all databases created in 4.3 and onwards.


[[index-configuration-token-lookup-upgrade]]
=== Databases created before version 4.3

By default, databases created before version 4.3 get only a node label lookup index when used in a Neo4j DBMS 4.3 or later.
This is to preserve the backward compatibility and performance characteristics of such databases.

If needed, such databases can also get a relationship type lookup index by creating it explicitly using Cypher.

[NOTE]
====
Creating a relationship type lookup index on a large database can take a significant amount of time as all relationships need to be scanned when populating such an index.
====

When used in Neo4j DBMS 4.3 or later, all databases created before 4.3 automatically get a node label lookup index by converting the former label scan store and naming it `__org_neo4j_schema_index_label_scan_store_converted_to_token_index`.
This index name is reserved from 4.3 onwards, and if you attempt to create a user-defined index with it, Neo4j throws an error.
Similarly, in the unlikely situation that an index with such a name was created in previous versions, it must be dropped and recreated with a different name before upgrading to 4.3.

The following table summarizes which token lookup indexes and label scan stores are present by default in various versions.
Note that the table represents only the default indexes and that the relationship type lookup index can be created explicitly through Cypher if needed.

[options="header" cols=4]
|===
| Token lookup index
| Databases created before Neo4j 4.3
| Databases upgraded to Neo4j 4.3
| Databases created in Neo4j 4.3 and onwards

| Label scan store
| yes
| no
| no

| Node label lookup index
| no
| yes (automatic conversion)
| yes

| Relationship type lookup index
| no
| yes (using Cypher)
| yes
|===
