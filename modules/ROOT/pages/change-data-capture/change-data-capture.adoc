// Creating a cdc enabled build:
// Add CDC dependency to private/enterprise/neo4j-enterprise/pom.xml

[role=enterprise-edition]
[[change-data-capture]]
= Change Data Capture

====
TODO general introduction, what is CDC?
====
====
TODO examples are similar to the movie graph, but not actually following the movie graph. See if northwind is complicated enough or if we should go with our own.
====

== Setup
In order to enable the change data capture feature, the setting `internal.dbms.change_data_capture` must be set to `true` in neo4j.conf.

====
TODO currently these are needed in neo4j.conf, let's try to build the kernel version patch into the .jar:
[source]
----
internal.dbms.change_data_capture=true
internal.dbms.latest_kernel_version=6
internal.dbms.latest_runtime_version=7
----
====

Log enrichment needs to be enabled for individual databases.
Use the options clause to enable log enrichment when creating the database:
[source, cypher]
----
CREATE DATABASE name OPTIONS {txLogEnrichment:"FULL"}
----
Log enrichment can also be enabled on an existing database using:
[source, cypher]
----
ALTER DATABASE name SET OPTION txLogEnrichment "FULL"
----

Log enrichment can be disabled through:
[source, cypher]
----
ALTER DATABASE name SET OPTION txLogEnrichment "OFF"
----

Valid values for the `txLogEnrichment` option are `OFF`, `DIFF`, `FULL`. For more information on the log enrichment modes see <<change-data-capture-enrichment-mode>>.

[[change-data-capture-enrichment-mode]]
== Enrichment mode
Neo4j offers three levels of transaction log enrichment `OFF`, `DIFF` and `FULL`. For change data capture procedures to work, the level of enrichment must be either `DIFF` or `FULL`. The enrichment level is set on each database.

With enrichment mode set to `OFF`, no additional data is written to the transaction log.

With enrichment mode set to `DIFF`, changes are recorded as the difference between before and after state.

With enrichment mode set to `FULL`, changes are recorded as a complete copy of the previous state and the new state.

Enrichment mode is reflected in the output from change data capture procedures. On databases with `FULL` enrichment mode, The `event.state.before` and `event.state.after` fields contain the complete before and after state. With `DIFF` mode they only contain removals, updates and additions.

Selectors targeting a field that has not changed will match in `FULL` mode but not in `DIFF` mode.
====
TODO above is probably a lie. The current version limits `DIFF` behaviour to match that of `FULL` (todo verify)? Is that the intended behaviour?
====

[[change-data-capture-selectors]]
== Selectors
Change data capture procedures support filtering their output using selectors.

The following cypher will only return changes where the property "name" has changed on nodes.
[source, cypher]
----
CALL cdc.query("0", [{select:"node", changesTo:["name"]}])
----

=== Combining selectors
The more specific a selector is, the fewer changes will be returned. Specifying both "name" and "surname" for example, will only return changes where both name *and* surname have been changed.
[source, cypher]
----
CALL cdc.query("0", [{select:"node", changesTo:["name", "surname"]}])
----

In order to extract changes for either name *or* surname, two separate selectors have to be specified:
[source, cypher]
----
CALL cdc.query("0", [
    {select:"node", changesTo:["name"]}
    {select:"node", changesTo:["surname"]}
])
----


=== Examples
// ENTITY UNSPECIFIC
Changes can be filtered to only return creates, updates or deletions:
[source, cypher]
----
CALL cdc.query("0", [{select:"entity", operation:"CREATE"}])
CALL cdc.query("0", [{select:"entity", operation:"UPDATE"}])
CALL cdc.query("0", [{select:"entity", operation:"DELETE"}])
----

Changes can be filtered to only include those where a certain property changed.
[source, cypher]
----
CALL cdc.query("0", [{select:"entity", changesTo:["name"]}])
----

// NODE/RELATIONSHIP needs to be specified
Changes can be filtered to a specific element ID:
[source, cypher]
----
CALL cdc.query("0", [{select:"node", elementId:"4:e239be76-c7e8-43d8-aa03-567de592f426:0"}])
CALL cdc.query("0", [{select:"relationship", elementId:"5:e239be76-c7e8-43d8-aa03-567de592f426:0"}])
----

// NODE selectors
Node changes can be filtered to specific keys:
[source, cypher]
----
CALL cdc.query("0", [{select:"node", key:{name:"Kevin", surname:"Bacon"}}])
----

Node changes can be filtered to specific labels.
[source, cypher]
----
CALL cdc.query("0", [{select:"node", labels:["ACTOR", "DIRECTOR"]}])
----
[NOTE]
====
The query above will only return changes on nodes that have *both* labels. In order to get changes on nodes with either label, two separate selectors have to be specified.
[source, cypher]
----
CALL cdc.query("0", [{select:"node", labels:["ACTOR"]}, {select:"node", labels:["DIRECTOR"]}])
----
====

// RELATIONSHIP selectors
Relationship changes can be filtered to a specific type.
[source, cypher]
----
CALL cdc.query("0", [{select:"relationship", type:"ACTED_IN"}])
----

Relationship changes can be selected based on their start and end node.
[source, cypher]
----
CALL cdc.query("0", [{
    select:"relationship",
    start:{labels:["ACTOR"]},
    end:{key:{title:"Apollo 13"}}
}])
----

== CDC procedures
[[change-data-capture-querying-changes]]
=== Querying changes
The procedure `cdc.query(from, selectors)` is used to query the database for changes. Once all changes have been streamed the query will terminate. Each record contains an `id` field, which can be used as `from` in a subsequent query, in order to continue streaming from that point. The `from` field is exclusive and will not include the already seen record a second time. Selectors can be used to filter the output, see <<change-data-capture-selectors, selectors>> for details.
[source, cypher]
----
CALL cdc.query("A-I5vnbH6EPYqgNWfeWS9CYAAAAAAAAABQAAAAAAAAAA")
CALL cdc.query("A-I5vnbH6EPYqgNWfeWS9CYAAAAAAAAABQAAAAAAAAAA", {select:"node"})
----

The output from `cdc.query` is described in the section <<change-data-capture-output, change event output>>.

====
TODO omitting `cdc.stream` here since it currently doesn't work
====


=== Getting the earliest change
The procedure `cdc.earliest` is used to get a `from` value for the earliest available change.
[source, cypher]
----
CALL cdc.earliest
----

The following affect what the earliest value is:

    * Transaction log enrichment has been turned off
====
TODO Do we need to be more explicit about this? Maybe some sentence in the enrichment mode section that turning enrichment OFF voids all previous data?
====
    * Transaction log rotation
====
TODO are there other things that affect the earliest value?
====

=== Getting the current change
The procedure `cdc.current` returns the `id` from the newest entry in the transaction log. This value may be used to query changes from "now".
[source, cypher]
----
CALL cdc.current
----

[[change-data-capture-output]]
== Change event output
====
TODO we aren't explaining all metadata fields yet.
====
Data change events for nodes contain the following fields:
[cols="<31s,69",frame="topbot",options="header"]
|===
| Field path
| Description

| id
| A unique id. It can be used to continue streaming changes. See <<change-data-capture-querying-changes>>

| txId
| A unique id identifying which transaction the change happened in.

| seq
| A number used for ordering changes that happened in the same transaction. <TODO is this right?>

| metadata
| Metadata about the transaction.

| metadata.executingUser
| As which user was the query executed. May be different form authenticatedUser when using impersonation. <TODO link to impersonation docs>

| metadata.authenticatedUser
| The authenticated user when the query was executed.

| event
| A map describing the change.

| event.elementId
| ElementId of the changed element (Node or Relationship).

| event.eventType
| `n` or `r` indicating if the event changes a node or relationship.

| event.keys
| Map containing the primary key for the changed element. Requires constraints, see <<change-data-capture-constraints>>.

| event.operation
| `c` for creation, `u` for updates, `d` for deletes.

| event.labels
| Labels on the changed node. <TODO regardless of DIFF/FULL mode?>

| event.state.before
| Labels and properties of the node before this change. Either the deleted and changed characteristics or the entire state, depending on <<change-data-capture-enrichment-mode>>.

| event.state.after
| Labels and properties of the node after this change. Either the added and changed characteristics or the entire state, depending on <<change-data-capture-enrichment-mode>>.

|===


Example node creation:
[source, json]
----
{
  "id": "A7fjWXMK_0L6hztd4xhoy0oAAAAAAAAADAAAAAAAAAAA",
  "txId": 12,
  "seq": 0,
  "metadata": {
    "executingUser": "neo4j",
    "connectionClient": "127.0.0.1:51320",
    "authenticatedUser": "neo4j",
    "serverId": "e605bd8f",
    "connectionType": "bolt",
    "connectionServer": "127.0.0.1:51316",
    "txStartTime": "2023-03-03T11:58:30.429Z",
    "txCommitTime": "2023-03-03T11:58:30.526Z"
  },
  "event": {
    "elementId": "4:b7e35973-0aff-42fa-873b-5de31868cb4a:1",
    "keys": {},
    "eventType": "n",
    "state": {
      "before": null,
      "after": {
        "properties": {
          "tagline": "Houston, we have a problem.",
          "title": "Apollo 13",
          "released": "1995"
        },
        "labels": [
          "MOVIE"
        ]
      }
    },
    "operation": "c",
    "labels": [
      "MOVIE"
    ]
  }
}
----


Relationship changes are similar to node changes, except:
[cols="<31s,69",frame="topbot",options="header"]
|===
| Field path
| Description

| event.labels
| This field does not exist on relationship changes since relationships do not have labels.

| event.type
| Type of the changed relationship. <TODO regardless of DIFF/FULL mode?>

| event.start / event.end
| Maps describing the start and end nodes on the changed relationship.

| event.start.elementId
| Element ID of the start node

| event.start.keys
| Primary keys describing the start node. Requires constraints, see <<change-data-capture-constraints>>

| event.start.labels
| List of labels on the start node.
|===

Example relationship creation:
[source, json]
----
{
  "id": "A2pK9P_aOknnrnEsCsPB_BoAAAAAAAAADwAAAAAAAAAA",
  "txId": 15,
  "seq": 0,
  "metadata": {
    "executingUser": "neo4j",
    "connectionClient": "127.0.0.1:51190",
    "authenticatedUser": "neo4j",
    "serverId": "2230d17a",
    "connectionType": "bolt",
    "connectionServer": "127.0.0.1:51186",
    "txStartTime": "2023-03-03T11:54:40.510Z",
    "txCommitTime": "2023-03-03T11:54:40.773Z"
  },
  "event": {
    "elementId": "5:6a4af4ff-da3a-49e7-ae71-2c0ac3c1fc1a:0",
    "start": {
      "elementId": "4:6a4af4ff-da3a-49e7-ae71-2c0ac3c1fc1a:0",
      "keys": {},
      "labels": [
        "PERSON"
      ]
    },
    "end": {
      "elementId": "4:6a4af4ff-da3a-49e7-ae71-2c0ac3c1fc1a:1",
      "keys": {},
      "labels": [
        "MOVIE"
      ]
    },
    "eventType": "r",
    "state": {
      "before": null,
      "after": {
        "properties": {
          "roles": "Jack Swigert"
        }
      }
    },
    "type": "ACTED_IN",
    "operation": "c",
    "key": {}
  }
}
----

[[change-data-capture-constraints]]
== Key field
Constraints are required for populating the `event.key` field on node changes and `event.start/end.keys` fields on relationship changes. With the following constraint, properties `name` and `lastname` will be present in the fields for all changes involving `PERSON` nodes:
[source, cypher]
----
CREATE CONSTRAINT IF NOT EXISTS FOR (n:PERSON) REQUIRE (n.name, n.lastname) IS NODE KEY
----
Alternatively, the key constraint can be split up into existence and uniqueness constraints.
[source, cypher]
----
CREATE CONSTRAINT IF NOT EXISTS FOR (n:PERSON) REQUIRE n.name IS NOT NULL
CREATE CONSTRAINT IF NOT EXISTS FOR (n:PERSON) REQUIRE n.lastname IS NOT NULL
CREATE CONSTRAINT IF NOT EXISTS FOR (n:PERSON) REQUIRE (n.name, n.lastname) IS UNIQUE
----

For more details on the constraint commands see <TODO link to constraint docs>

====
*TODO put these topics/stuff somewhere:*

    - might skip txIds (system commands)
    - system commands are not being shown
    - what is seq
        * change order within tx (create node, create rel, update node update rel etc???)
//         final var expected = List.of(
//                new EventInfo(Type.NODE, Operation.CREATE, idMapper.nodeElementId(nodeToAdd), false),
//                new EventInfo(Type.RELATIONSHIP, Operation.CREATE, idMapper.relationshipElementId(relToAdd), false),
//                new EventInfo(Type.NODE, Operation.UPDATE, nodeLabelModify, false),
//                new EventInfo(Type.NODE, Operation.UPDATE, nodePropModify, false),
//                new EventInfo(Type.RELATIONSHIP, Operation.UPDATE, relPropModify, false),
//                new EventInfo(Type.NODE, Operation.DELETE, nodeToDelete, false),
//                new EventInfo(Type.RELATIONSHIP, Operation.DELETE, relToDelete, true));
    - For create events `event.state.before` is null
    - For delete events `event.state.after` is null
    - For update events neither is null, they might be empty maps for diff mode


*Scenarios?*

    - Start/Stop database
    - Leader switch
    - Enable/Disable/Change enrichment mode
        * DIFF -> FULL -> DIFF is silent, but causes different output?

*TODO finishing touches:*

    - Make sure links work and make sense (don't put a link from one section to the one right below...)
    - double check "earliest" syntax in examples, is "0" always valid as "earliest"
    - Delete this TODO list...
====