:description: This section describes how to configure and install a Neo4j helm deployment in a Kubernetes cluster using a customized Helm chart.
[[kubernetes-neo4j-configuration]]
= Configure a Neo4j Helm deployment


Helm is different from “package managers”, such as `apt`, `yum`, and `npm`, because, in addition to installing applications, Helm allows rich configuration of applications.
The customized configuration should be expressed declaratively in a YAML formatted file, and then passed during installation.

[TIP]
====
For more information, see link:https://helm.sh/docs/intro/using_helm/#customizing-the-chart-before-installing[Helm official documentation].
====

[[create-yaml]]
== Create a custom _values.yaml_ file

. Ensure your Neo4j Helm chart repository is up to date and get the latest charts.
For more information, see xref:kubernetes/helm-charts-setup.adoc[Configure the Neo4j Helm chart repository].
. To see what options are configurable on the Neo4j helm chart that you want to deploy, use `helm show values` and the Helm chart, such as _neo4j/neo4j-standalone_, _neo4j/neo4j-cluster-core_, _neo4j/neo4j-cluster-read-replica_, _neo4j/neo4j-cluster-headless-service_, and _neo4j/neo4j-cluster-loadbalancer_.
For example:
+
[source, shell]
--
helm show values neo4j/neo4j-standalone
--
+
[source, yaml]
----
# Default values for Neo4j.
# This is a YAML-formatted file.

neo4j:
  # Name of your cluster
  name: ""

  # If the password is not set or empty a random password will be generated during installation
  password: ""

  # Neo4j Edition to use (community|enterprise)
  edition: "community"
  # set edition: "enterprise" to use Neo4j Enterprise Edition
  #
  # To use Neo4j Enterprise Edition you must have a Neo4j license agreement.
  #
  # More information is also available at: https://neo4j.com/licensing/
  # Email inquiries can be directed to: licensing@neo4j.com
  #
  # Set acceptLicenseAgreement: "yes" to confirm that you have a Neo4j license agreement.
  acceptLicenseAgreement: "no"
  #
  # set offlineMaintenanceModeEnabled: true to restart the StatefulSet without the Neo4j process running
  # this can be used to perform tasks that cannot be performed when Neo4j is running such as `neo4j-admin dump`
  offlineMaintenanceModeEnabled: false
  #
  # set resources for the Neo4j Container. The values set will be used for both "requests" and "limit".
  resources:
    cpu: "1000m"
    memory: "2Gi"

# Volumes for Neo4j
volumes:
  data:
    # REQUIRED: specify a volume mode to use for data
    # Valid values are share|selector|defaultStorageClass|volume|volumeClaimTemplate|dynamic
    # To get up and running quickly, for development or testing, use "defaultStorageClass" for a dynamically provisioned volume of the default storage class.
    mode: ""

    # Only used if the mode is set to "selector"
    # Will attach to existing volumes that match the selector
    selector:
      storageClassName: "manual"
      accessModes:
        - ReadWriteOnce
      requests:
        storage: 100Gi
      # A helm template to generate a label selector to match existing volumes n.b. both storageClassName and label selector must match existing volumes
      selectorTemplate:
        matchLabels:
          app: "{{ .Values.neo4j.name }}"
          helm.neo4j.com/volume-role: "data"

    # Only used if mode is set to "defaultStorageClass"
    # Dynamic provisioning using the default storageClass
    defaultStorageClass:
      accessModes:
        - ReadWriteOnce
      requests:
        storage: 10Gi

    # Only used if the mode is set to "dynamic"
    # Dynamic provisioning using the provided storageClass
    dynamic:
      storageClassName: "neo4j"
      accessModes:
        - ReadWriteOnce
      requests:
        storage: 100Gi

    # Only used if mode is set to "volume"
    # Provide an explicit volume to use
    volume:
      # If set an init container (running as root) will be added that runs:
      #   `chown -R <securityContext.fsUser>:<securityContext.fsGroup>` AND `chmod -R g+rwx`
      # on the volume. This is useful for some file systems (e.g. NFS) where Kubernetes fsUser or fsGroup settings are not respected
      setOwnerAndGroupWritableFilePermissions: false

      # Example (using a specific Persistent Volume Claim)
      # persistentVolumeClaim:
      #   claimName: my-neo4j-pvc

    # Only used if mode is set to "volumeClaimTemplate"
    # Provide an explicit volumeClaimTemplate to use
    volumeClaimTemplate: {}

  # provide a volume to use for backups
  # n.b. backups will be written to /backups on the volume
  # any of the volume modes shown above for data can be used for backups
  backups:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

  # provide a volume to use for logs
  # n.b. logs will be written to /logs/$(POD_NAME) on the volume
  # any of the volume modes shown above for data can be used for logs
  logs:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

  # provide a volume to use for csv metrics (csv metrics are only available in Neo4j Enterprise Edition)
  # n.b. metrics will be written to /metrics/$(POD_NAME) on the volume
  # any of the volume modes shown above for data can be used for metrics
  metrics:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

  # provide a volume to use for import storage
  # n.b. import will be mounted to /import on the underlying volume
  # any of the volume modes shown above for data can be used for import
  import:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

  # provide a volume to use for licenses
  # n.b. licenses will be mounted to /licenses on the underlying volume
  # any of the volume modes shown above for data can be used for licenses
  licenses:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

# Services for Neo4j
services:
  # A ClusterIP service with the same name as the Helm Release name should be used for Neo4j Driver connections originating inside the
  # Kubernetes cluster.
  default:
    # Annotations for the K8s Service object
    annotations: { }

  # A LoadBalancer Service for external Neo4j driver applications and Neo4j Browser
  neo4j:
    enabled: true

    # Annotations for the K8s Service object
    annotations: { }

    spec:
      # Type of service.
      type: LoadBalancer

      # in most cloud environments LoadBalancer type will receive an ephemeral public IP address automatically. If you need to specify a static ip here use:
      # loadBalancerIP: ...

    # ports to include in neo4j service
    ports:
      http:
        enabled: true #Set this to false to remove HTTP from this service (this does not affect whether http is enabled for the neo4j process)
      https:
        enabled: true #Set this to false to remove HTTPS from this service (this does not affect whether https is enabled for the neo4j process)
      bolt:
        enabled: true #Set this to false to remove BOLT from this service (this does not affect whether https is enabled for the neo4j process)

  # A service for admin/ops tasks including taking backups
  # This service is available even if the deployment is not "ready"
  admin:
    enabled: true
    # Annotations for the admin service
    annotations: { }
    spec:
      type: ClusterIP
    # n.b. there is no ports object for this service. Ports are autogenerated based on the neo4j configuration

  # A "headless" service for admin/ops and Neo4j cluster-internal communications
  # This service is available even if the deployment is not "ready"
  internals:
    enabled: false
    # Annotations for the internals service
    annotations: { }
    # n.b. there is no ports object for this service. Ports are autogenerated based on the neo4j configuration

# Neo4j Configuration (yaml format)
config:
  dbms.config.strict_validation: "true"

# securityContext defines privilege and access control settings for a Pod or Container. Making sure that you do not run Neo4j as root user.
securityContext:
  runAsNonRoot: true
  runAsUser: 7474
  runAsGroup: 7474
  fsGroup: 7474
  fsGroupChangePolicy: "Always"

# Readiness probes are set to know when a container is ready to be used.
# Because Neo4j uses Java these values are large to distinguish between long Garbage Collection pauses (which don't require a restart) and an actual failure.
# These values should mark Neo4j as not ready after at most 5 minutes of problems (20 attempts * max 15 seconds between probes)
readinessProbe:
  failureThreshold: 20
  timeoutSeconds: 10
  periodSeconds: 5

# Liveness probes are set to know when to restart a container.
# Because Neo4j uses Java these values are large to distinguish between long Garbage Collection pauses (which don't require a restart) and an actual failure.
# These values should trigger a restart after at most 10 minutes of problems (40 attempts * max 15 seconds between probes)
livenessProbe:
  failureThreshold: 40
  timeoutSeconds: 10
  periodSeconds: 5

# Startup probes are used to know when a container application has started.
# If such a probe is configured, it disables liveness and readiness checks until it succeeds
# When restoring Neo4j from a backup, it's important that the startup probe gives time for Neo4j to recover and/or upgrade store files
# When using Neo4j clusters, it's important that the startup probe gives the Neo4j cluster time to form
startupProbe:
  failureThreshold: 1000
  periodSeconds: 5

# top level setting called ssl to match the "ssl" from "dbms.ssl.policy"
ssl:
  # setting per "connector" matching neo4j config
  bolt:
    privateKey:
      secretName:  # we set up the template to grab `private.key` from this secret
      subPath:  # we specify the privateKey value name to get from the secret
    publicCertificate:
      secretName:  # we set up the template to grab `public.crt` from this secret
      subPath:  # we specify the publicCertificate value name to get from the secret
    trustedCerts:
      sources: [ ] # a sources array for a projected volume - this allows someone to (relatively) easily mount multiple public certs from multiple secrets for example.
    revokedCerts:
      sources: [ ]  # a sources array for a projected volume
  https:
    privateKey:
      secretName:
      subPath:
    publicCertificate:
      secretName:
      subPath:
    trustedCerts:
      sources: [ ]
    revokedCerts:
      sources: [ ]

# Kubernetes cluster domain suffix
clusterDomain: "cluster.local"

# Override image settings in Neo4j pod
image:
  imagePullPolicy: IfNotPresent
  # set a customImage if you want to use your own docker image
  # customImage: my-image:my-tag

# additional environment variables for the Neo4j Container
env: {}

# Other K8s configuration to apply to the Neo4j pod
podSpec:
  # Anti Affinity
  # If set to true then an anti-affinity rule is applied to prevent database pods with the same `neo4j.name` running on a single Kubernetes node.
  # If set to false then no anti-affinity rules are applied
  # If set to an object then that object is used for the Neo4j podAntiAffinity
  podAntiAffinity: true

  # Name of service account to use for the Neo4j Pod (optional)
  # this is useful if you want to use Workload Identity to grant permissions to access cloud resources e.g. cloud object storage (AWS S3 etc.)
  serviceAccountName: ""

  # How long the Neo4j pod is permitted to keep running after it has been signaled by Kubernetes to stop. Once this timeout elapses the Neo4j process is forcibly terminated.
  # A large value is used because Neo4j takes time to flush in-memory data to disk on shutdown.
  terminationGracePeriodSeconds: 3600

  # initContainers for the Neo4j pod
  initContainers: [ ]

  # additional runtime containers for the Neo4j pod
  containers: [ ]

# print the neo4j user password set during install to the `helm install` log
logInitialPassword: true

# Jvm configuration for Neo4j
jvm:
  # If true any additional arguments are added after the Neo4j default jvm arguments.
  # If false Neo4j default jvm arguments are not used.
  useNeo4jDefaultJvmArguments: true
  # additionalJvmArguments is a list of strings. Each jvm argument should be a separate element
  additionalJvmArguments: []
  # - "-XX:+HeapDumpOnOutOfMemoryError"
  # - "-XX:HeapDumpPath=/logs/neo4j.hprof"
----
+
You can amend any of these settings.
Passing that file during installation overrides the default Helm chart configuration of the Neo4j installation on Kubernetes and the configuration of the Neo4j database itself.
+
. Create the _neo4j-values.yaml_ file with your preferred configuration.
For example:
+
[source, yaml]
----
# neo4j-values.yaml

neo4j:
  password: "my-password"
  resources:
    cpu: "2"
    memory: "5Gi"

volumes:
  data:
    mode: "defaultStorageClass"

# Neo4j configuration (yaml format)
config:
  dbms.default_database: "neo4j"
  dbms.config.strict_validation: "true"
----
+
. Pass the _neo4j-values.yaml_ file during installation.
+
[source, shell]
----
helm install <release-name> neo4j/neo4j-standalone -f neo4j-values.yaml
----
+
[TIP]
====
To see the values that have been set for a given release, use `helm get values <release-name>`.
====

Some examples of possible K8s configurations::
* Configure (or disable completely) the Kubernetes LoadBalancer that exposes Neo4j outside the Kubernetes cluster by modifying the `externalService` object in the _values.yml_ file.
* Set the `securityContext` used by Neo4j Pods by modifying the `securityContext` object in the _values.yml_ file.
* Configure manual persistent volume provisioning or set the `StorageClass` to be used as the Neo4j persistent storage.

Some examples of possible Neo4j configurations::
* All Neo4j configuration (_neo4j.conf_) settings can be set directly on the `config` object in the _values.yaml_ file.
* Neo4j can be configured to use SSL certificates contained in Kubernetes Secrets by modifying the `ssl` object in the values file.

[[configure-neo4j-in-kubernetes]]
== Set Neo4j configuration

The Neo4j Helm chart does not use a `neo4j.conf` file.
Instead, the Neo4j configuration is set in the Helm deployment's _values.yaml_ file under the `config` object.

The `config` object should contain a string map of _neo4j.conf_ setting name to value.
For example, this `config` object configures the Neo4j metrics:

[source, properties]
----
# Neo4j configuration (yaml format)
config:
  metrics.enabled: "true"
  metrics.namespaces.enabled: "false"
  metrics.csv.interval: "10s"
  metrics.csv.rotation.keep_number: "2"
  metrics.csv.rotation.compression: "NONE"
----

[NOTE]
====
All Neo4j `config` values must be YAML strings.
It is important to put quotes around the values, such as `"true"`, `"false"`, and `"2"`, so that they are handled correctly as strings.
====

All _neo4j.conf_ settings are supported except for `dbms.jvm.additional`.
Additional JVM settings can be set on the `jvm` object in the Helm deployment _values.yaml_ file, as shown in the example:

[source, java]
----
# Jvm configuration for Neo4j
jvm:
  additionalJvmArguments:
  - "-XX:+HeapDumpOnOutOfMemoryError"
  - "-XX:HeapDumpPath=/logs/neo4j.hprof"
----

To find out more about configuring Neo4j and the _neo4j.conf_ file, see xref:configuration/index.adoc[Configuration] and xref:configuration/neo4j-conf.adoc[The neo4j.conf file].

[[set-initial-password]]
== Set an initial password

You can set an initial password for accessing Neo4j in the _values.yaml_ file.
If no initial password is set, the Neo4j helm chart will automatically generate one.
In cluster deployments, the same password must be set on all cluster members.

[source, properties]
----
neo4j:
 # If not set or empty a random password will be generated
 password: ""
----

The password will be printed out in the Helm install output, unless `--set logInitialPassword=false` is used.

The initial Neo4j password is stored in a _Kubernetes Secret_.
The password can be extracted from the _Secret_ using this command:

[source, shell]
----
kubectl get secret <release-name>-auth -oyaml | yq -r '.data.NEO4J_AUTH' | base64 -d
----

[TIP]
====
To change the initial password, follow the steps in xref:kubernetes/maintenance.adoc#reset-password[Operations - Reset the Neo4j user password].

Once you change the password in Neo4j, the password stored in _Kubernetes Secrets_ will still exist but will no longer be valid.
====

[[configure-ssl]]
== Configure SSL

The Neo4j xref:security/ssl-framework.adoc[SSL Framework] can be used with Neo4j Helm charts.
SSL policy objects can be specified for `bolt`, `https`, `cluster`, `backup`, and `fabric`.
SSL public certificates and private keys to use with a Neo4j Helm deployment must be stored in _Kubernetes Secrets_.

To enable Neo4j SSL policies, configure the `ssl.<policy name>` object in the Neo4j Helm deployment's _values.yaml_ file to reference the _Kubernetes Secrets_ containing the SSL certificates and keys to use.
This example shows how to configure the `bolt` SSL policy:

[source, properties]
----
ssl:
 bolt:
   privateKey:
     secretName: bolt-cert
     subPath: private.key
   publicCertificate:
     secretName: bolt-cert
     subPath: public.crt
----

When a private key is specified in the _values.yaml_ file, the Neo4j `ssl` policy is enabled automatically.
To disable a policy, add `dbms.ssl.policy.{{ $name }}.enabled: "false"` to the `config` object.

[NOTE]
====
Unencrypted `http` is not disabled automatically when `https` is enabled.
If `https` is enabled, add `dbms.connector.http.enabled: "false"` to the `config` object to disable `http`.
====

[[configure-sso]]
== Configure SSO

Neo4j supports SSO authentication and authorization through identity providers implementing the OpenID Connect (OIDC) standard.

To configure the Neo4j helm deployment to use SSO authentication, first you need to configure your identity provider for authentication and authorization using ID tokens.
And then, you configure the Neo4j helm deployment to use that identity provider for authentication by adding all the SSO configurations to the _values.yaml_ file.

For more information on how to configure your identity provider and what settings you should define, see xref:tutorial/tutorial-sso-configuration.adoc[Neo4j Single Sign-On (SSO) configuration].

.An example of configuring Neo4j to use Azure SSO for authentication
[source, properties]
----
config:
  dbms.security.oidc.azure.audience: "00f3a7d3-d855-4849-9e3c-57d7b6e12794"
  dbms.security.oidc.azure.params: "client_id=00f3a7d3-d855-4849-9e3c-57d7b6e12794;response_type=code;scope=openid profile email"
  dbms.security.oidc.azure.well_known_discovery_uri: "https://login.microsoftonline.com/da501982-4ca7-420c-8926-1e65b5bf565f/v2.0/.well-known/openid-configuration"
  dbms.security.authorization_providers: "oidc-azure,native"
  dbms.security.authentication_providers: "oidc-azure,native"
  dbms.security.oidc.azure.display_name: "Azure SSO on K8s"
  dbms.security.oidc.azure.auth_flow: "pkce"
  token_type_principal=id_token;token_type_authentication=id_token"
  dbms.security.oidc.azure.config: "principal=unique_name;code_challenge_method=S256;
  dbms.security.oidc.azure.claims.username: "sub"
  dbms.security.oidc.azure.claims.groups: "groups"
  dbms.security.oidc.azure.authorization.group_to_role_mapping: "e197354c-bd75-4524-abbc-d44325904567=editor;fa31ce67-9e4d-4999-bf6d-25c55258d116=publisher"
----

[IMPORTANT]
====
`sub` is the only claim guaranteed to be unique and stable. 
Other claims, such as `email` or `preferred_username`, may change over time and should *not* be used for authentication. 
Neo4j may assign permissions to a user based on this username value in a hybrid authorization configuration. 
Thus, changing the username claim from `sub` is not recommended. 
For details, see https://learn.microsoft.com/en-us/azure/active-directory/develop/id-tokens#using-claims-to-reliably-identify-a-user-subject-and-object-id[Microsoft documentation] as well as the https://openid.net/specs/openid-connect-core-1_0.html#ClaimStability[OpenId spec].
====

[[configure-resources]]
== Configure resource allocation

*CPU and memory*::
The resources (CPU, memory) for the Neo4j container are configured by setting `neo4j.resources` object in the _values.yaml_ file.
In the resource _requests_, you can specify how much CPU and memory the Neo4j container needs, while in the resource _limits_, you can set a limit on these resources in case the container tries to use more resources than its _requests_ allow.
//For more information, see link:https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/[the Kubernetes container resources documentation].
+
[source, properties]
----
neo4j:
  resources:
    requests:
     cpu: "1000m"
     memory: "2Gi"
    limits:
     cpu: "2000m"
     memory: "4Gi"
----
+
If no resource _requests_ and resource _limits_ are specified, the values set in the `resources` object are used for both the Neo4j container's resource _requests_ and resource _limits_.
+
[source, properties]
----
neo4j:
  resources:
    cpu: "2"
    memory: "5Gi"
----
+
[NOTE]
====
The minimum for a Neo4j instance is `0.5` CPU and `2GB` memory. +
If invalid or less than the minimum values are provided, Helm will throw an error, for example:

[source, role=noheader]
----
Error: template: neo4j-standalone/templates/_helpers.tpl:157:11: executing "neo4j.resources.evaluateCPU" at <fail (printf "Provided cpu value %s is less than minimum. \n %s" (.Values.neo4j.resources.cpu) (include "neo4j.resources.invalidCPUMessage" .))>: error calling fail: Provided cpu value 0.25 is less than minimum.
 cpu value cannot be less than 0.5 or 500m
----
====

*JVM heap and page cache*::
You configure Neo4j to use the memory provided to the container by setting the parameters `dbms.memory.heap.max_size` and `dbms.memory.pagecache.size`.
Combined, they must not exceed the memory configuration of the Neo4j container. +
In Kubernetes, running processes in the Neo4j container that exceed the configured memory limit are killed by the underlying operating system.
Therefore, it is recommended to allow an additional 1GB of memory headroom so that `heap + pagecache + 1GB < available memory`.
+
For example, a 5GB container could be configured like this:
+
[source, properties]
----
neo4j:
  resources:
    cpu: "2"
    memory: "5Gi"

# Neo4j configuration (yaml format)
config:
  dbms.memory.heap.initial_size: "3G"
  dbms.memory.heap.max_size: "3G"
  dbms.memory.pagecache.size: "1G"
----
+
`dbms.memory.pagecache.size` and `dbms.memory.heap.initial_size` are not the only settings available in Neo4j to manage memory usage.
For full details of how to configure memory usage in Neo4j, see xref:memory-configuration[Performance - Memory Configuration].

[[k8s-service-accounts]]
== Configure a service account

In some deployment situations, it may be desirable to assign a Kubernetes Service Account to the Neo4j pod.
For example, if processes in the pod want to connect to services that require Service Account authorization.
To configure the Neo4j pod to use a Kubernetes service account, set `podSpec.serviceAccountName` to the name of the service account to use.

For example:

[source, properties]
----
# neo4j-values.yaml
neo4j:
  password: "my-password"

podSpec:
  serviceAccountName: "neo4j-service-account"
----

[NOTE]
====
The service account must already exist.
The Neo4j Helm charts do not create or configure Service Accounts.
====

[[configure-custom-image]]
== Configure a custom container image

The helm chart uses the official Neo4j Docker image that matches the version of the Helm chart.
To configure the helm chart to use a different container image, set the `image.customImage` property in the _values.yaml_ file.

This can be necessary when public container repositories are not accessible for security reasons.
For example, this _values.yaml_ file configures Neo4j to use `my-container-repository.io` as the container repository:

[source, properties, subs=attributes]
----
# neo4j-values.yaml
neo4j:
  password: "my-password"

image:
  customImage: "my-container-repository.io/neo4j:{neo4j-version}-enterprise"
----

[[operations-using-apoc-core]]
== Configure and install APOC core only

APOC core is shipped with Neo4j, but it is not installed in the Neo4j _plugins_ directory.
If APOC core is the _only_ plugin that you want to add to Neo4j, it is not necessary to perform plugin installation as described in xref:kubernetes/configuration.adoc#operations-installing-plugins[Install Plugins].
Instead, you can configure the helm deployment to use APOC core by upgrading the deployment with this additional setting in the _values.yaml_ file:

. Configure APOC core:
+
[source, properties]
----
config:
  dbms.directories.plugins: "/var/lib/neo4j/labs"
  dbms.security.procedures.unrestricted: "apoc.*"
----
+
. Under `apoc_config`, configure the APOC settings you want, for example:
+
[source, properties]
----
apoc_config:
  apoc.trigger.enabled: "true"
  apoc.jdbc.neo4j.url: "jdbc:foo:bar"
  apoc.import.file.enabled: "true"
----
+
. Run `helm upgrade` to apply the changes:
+
[source, shell]
----
helm upgrade <release-name> neo4j/neo4j-standalone -f values.yaml
----

. After the Helm upgrade rollout is complete, verify that APOC core has been configured by running the following Cypher query using `cypher-shell` or Neo4j Browser:
+
[source, cypher]
----
RETURN apoc.version()
----
+
. Verify the APOC configs using the `apoc.config.list()` procedure:
+
[source, cypher]
----
CALL apoc.config.list() YIELD key, value WHERE key = "apoc.jdbc.neo4j.url" RETURN *;
----

[[operations-installing-plugins]]
== Install Plugins

There are three recommended methods for adding Neo4j plugins to Neo4j Helm chart deployments.
You can use:

* <<automatic-plugin-download, an automatic plugin download>>
* <<init-container-plugin-installation, an init container>>
* <<custom-container, a custom container image>>.
* <<plugins-volume, a `plugins` volume>>.

[[automatic-plugin-download]]
=== Add plugins using an automatic plugin download

You can configure the Neo4j deployment to automatically download and install plugins.
If licenses are required for the plugins, you must provide the licenses in a secret.

==== Install GDS Community Edition (CE)

GDS Community Edition does not require a license.
To add the GSD CE, configure the Neo4j _values.yaml_ and set the `env` to download the plugins:

[source, properties]
----
neo4j:
  name: licenses
  acceptLicenseAgreement: "yes"
  edition: enterprise
volumes:
  data:
    mode: defaultStorageClass
env:
  NEO4J_PLUGINS: '["graph-data-science"]'
config:
  dbms.security.procedures.unrestricted: "gds.*,apoc.*"
----

==== Install GDS Enterprise Edition (EE) and Bloom plugins

To install GDS EE and Bloom, you must provide a license for each plugin.
You provide the licenses in a secret.

. Create a secret containing the licenses:
+
[source, shell]
----
kubectl create secret  generic --from-file=gds.license,bloom.license gds-bloom-license
----
. Configure the Neo4j _values.yaml_ file using the secret as the _/licenses_ volume mount, and set the `env` to download the plugins:
+
[source, properties]
----
neo4j:
  name: licenses
  acceptLicenseAgreement: "yes"
  edition: enterprise
volumes:
  data:
    mode: defaultStorageClass
  licenses:
    mode: volume
    volume:
      secret:
        secretName: gds-bloom-license
        items:
          - key: gds.license
            path: gds.license
          - key: bloom.license
            path: bloom.license
env:
  NEO4J_PLUGINS: '["graph-data-science", "bloom"]'
config:
  gds.enterprise.license_file: "/licenses/gds.license"
  dbms.security.procedures.unrestricted: "gds.*,apoc.*,bloom.*"
  server.unmanaged_extension_classes: "com.neo4j.bloom.server=/bloom,semantics.extension=/rdf"
  dbms.security.http_auth_allowlist: "/,/browser.*,/bloom.*"
  dbms.bloom.license_file: "/licenses/bloom.license"
----

[[init-container-plugin-installation]]
=== Add plugins using an init container

Init containers are specialized containers that run before the main containers (in this case, the Neo4j container) in a pod.
You can use an init container to add plugins that have already been downloaded on an internal file server and are available to you via the internal network.

In the following example a YAML file, called _plugin_initContainer.yaml_ file, configures an init container to download the Apoc plugin from an internal file server to the _/plugins_ directory, which is backed by a persistent volume.
Then, it deploys a Neo4j standalone server. 
When the Neo4j container starts, it automatically installs the plugin from the /plugins directory.

. Configure what operations the init container runs using the `initContainers` property in the _plugin_initContainer.yaml_ file.
+
[NOTE]
====
Some Neo4j plugins, such as Bloom and GDS Enterprise, require a license activation key, which needs to be placed in a directory accessible by the Neo4j Docker container, for example, mounted to _/licenses_ (default).
To obtain a valid license, reach out to your Neo4j account representative or write to licensing@neo4j.com.
====
+
[source, properties]
----
neo4j:
  resources:
    cpu: "0.5"
    memory: "2G"
​
  password: "password"
​
  edition: "enterprise"
  acceptLicenseAgreement: "yes"
​
​
volumes:
  data:
    mode: defaultStorageClass
  plugins:
    mode: "share"
    share:
      name: "data"
# licenses:
  # mode: "share"
  # share:
  #   name: "data"
podSpec:
  initContainers:
    - name: get-plugins
      command: ["wget", "/path/to/the/downloaded/plugin-file/apoc-version-all.jar", "-O", "/plugins/apoc.jar"] 
  # - name: get-licenses
  #   command: ["wget", "/path/to/the/downloaded/plugin-file/plugin-file-version-all.jar", "-O", "/licenses/plugin-file.license"] 
​
config:
  dbms.directories.plugins: "/plugins"
  # dbms.directories.licenses: "/licenses"
  dbms.security.procedures.unrestricted: "apoc.*"  
  dbms.config.strict_validation: "false"
  dbms.security.procedures.allowlist: "apoc.*"

apoc_config:
  apoc.trigger.enabled: "true"
  apoc.jdbc.my.url: "jdbc:foo:bar"
  apoc.import.file.enabled: "true"
----

. Deploy a Neo4j standalone server and the init container:
+
[source, shell]
----
helm install neo4j neo4j/neo4j-standalone -f ~/path/to/plugin_initContainer.yaml
----
. Verify that the plugin is installed:
+
[source, role=noheader]
----
k exec -it standalone-0 -- bash
----
+
.Example output
[source, role=noheader]
----
neo4j@standalone-0:/$ cd /plugins
neo4j@standalone-0:/plugins$ ls -lst
total 21140
21140 -rw-r--r-- 1 neo4j neo4j 21645102 Nov 28 12:03 apoc.jar
----
+
When the pod gets into a READY state, the Neo4j container will be using the APOC plugin.


[[custom-container]]
=== Add plugins using a custom container image

The best method for adding plugins to Neo4j running in Kubernetes is to create a new Docker container image that contains both Neo4j and the Neo4j plugins.
This way, you can ensure when building the container that the correct plugin version for the Neo4j version of the container is used and that the resulting image encapsulates all Neo4j runtime dependencies.

[NOTE]
====
The Neo4j Bloom plugin (https://neo4j.com/download-center/#bloom) requires a license activation key, which needs to be placed in a directory accessible by the Neo4j Docker container, for example, mounted to _/licenses_ (default).
To obtain a valid license, reach out to your Neo4j account representative or write to licensing@neo4j.com.
====

Building a Docker container image that is based on the official Neo4j Docker image and does not override the official image's `ENTRYPOINT` and `COMMAND` is the recommended method to use with the Neo4j Helm chart, as shown in this example Dockerfile:

[source, Dockerfile, subs=attributes]
----
ARG  NEO4J_VERSION
FROM neo4j:\{NEO4J_VERSION}

# copy my-plugins into the Docker image
COPY my-plugins/ /var/lib/neo4j/plugins

# install the apoc core plugin that is shipped with Neo4j
RUN cp /var/lib/neo4j/labs/apoc-* /var/lib/neo4j/plugins
----

Once the docker image has been built, push it to a container repository that is accessible to your Kubernetes cluster.

[source, shell, subs=attributes]
----
CONTAINER_REPOSITORY="my-container-repository.io"
IMAGE_NAME="my-neo4j"

# export this so that it's accessible as a docker build arg
export NEO4J_VERSION={neo4j-version-exact}-enterprise

docker build --build-arg NEO4J_VERSION --tag $\{CONTAINER_REPOSITORY}/$\{IMAGE_NAME}:$\{NEO4J_VERSION} .
docker push $\{CONTAINER_REPOSITORY}/$\{IMAGE_NAME}:$\{NEO4J_VERSION}
----

To use the image that you have created, in the Neo4j Helm deployment's _values.yaml_ file, set `image.customImage` to use the image.
For more details, see xref:kubernetes/configuration.adoc#configure-custom-image[Configure a custom container image].

[NOTE]
====
Many plugins require additional Neo4j configuration to work correctly.
Plugin configuration should be set on the `config` object in the Helm deployment's _values.yaml_ file.
In some cases, plugin configuration can cause Neo4j's strict config validation to fail.
Strict config validation can be disabled by setting `dbms.config.strict_validation: "false"`.
====

[[plugins-volume]]
=== Add plugins using a plugins volume

An alternative method for adding Neo4j plugins to a Neo4j Helm deployment uses a `plugins` volume mount.
With this method, the plugin jar files are stored on a Persistent Volume that is mounted to the `/plugins` directory of the Neo4j container.

[NOTE]
====
The Neo4j Bloom plugin (https://neo4j.com/download-center/#bloom) requires a license activation key, which needs to be placed in a directory accessible by the Neo4j Docker container, for example, mounted to _/licenses_ (default).
To obtain a valid license, reach out to your Neo4j account representative or write to licensing@neo4j.com.
====

The simplest way to set up a persistent _/plugins_ volume is to share the Persistent Volume that is used for storing Neo4j data.
This example shows how to configure that in the Neo4j Helm deployment _values.yaml_ file:

[source, properties]
----
# neo4j-values.yaml
volumes:
  data:
    # your data volume configuration
    ...

  plugins:
    mode: "share"
    share:
      name: "data"
----

Details of different ways to configure volume mounts are covered in xref:kubernetes/persistent-volumes.adoc#volume-mounts[Mapping volume mounts to persistent volumes].

The Neo4j container now has an empty `/plugins` directory backed by a persistent volume.
Plugin jar files can be copied onto the volume using `kubectl cp`.
Because it is backed by a persistent volume, plugin files will persist even if the Neo4j pod is restarted or moved.

[NOTE]
====
Neo4j loads plugins only on startup.
Therefore, you must restart the Neo4j pod to load them once all plugins are in place.
====

For example:

[source, shell]
----
# Copy plugin files into Neo4j container
kubectl cp my-plugins/* <namespace>/<neo4j-pod-name>:/plugins/

# Restart Neo4j
kubectl rollout restart statefulset/<neo4j-statefulset-name>

# Verify plugins are still present after restart
kubectl exec <neo4j-pod-name> -- ls /plugins
----

// Neo4j Browser, Data Import,  fabric?
