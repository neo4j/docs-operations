[[neo4j-procedures]]
= Procedures
:description: This page provides a complete reference to the Neo4j procedures.
:table-caption!:
:table-stripes: hover
:table-frame: topbot

:stem:
:mathjax-tex-packages: ams

This page provides a complete reference to Neo4j's built-in procedures.
// The procedures are grouped into the following categories:


// * <<#_authentication_and_authorization,Authentication and authorization>>
// * <<#_background_job_management,Background job management>>
// * <<#_change_data_capture_cdc,Change Data Capture (CDC)>>
// * <<#_cluster_management,Cluster management>>
// * <<#_configuration_and_dbms_info,Configuration and DBMS info>>
// * <<#_connection_management,Connection management>>
// * <<#_database_management,Database management>>
// * <<#_genai_and_vectors, GenAI and vectors>>
// * <<#_index_management,Index management>>
// * <<#_metrics, Metrics>>
// * <<#_schema_and_metadata,Schema and metadata>>
// * <<#_statistics_and_query_planning,Statistics and query planning>>
// * <<#_transaction_management,Transaction management>>


It also lists current xref:procedures.adoc#deprecated-procedures[deprecated procedures] and the xref:procedures.adoc#removed-procedures[procedures removed in Neo4j 5], along with their replacements.

The available procedures on a server depends on several factors:

* Neo4j Enterprise Edition provides a larger set of procedures than Neo4j Community Edition.
* Neo4j's link:{neo4j-docs-base-uri}/apoc/{page-version}/[APOC Core library] and link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/genai-integrations/[GenAI plugin] are installed by default on link:{neo4j-docs-base-uri}/aura/[Aura] instances, but have to be installed separately on on-prem servers.
* Cluster members have procedures that are not available in standalone mode.

To check which procedures are available in your Neo4j DBMS, use the Cypher command link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/clauses/listing-procedures[`SHOW PROCEDURES`]:

.List available procedures with default output columns
[source, cypher]
----
SHOW PROCEDURES
----

.List available procedures with full output columns
[source, cypher]
----
SHOW PROCEDURES YIELD *
----


[NOTE]
====
Some procedures can only be run by users with `Admin` privileges.
Specifically, either the `EXECUTE ADMIN PROCEDURES` privilege or both the `EXECUTE PROCEDURES` and `EXECUTE BOOSTED PROCEDURES` privileges.
These procedures are labeled with label:admin-only[].

For more information, see xref:authentication-authorization/dbms-administration.adoc#access-control-dbms-administration-execute[the `EXECUTE` privileges section].
====

== Authentication and authorization

For more information, see xref:authentication-authorization/index.adoc[Authentication and authorization].

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_security_clearauthcache]]
=== dbms.security.clearAuthCache()


.Details
|===
| *Syntax* 3+m| dbms.security.clearAuthCache()
| *Description* 3+a| Clears authentication and authorization cache.
| *Mode* 3+| DBMS
|===


[[procedure_dbms_showcurrentuser]]
=== dbms.showCurrentUser()


.Details
|===
| *Syntax* 3+m| dbms.showCurrentUser() :: (username, roles, flags)
| *Description* 3+a| Show the current user.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `username` | `STRING` | The name of the current user.
| `roles` | `LIST<STRING>` | The roles assigned to the current user.
| `flags` | `LIST<STRING>` | The flags set on the current user.
| *Mode* 3+| DBMS
|===


== Background job management

For more information, see xref:monitoring/background-jobs.adoc[].

[[procedure_dbms_scheduler_failedjobs]]
[role=label--enterprise-edition label--admin-only]
=== dbms.scheduler.failedJobs()


.Details
|===
| *Syntax* 3+m| dbms.scheduler.failedJobs() :: (jobId, group, database, submitter, description, type, submitted, executionStart, failureTime, failureDescription)
| *Description* 3+a| List failed job runs. There is a limit for amount of historical data.
.11+| *Return arguments* | *Name* | *Type* | *Description*
| `jobId` | `STRING` | The id of the failed job.
| `group` | `STRING` | The category of the failed job.
| `database` | `STRING` | The name of the database the job failed in.
| `submitter` | `STRING` | The creator of the failed job.
| `description` | `STRING` | Information about the failed job.
| `type` | `STRING` | The interval of the failed job.
| `submitted` | `STRING` | The submission time of the failed job.
| `executionStart` | `STRING` | The start time of the failed job.
| `failureTime` | `STRING` | The failure time of the failed job.
| `failureDescription` | `STRING` | Information about the job failure.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_scheduler_groups]]
=== dbms.scheduler.groups()


.Details
|===
| *Syntax* 3+m| dbms.scheduler.groups() :: (group, threads)
| *Description* 3+a| List the job groups that are active in the database internal job scheduler.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `group` | `STRING` | The name of the job group.
| `threads` | `INTEGER` | The number of active threads in that job group.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_scheduler_jobs]]
=== dbms.scheduler.jobs()


.Details
|===
| *Syntax* 3+m| dbms.scheduler.jobs() :: (jobId, group, submitted, database, submitter, description, type, scheduledAt, period, state, currentStateDescription)
| *Description* 3+a| List all jobs that are active in the database internal job scheduler.
.12+| *Return arguments* | *Name* | *Type* | *Description*
| `jobId` | `STRING` | The id of the job.
| `group` | `STRING` | The category of the job.
| `submitted` | `STRING` | The submission time of the job.
| `database` | `STRING` | The name of the database the job is in.
| `submitter` | `STRING` | The creator of the job.
| `description` | `STRING` | Information about the job.
| `type` | `STRING` | The interval of the job.
| `scheduledAt` | `STRING` | The start time of the job.
| `period` | `STRING` | The interval for jobs run periodically.
| `state` | `STRING` | The state of the job: ('EXECUTING', 'SCHEDULED').
| `currentStateDescription` | `STRING` | A description of the job state.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== Change Data Capture (CDC)

For more information, see the link:{neo4j-docs-base-uri}/cdc/{page-version}/[CDC documentation].

[role=label--enterprise-edition label--new-5.14 label--beta label--deprecated-5.17]
[[procedure_cdc_current]]
=== cdc.current()


.Details
|===
| *Syntax* 3+m| cdc.current() :: (id)
| *Description* 3+a| Returns the current change identifier that can be used to stream changes from.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
| *Replaced by* 3+| xref:procedures.adoc#db_cdc_current[`db.cdc.current()`]
|===

[role=label--enterprise-edition label--new-5.13 label--beta label--deprecated-5.17]
[[procedure_cdc_earliest]]
=== cdc.earliest()


.Details
|===
| *Syntax* 3+m| cdc.earliest() :: (id)
| *Description* 3+a| Returns the earliest change identifier that can be used to stream changes from.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
| *Replaced by* 3+| xref:procedures.adoc#db_cdc_earliest[`db.cdc.earliest()`]
|===

[role=label--enterprise-edition label--new-5.13 label--beta label--deprecated-5.17]
[[procedure_cdc_query]]
=== cdc.query()


.Details
|===
| *Syntax* 3+m| cdc.query([ from selectors ]) :: (id, txId, seq, metadata, event)
| *Description* 3+a| Query changes that happened from the provided change identifier.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `from` | `STRING` | The change identifier to query changes from.
| `selectors` | `LIST<MAP>` | An optional list of selectors to filter out changes.
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier for this change event. Used to continue querying from this change event.
| `txId` | `INTEGER` | A number identifying which transaction the change happened in, unique in combination with seq.
| `seq` | `INTEGER` | A number used for ordering changes that happened in the same transaction.
| `metadata` | `MAP` | Metadata from the transaction that caused this change event.
| `event` | `MAP` | The retrieved changes on the affected entity.
| *Mode* 3+| READ
| *Replaced by* 3+| xref:procedures.adoc#db_cdc_query[`db.cdc.query()`]
|===

[role=label--enterprise-edition label--new-5.17 label--beta]
[[procedure_db_cdc_current]]
=== db.cdc.current()


.Details
|===
| *Syntax* 3+m| db.cdc.current() :: (id)
| *Description* 3+a| Returns the current change identifier that can be used to stream changes from.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
|===

[role=label--new-5.17 label--beta]
[[procedure_db_cdc_earliest]]
=== db.cdc.earliest()


.Details
|===
| *Syntax* 3+m| db.cdc.earliest() :: (id)
| *Description* 3+a| Returns the earliest change identifier that can be used to stream changes from.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
|===

[role=label--enterprise-edition label--new-5.17 label--beta label--admin-only]
[[procedure_db_cdc_query]]
=== db.cdc.query()


.Details
|===
| *Syntax* 3+m| db.cdc.query([ from selectors ]) :: (id, txId, seq, metadata, event)
| *Description* 3+a| Query changes that happened from the provided change identifier.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `from` | `STRING` | The change identifier to query changes from.
| `selectors` | `LIST<MAP>` | An optional list of selectors to filter out changes.
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier for this change event. Used to continue querying from this change event.
| `txId` | `INTEGER` | A number identifying which transaction the change happened in, unique in combination with seq.
| `seq` | `INTEGER` | A number used for ordering changes that happened in the same transaction.
| `metadata` | `MAP` | Metadata from the transaction that caused this change event.
| `event` | `MAP` | The retrieved changes on the affected entity.
| *Mode* 3+| READ
|===

== Cluster management

For more information, see xref:clustering/index.adoc[].

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_cluster_checkConnectivity]]
=== dbms.cluster.checkConnectivity()


.Details
|===
| *Syntax* 3+m| dbms.cluster.checkConnectivity([ port-name server ]) :: (serverId, name, address, mode-constraint, port-name, port-address, result)
| *Description* 3+a| Check the connectivity of this instance to other cluster members. Not all ports are relevant to all members. Valid values for 'port-name' are: [CLUSTER, INTRA_BOLT, RAFT]
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `port-name` | `STRING` | The name of the port: ('CLUSTER', 'RAFT').
| `server` | `STRING` | The id of the server to check connectivity of.
.8+| *Return arguments* | *Name* | *Type* | *Description*
| `serverId` | `STRING` | The id of the checked server.
| `name` | `STRING` | name :: STRING
| `address` | `STRING` | address :: STRING
| `mode-constraint` | `STRING` | The instance mode constraint of the server.
| `port-name` | `STRING` | The name of the checked port.
| `port-address` | `STRING` | The address of the checked port.
| `result` | `STRING` | Whether the check was successful or not.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition]
[[procedure_dbms_cluster_cordonServer]]
=== dbms.cluster.cordonServer()


.Details
|===
| *Syntax* 3+m| dbms.cluster.cordonServer(server)
| *Description* 3+a| Mark a server in the topology as not suitable for new allocations. It will not force current allocations off the server. This is useful when deallocating databases when you have multiple unavailable servers.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The name or id of the server to be cordoned.
| *Mode* 3+| WRITE
|*Required provileges* 3+| `SERVER MANAGEMENT`
|===


[NOTE]
====
Before Neo4j 5.23, the procedure `dbms.cluster.cordonServer()` can be run only by users with `Admin` privileges.
Since Neo4j 5.23, it can be run with the `SERVER MANAGEMENT` privilege.
It will still run with the `Admin` privilege, but that should be considered deprecated.
====


[role=label--enterprise-edition label--new-5.23]
[[procedure_dbms_cluster_deallocateDatabaseFromServer]]
=== dbms.cluster.deallocateDatabaseFromServer()


.Details
|===
| *Syntax* 3+m| dbms.cluster.deallocateDatabaseFromServer(server, database [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Deallocate a specific user database from a specific server.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The id of the server to deallocate from.
| `database` | `STRING` | The name of the database to deallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required provileges* 3+| `SERVER MANAGEMENT`
|===

[role=label--enterprise-edition label--new-5.23]
[[procedure_dbms_cluster_deallocateDatabaseFromServers]]
=== dbms.cluster.deallocateDatabaseFromServers()


.Details
|===
| *Syntax* 3+m| dbms.cluster.deallocateDatabaseFromServers(servers, database [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Deallocate a specific user database from a list of servers.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `servers` | `LIST<STRING>` | The ids of the servers to deallocate from.
| `database` | `STRING` | The id of the database to deallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required provileges* 3+| `SERVER MANAGEMENT`
|===

[role=label--enterprise-edition label--new-5.23]
[[procedure_dbms_cluster_deallocateNumberOfDatabases]]
=== dbms.cluster.deallocateNumberOfDatabases()


.Details
|===
| *Syntax* 3+m| dbms.cluster.deallocateNumberOfDatabases(server, number [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Deallocate a number of user databases from a specific server.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The id of the server to deallocate from.
| `number` | `INTEGER` | The number of databases to deallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required provileges* 3+| `SERVER MANAGEMENT`
|===

[role=label--enterprise-edition]
[[procedure_dbms_cluster_protocols]]
=== dbms.cluster.protocols()


.Details
|===
| *Syntax* 3+m| dbms.cluster.protocols() :: (orientation, remoteAddress, applicationProtocol, applicationProtocolVersion, modifierProtocols)
| *Description* 3+a| Overview of installed protocols
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `orientation` | `STRING` | Direction of the protocol (inbound or outbound).
| `remoteAddress` | `STRING` | The socket address this protocol is available on.
| `applicationProtocol` | `STRING` | The name of the protocol.
| `applicationProtocolVersion` | `INTEGER` | The version of the protocol.
| `modifierProtocols` | `STRING` | Installed modifier protocols, for example, compression.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition label--admin-only label--deprecated-5.6]
[[procedure_dbms_cluster_readreplicatoggle]]
=== dbms.cluster.readReplicaToggle()


.Details
|===
| *Syntax* 3+m| dbms.cluster.readReplicaToggle(databaseName, pause) :: (state)
| *Description* 3+a| The toggle can pause or resume read replica (deprecated in favor of dbms.cluster.secondaryReplicationDisable)
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database to toggle the secondary replication process for.
| `pause` | `BOOLEAN` | Whether or not to enable/disable the secondary replication process.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `state` | `STRING` | The current state of the secondary replication process.
| *Mode* 3+| DBMS
|===


[TIP]
====
_What is it for?_

You can perform a point-in-time backup, as the backup will contain only the transactions up to the point where the transaction pulling was paused.
Follow these steps to do so:

. Connect directly to the server hosting the database in secondary mode. (Neo4j Driver use `bolt://` or use the HTTP API).
. Pause transaction pulling for the specified database.
. Back up the database, see xref:backup-restore/online-backup.adoc[Back up an online database].

If connected directly to a server hosting a database in secondary mode, Data Scientists can execute analysis on a specific database that is paused, the data will not unexpectedly change while performing the analysis.
====

[NOTE]
====
This procedure can only be executed on a database that runs in a secondary role on the connected server.
====


.Pause transaction pulling for database `neo4j`
[source, cypher, role="noheader"]
----
CALL dbms.cluster.readReplicaToggle("neo4j", true)
----


.Resume transaction pulling for database `neo4j`
[source, cypher, role="noheader"]
----
CALL dbms.cluster.readReplicaToggle("neo4j", false)
----

[role=label--enterprise-edition label--new-5.23]
[[procedure_dbms_cluster_reallocateDatabase]]
=== dbms.cluster.reallocateDatabase()


.Details
|===
| *Syntax* 3+m| dbms.cluster.reallocateDatabase(database [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Reallocate a specific database.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database to reallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required provileges* 3+| `SERVER MANAGEMENT`
|===

[role=label--enterprise-edition label--new-5.23]
[[procedure_dbms_cluster_reallocateNumberOfDatabases]]
=== dbms.cluster.reallocateNumberOfDatabases()

.Details
|===
| *Syntax* 3+m| dbms.cluster.reallocateNumberOfDatabases(number [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Reallocate a specified number of user databases.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `number` | `INTEGER` | The number of databases to reallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required provileges* 3+| `SERVER MANAGEMENT`
|===

[role=label--enterprise-edition label--new-5.24]
[[procedure_dbms_cluster_recreateDatabase]]
=== dbms.cluster.recreateDatabase()

.Details
|===
| *Syntax* 3+m| dbms.cluster.recreateDatabase(database :: STRING, options = {} :: MAP)
| *Description* 3+a| Recreates a database while keeping all RBAC settings.
The procedure initiates a process, which when complete, will have synchronized and started all database instances within the cluster.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | database :: STRING
| `options` | `MAP` | options = {} :: MAP
| *Mode* 3+| WRITE
|===


[role=label--enterprise-edition label--deprecated-5.21]
[[procedure_dbms_cluster_routing_getroutingtable]]
=== dbms.cluster.routing.getRoutingTable()


.Details
|===
| *Syntax* 3+m| dbms.cluster.routing.getRoutingTable(context [, database ]) :: (ttl, servers)
| *Description* 3+a| Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example, an endpoint may serve read queries, write queries, and/or future `getRoutingTable` requests.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `context` | `MAP` | Routing context, for example, routing policies.
| `database` | `STRING` | The database to get a routing table for.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `ttl` | `INTEGER` | Time to live (in seconds) for the routing table.
| `servers` | `LIST<MAP>` | Servers grouped by whether they are readers, writers, or routers.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition label--new-5.6 label--admin-only]
[[procedure_dbms_cluster_secondaryreplicationdisable]]
=== dbms.cluster.secondaryReplicationDisable()


.Details
|===
| *Syntax* 3+m| dbms.cluster.secondaryReplicationDisable(databaseName, pause) :: (state)
| *Description* 3+a| The toggle can pause or resume the secondary replication process.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database to toggle the secondary replication process for.
| `pause` | `BOOLEAN` | Whether or not to enable/disable the secondary replication process.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `state` | `STRING` | The current state of the secondary replication process.
| *Mode* 3+| DBMS
|===

[TIP]
====
_What is it for?_

You can perform a point-in-time backup, as the backup will contain only the transactions up to the point where the transaction pulling was paused.
Follow these steps to do so:

. Connect directly to the server hosting the database in secondary mode. (Neo4j Driver use `bolt://` or use the HTTP API).
. Pause transaction pulling for the specified database.
. Back up the database, see xref:backup-restore/online-backup.adoc[Back up an online database].

If connected directly to a server hosting a database in secondary mode, Data Scientists can execute analysis on a specific database that is paused, the data will not unexpectedly change while performing the analysis.
====

[NOTE]
====
This procedure can only be executed on a database that runs in a secondary role on the connected server.
====

.Pause transaction pulling for database `neo4j`
[source, cypher, role="noheader"]
----
CALL dbms.cluster.secondaryReplicationDisable("neo4j", true)
----

.Resume transaction pulling for database `neo4j`
[source, cypher, role="noheader"]
----
CALL dbms.cluster.secondaryReplicationDisable("neo4j", false)
----

[role=label--enterprise-edition]
[[procedure_dbms_cluster_setAutomaticallyEnableFreeServers]]
=== dbms.cluster.setAutomaticallyEnableFreeServers()


.Details
|===
| *Syntax* 3+m| dbms.cluster.setAutomaticallyEnableFreeServers(autoEnable)
| *Description* 3+a| With this method you can set whether free servers are automatically enabled.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `autoEnable` | `BOOLEAN` | Whether or not to automatically enable free servers.
| *Mode* 3+| WRITE
| *Required provileges* 3+| `SERVER MANAGEMENT`
|===


[NOTE]
====
Before Neo4j 5.23, the procedure `dbms.cluster.setAutomaticallyEnableFreeServers()` can be run only by users with the `Admin` privileges.
Since Neo4j 5.23, it can be run with the `SERVER MANAGEMENT` privilege.
It will still run with the `Admin` privilege, but that should be considered deprecated.
====

[role=label--enterprise-edition label--new-5.22 label--admin-only ]
[[procedure_dbms_cluster_showparalleldiscoverystate]]
=== dbms.cluster.showParallelDiscoveryState()


.Details
|===
| *Syntax* 3+m| dbms.cluster.showParallelDiscoveryState() :: (mode, stateComparison, v1ServerCount, v2ServerCount)
| *Description* 3+a| Compare the states of Discovery service V1 and Discovery service V2.
.5+| *Return arguments* | *Name* | *Type* | *Description*
| `mode` | `STRING` | mode :: STRING
| `stateComparison` | `STRING` | stateComparison :: STRING
| `v1ServerCount` | `STRING` | v1ServerCount :: STRING
| `v2ServerCount` | `STRING` | v2ServerCount :: STRING
| *Mode* 3+| DBMS
|===


[role=label--enterprise-edition label--new-5.24 label--admin-only]
[[procedure_dbms_cluster_statusCheck]]
=== dbms.cluster.statusCheck()

.Details
|===
| *Syntax* 3+m| dbms.cluster.statusCheck(databases, timeoutMilliseconds) :: (database, serverId, serverName, address, replicationSuccessful, memberStatus, recognisedLeader, recognisedLeaderTerm, requester, error)
| *Description* 3+a| Performs a rafted status check.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `databases` | `LIST<STRING>` | databases :: LIST<STRING>
| `timeoutMilliseconds` | `INTEGER` | timeoutMilliseconds = null :: INTEGER
.11+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | database :: STRING
| `serverId` | `STRING` | serverId :: STRING
| `serverName` | `STRING` | serverName :: STRING
| `address` | `STRING` | address :: STRING
| `replicationSuccessful` | `BOOLEAN` | replicationSuccessful :: BOOLEAN
| `memberStatus` | `STRING` | memberStatus :: STRING
| `recognisedLeader` | `STRING` | recognisedLeaderTerm :: INTEGER
| `recognisedLeaderTerm` | `STRING` | requester :: BOOLEAN
| `requester` | `STRING` | requester :: BOOLEAN
| `error` | `STRING` | error :: STRING
| *Mode* 3+| DBMS
|===


[role=label--enterprise-edition label--new-5.22 label--admin-only]
[[procedure_dbms_cluster_switchdiscoveryserviceversion]]
=== dbms.cluster.switchDiscoveryServiceVersion()


.Details
|===
| *Syntax* 3+m| dbms.cluster.switchDiscoveryServiceVersion(mode)
| *Description* 3+a| Allows you to select which discovery service should be started.
Possible values are:

* `V1_ONLY` -- it runs only discovery service v1.
* `V1_OVER_V2` -- it runs both Discovery Service V1 and Discovery Service V2, where V1 is the main service and V2 runs in the background.
* `V2_OVER_V1` -- it runs both Discovery Service V1 and Discovery Service V2, where V2 is the main service and V1 runs in the background.
* `V2_ONLY` -- it runs only discovery service v2.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `mode` | `STRING` | mode :: STRING
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition label--deprecated-5.23]
[[procedure_dbms_cluster_uncordonServer]]
=== dbms.cluster.uncordonServer()


.Details
|===
| *Syntax* 3+m| dbms.cluster.uncordonServer(server)
| *Description* 3+a| Remove the cordon on a server, returning it to 'enabled'.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The name or id of the server to be uncordoned.
| *Mode* 3+| WRITE
| *Replaced by* 3+| xref:clustering/server-syntax.adoc#server-management-syntax[`ENABLE SERVER`]
|*Required provileges* 3+| `SERVER MANAGEMENT`
|===

[NOTE]
====
Before Neo4j 5.23, the procedure `dbms.cluster.uncordonServer()` can be run only by users with `Admin` privileges.
Since Neo4j 5.23, it can be run with the `SERVER MANAGEMENT` privilege.
It will still run with the `Admin` privilege, but that should be considered deprecated.
====

[role=label--enterprise-edition label--admin-only label--deprecated-5.23]
[[procedure_dbms_setDatabaseAllocator]]
=== dbms.setDatabaseAllocator()


.Details
|===
| *Syntax* 3+m| dbms.setDatabaseAllocator(allocator)
| *Description* 3+a| With this method you can set the allocator that is responsible for selecting servers for hosting databases.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `allocator` | `STRING` | The name of the allocator.
| *Mode* 3+| WRITE
|===


[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_setDefaultAllocationNumbers]]
=== dbms.setDefaultAllocationNumbers()


.Details
|===
| *Syntax* 3+m| dbms.setDefaultAllocationNumbers(primaries, secondaries)
| *Description* 3+a| With this method you can set the default number of primaries and secondaries.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `primaries` | `INTEGER` | The default number of primaries.
| `secondaries` | `INTEGER` | The default number of secondaries.
| *Mode* 3+| WRITE
|===

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_showTopologyGraphConfig]]
=== dbms.showTopologyGraphConfig()


.Details
|===
| *Syntax* 3+m| dbms.showTopologyGraphConfig() :: (allocator, defaultPrimariesCount, defaultSecondariesCount, defaultDatabase, autoEnableFreeServers)
| *Description* 3+a| With this method the configuration of the Topology Graph can be displayed.
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `allocator` | `STRING` | The name of the allocator.
| `defaultPrimariesCount` | `INTEGER` | The default number of primaries.
| `defaultSecondariesCount` | `INTEGER` | The default number of secondaries.
| `defaultDatabase` | `STRING` | The name of the default database.
| `autoEnableFreeServers` | `BOOLEAN` | Whether or not to automatically enable free servers.
| *Mode* 3+| READ
|===


== Configuration and DBMS info

For more information, see xref:configuration/index.adoc[].

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_checkconfigvalue]]
=== dbms.checkConfigValue()


.Details
|===
| *Syntax* 3+m| dbms.checkConfigValue(setting, value) :: (valid, message)
| *Description* 3+a| Check if a potential config setting value is valid.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `setting` | `STRING` | The name of the setting.
| `value` | `STRING` | The setting value to verify.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `valid` | `BOOLEAN` | Whether or not the setting value is valid.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


[[procedure_dbms_components]]
=== dbms.components()


.Details
|===
| *Syntax* 3+m| dbms.components() :: (name, versions, edition)
| *Description* 3+a| List DBMS components and their versions.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The name of the component.
| `versions` | `LIST<STRING>` | The installed versions of the component.
| `edition` | `STRING` | The Neo4j edition of the DBMS.
| *Mode* 3+| DBMS
|===


[[procedure_dbms_info]]
=== dbms.info()


.Details
|===
| *Syntax* 3+m| dbms.info() :: (id, name, creationDate)
| *Description* 3+a| Provides information regarding the DBMS.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The id of the DBMS.
| `name` | `STRING` | The name of the DBMS.
| `creationDate` | `STRING` | The creation date of the DBMS.
| *Mode* 3+| DBMS
|===

[[procedure_dbms_listcapabilities]]
=== dbms.listCapabilities()


.Details
|===
| *Syntax* 3+m| dbms.listCapabilities() :: (name, description, value)
| *Description* 3+a| List capabilities.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The full name of the capability (e.g. "dbms.instance.version").
| `description` | `STRING` | The capability description (e.g. "Neo4j version this instance is running").
| `value` | `ANY` | The capability object if it is present in the system (e.g. "5.20.0").
| *Mode* 3+| DBMS
|===

[role=label--admin-only]
[[procedure_dbms_listconfig]]
=== dbms.listConfig()


.Details
|===
| *Syntax* 3+m| dbms.listConfig([ searchString ]) :: (name, description, value, dynamic, defaultValue, startupValue, explicitlySet, validValues)
| *Description* 3+a| List the currently active configuration settings of Neo4j.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `searchString` | `STRING` | A string that filters on the name of config settings.
.9+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The name of the setting.
| `description` | `STRING` | The description of the setting.
| `value` | `STRING` | The set value of the setting.
| `dynamic` | `BOOLEAN` | If the setting can be set dynamically or not.
| `defaultValue` | `STRING` | The default value of the setting.
| `startupValue` | `STRING` | The value of the setting when the database started.
| `explicitlySet` | `BOOLEAN` | Whether or not the setting was explicitly set.
| `validValues` | `STRING` | A description of the valid values.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition label--admin-only label--not-on-aura]
[[procedure_dbms_setconfigvalue]]
=== dbms.setConfigValue()


.Details
|===
| *Syntax* 3+m| dbms.setConfigValue(setting, value)
| *Description* 3+a| Update a given setting value. Passing an empty value results in removing the configured value and falling back to the default value. Changes do not persist and are lost if the server is restarted. In a clustered environment, `dbms.setConfigValue` affects only the cluster member it is run against.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `setting` | `STRING` | The name of the setting.
| `value` | `STRING` | The value to set.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition]
[[procedure_dbms_listpools]]
=== dbms.listPools()


.Details
|===
| *Syntax* 3+m| dbms.listPools() :: (pool, databaseName, heapMemoryUsed, heapMemoryUsedBytes, nativeMemoryUsed, nativeMemoryUsedBytes, freeMemory, freeMemoryBytes, totalPoolMemory, totalPoolMemoryBytes)
| *Description* 3+a| List all memory pools, including sub pools, currently registered at this instance that are visible to the user.
.11+| *Return arguments* | *Name* | *Type* | *Description*
| `pool` | `STRING` | The name of the memory pool.
| `databaseName` | `STRING` | The name of the database.
| `heapMemoryUsed` | `STRING` | The amount of heap memory used.
| `heapMemoryUsedBytes` | `STRING` | The amount of heap memory used in bytes.
| `nativeMemoryUsed` | `STRING` | The amount of native memory used.
| `nativeMemoryUsedBytes` | `STRING` | The amount of native memory used in bytes.
| `freeMemory` | `STRING` | The amount of free memory.
| `freeMemoryBytes` | `STRING` | The amount of free memory in bytes.
| `totalPoolMemory` | `STRING` | The total pool memory.
| `totalPoolMemoryBytes` | `STRING` | The total pool memory in bytes.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== Connection management

For more information, see xref:monitoring/connection-management.adoc[].

[[procedure_dbms_listconnections]]
=== dbms.listConnections()


.Details
|===
| *Syntax* 3+m| dbms.listConnections() :: (connectionId, connectTime, connector, username, userAgent, serverAddress, clientAddress)
| *Description* 3+a| List all accepted network connections at this instance that are visible to the user.
.8+| *Return arguments* | *Name* | *Type* | *Description*
| `connectionId` | `STRING` | The id of the connection.
| `connectTime` | `STRING` | The time the connection was established.
| `connector` | `STRING` | The protocol of the connector.
| `username` | `STRING` | The username of the connected user.
| `userAgent` | `STRING` | The active agent.
| `serverAddress` | `STRING` | The address of the connected server.
| `clientAddress` | `STRING` | The address of the connected client.
| *Mode* 3+| DBMS
|===

[[procedure_dbms_killconnection]]
=== dbms.killConnection()


.Details
|===
| *Syntax* 3+m| dbms.killConnection(id) :: (connectionId, username, message)
| *Description* 3+a| Kill network connection with the given connection id.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The id of the connection to kill.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `connectionId` | `STRING` | The id of the connection killed.
| `username` | `STRING` | The username of the user of the killed connection.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===

[[procedure_dbms_killconnections]]
=== dbms.killConnections()


.Details
|===
| *Syntax* 3+m| dbms.killConnections(ids) :: (connectionId, username, message)
| *Description* 3+a| Kill all network connections with the given connection ids.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `ids` | `LIST<STRING>` | The ids of the connections to kill.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `connectionId` | `STRING` | The id of the connection killed.
| `username` | `STRING` | The username of the user of the killed connection.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===


== Database management

For more information, see xref:database-administration/index.adoc[] and xref:database-internals/index.adoc[].

[role=label--enterprise-edition]
[[procedure_db_checkpoint]]
=== db.checkpoint()


.Details
|===
| *Syntax* 3+m| db.checkpoint() :: (success, message)
| *Description* 3+a| Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `db.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `success` | `BOOLEAN` | Whether the checkpoint has successfully completed.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_info]]
=== db.info()


.Details
|===
| *Syntax* 3+m| db.info() :: (id, name, creationDate)
| *Description* 3+a| Provides information regarding the database.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The id of the database.
| `name` | `STRING` | The name of the database.
| `creationDate` | `STRING` | The creation date of the database.
| *Mode* 3+| READ
|===

[role=label--enterprise-edition]
[[procedure_dbms_listactivelocks]]
=== dbms.listActiveLocks()


.Details
|===
| *Syntax* 3+m| dbms.listActiveLocks(queryId) :: (mode, resourceType, resourceId)
| *Description* 3+a| List the active lock requests granted for the transaction executing the query with the given query id.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `queryId` | `STRING` | The id of the query to check for active locks on.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `mode` | `STRING` | The lock type: ('SHARED', 'EXCLUSIVE').
| `resourceType` | `STRING` | The locked resource.
| `resourceId` | `INTEGER` | The id of the locked resource.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[role=label--enterprise-edition label--admin-only]
[[procedure_listlocks]]
=== db.listLocks()


.Details
|===
| *Syntax* 3+m| db.listLocks() :: (mode, resourceType, resourceId, transactionId)
| *Description* 3+a| List all locks at this database.
.5+| *Return arguments* | *Name* | *Type* | *Description*
| `mode` | `STRING` | The locking mode this lock is using, either "SHARED" or "EXCLUSIVE".
| `resourceType` | `STRING` | The type of resource (e.g. nodes, relationships, labels) this lock protects.
| `resourceId` | `INTEGER` | The id of the resource this lock protects.
| `transactionId` | `STRING` | The id of the transaction that owns this lock.
| *Mode* 3+| DBMS
|===

[[procedure_db_ping]]
=== db.ping()


.Details
|===
| *Syntax* 3+m| db.ping() :: (success)
| *Description* 3+a| This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `success` | `BOOLEAN` | Whether or not the connection call to the database has been successful.
| *Mode* 3+| READ
|===

[[procedure_dbms_routing_getroutingtable]]
=== dbms.routing.getRoutingTable()


.Details
|===
| *Syntax* 3+m| dbms.routing.getRoutingTable(context [, database ]) :: (ttl, servers)
| *Description* 3+a| Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example, an endpoint may serve read queries, write queries, and/or future `getRoutingTable` requests.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `context` | `MAP` | Routing context, for example, routing policies.
| `database` | `STRING` | The database to get a routing table for.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `ttl` | `INTEGER` | Time to live (in seconds) for the routing table.
| `servers` | `LIST<MAP>` | Servers grouped by whether they are readers, writers, or routers.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_setDefaultDatabase]]
=== dbms.setDefaultDatabase()


.Details
|===
| *Syntax* 3+m| dbms.setDefaultDatabase(databaseName) :: (result)
| *Description* 3+a| Change the default database to the provided value. The database must exist and the old default database must be stopped.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `result` | `STRING` | Information about the default database.
| *Mode* 3+| WRITE
|===

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_quarantineDatabase]]
=== dbms.quarantineDatabase()


.Details
|===
| *Syntax* 3+m| dbms.quarantineDatabase(databaseName, setStatus [, reason ]) :: (databaseName, quarantined, result)
| *Description* 3+a| Place a database into quarantine or remove it from it.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database to set the quarantine status of.
| `setStatus` | `BOOLEAN` | Whether or not to quarantine the database.
| `reason` | `STRING` | The reason to quarantine the database.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database.
| `quarantined` | `BOOLEAN` | Whether or not the database is quarantined.
| `result` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===

[role=label--admin-only label--deprecated-5.9]
[[procedure_dbms_upgrade]]
=== dbms.upgrade()


.Details
|===
| *Syntax* 3+m| dbms.upgrade() :: (status, upgradeResult)
| *Description* 3+a| Upgrade the system database schema if it is not the current schema.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `status` | `STRING` | The upgrade status of the system database.
| `upgradeResult` | `STRING` | Information about the upgrade outcome.
| *Mode* 3+| WRITE
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


[role=label--admin-only label--deprecated-5.9]
[[procedure_dbms_upgradestatus]]
=== dbms.upgradeStatus()


.Details
|===
| *Syntax* 3+m| dbms.upgradeStatus() :: (status, description, resolution)
| *Description* 3+a| Report the current status of the system database sub-graph schema.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `status` | `STRING` | The upgrade status of the system database.
| `description` | `STRING` | Information describing the upgrade status.
| `resolution` | `STRING` | Information about the steps necessary to upgrade.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== GenAI and vectors

For more information, see:

* link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes/semantic-indexes/vector-indexes/[Cypher Manual -> Vector indexes]
* link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/genai-integrations[Cypher Manual -> GenAI integrations]
* link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/functions/vector-functions/[Cypher Manual -> Vector functions]
* link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/functions/genai-functions/[Cypher Manual -> GenAI functions]
* link:{neo4j-docs-base-uri}/genai/tutorials/embeddings-vector-indexes/[GenAI documentation -> Embeddings & Vector Indexes Tutorial]

[role=label--new-5.13 label--beta]
[[procedure_db_create_setnodevectorproperty]]
=== db.create.setNodeVectorProperty


.Details
|===
| *Syntax* 3+m| db.create.setNodeVectorProperty(node, key, vector)
| *Description* 3+a| Set a vector property on a given node in a more space efficient representation than Cypher's `SET`.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | The node on which the new property will be stored.
| `key` | `STRING` | The name of the new property.
| `vector` | `ANY` | The object containing the embedding.
| *Mode* 3+| WRITE
|===

.Known issue
[NOTE]
====
Procedure signatures from `SHOW PROCEDURES` renders the vector arguments with a type of `ANY` rather than the semantically correct type of `LIST<INTEGER | FLOAT>`.
The types are still enforced as `LIST<INTEGER | FLOAT>`.
====

[role=label--new-5.18 label--beta]
[[procedure_db_create_setrelationshipvectorproperty]]
=== db.create.setRelationshipVectorProperty()


.Details
|===
| *Syntax* 3+m| db.create.setRelationshipVectorProperty(relationship, key, vector)
| *Description* 3+a| Set a vector property on a given relationship in a more space efficient representation than Cypher's `SET`.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `relationship` | `RELATIONSHIP` | The relationship on which the new property will be stored.
| `key` | `STRING` | The name of the new property.
| `vector` | `ANY` | The object containing the embedding.
| *Mode* 3+| WRITE
|===

.Known issue
[NOTE]
====
Procedure signatures from `SHOW PROCEDURES` renders the vector arguments with a type of `ANY` rather than the semantically correct type of `LIST<INTEGER | FLOAT>`.
The types are still enforced as `LIST<INTEGER | FLOAT>`.
====

[role=label--new-5.11 label--beta label--deprecated-5.13]
[[procedure_db_create_setvectorproperty]]
=== db.create.setVectorProperty()


.Details
|===
| *Syntax* 3+m| db.create.setVectorProperty(node, key, vector) :: (node)
| *Description* 3+a| Set a vector property on a given node in a more space efficient representation than Cypher's SET.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | The node on which the new property will be stored.
| `key` | `STRING` | The name of the new property.
| `vector` | `ANY` | The object containing the embedding.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | The node on which the vector property was set.
| *Mode* 3+| WRITE
| *Replaced by* 3+| xref:procedures.adoc#procedure_db_create_setnodevectorproperty[`db.create.setNodeVectorProperty()`] and xref:procedures.adoc#procedure_db_create_setrelationshipvectorproperty[`db.create.setRelationshipVectorProperty()`]
|===

.Known issue
[NOTE]
====
Procedure signatures from `SHOW PROCEDURES` renders the vector arguments with a type of `ANY` rather than the semantically correct type of `LIST<INTEGER | FLOAT>`.
The types are still enforced as `LIST<INTEGER | FLOAT>`.
====


[role=label--new-5.11]
[[procedure_db_index_vector_createnodeindex]]
=== db.index.vector.createNodeIndex()


.Details
|===
| *Syntax* 3+m| db.index.vector.createNodeIndex(indexName, label, propertyKey, vectorDimension, vectorSimilarityFunction)
| *Description* 3+a| Create a named node vector index for the specified label and property with the given vector dimensionality using either the EUCLIDEAN or COSINE similarity function.
Both similarity functions are case-insensitive.
Use the `db.index.vector.queryNodes` procedure to query the named index.

.6+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | indexName :: STRING
| `label` | `STRING` | label :: STRING
| `propertyKey` | `STRING` | propertyKey :: STRING
| `vectorDimension` | `INTEGER` | vectorDimension :: INTEGER
| `vectorSimilarityFunction` | `STRING` | vectorSimilarityFunction :: STRING
| *Mode* 3+| SCHEMA
|===

[NOTE]
As of Neo4j 5.15, vector indexes can be created with the Cypher Command `CREATE VECTOR INDEX`.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes/semantic-indexes/vector-indexes/#create-vector-index[Cypher Manual -> Create a vector index].

[role=label--new-5.18]
[[procedure_db_index_vector_queryrelationships]]
=== db.index.vector.queryRelationships()


.Details
|===
| *Syntax* 3+m| db.index.vector.queryRelationships(indexName, numberOfNearestNeighbours, query) :: (relationship, score)
| *Description* 3+a| Query the given relationship vector index.
Returns requested number of nearest neighbors to the provided query vector,
and their similarity score to that query vector, based on the configured similarity function for the index.
The similarity score is a value between [0, 1]; where 0 indicates least similar, 1 most similar.

.4+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the vector index.
| `numberOfNearestNeighbours` | `INTEGER` | The size of the vector neighbourhood.
| `query` | `ANY` | The object to find approximate matches for.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `relationship` | `RELATIONSHIP` | A relationship which contains a vector property similar to the query object.
| `score` | `FLOAT` | The score measuring how similar the node property is to the query object.
| *Mode* 3+| READ
|===


[role=label--new-5.17]
[[procedure_genai_vector_encodeBatch]]
=== genai.vector.encodeBatch()


.Details
|===
| *Syntax* 3+m| genai.vector.encodeBatch(resources, provider, configuration) :: (index, resource, vector)
| *Description* 3+a|  Generate several vector embeddings with a single API request.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `resources` | `LIST<STRING>` | The object to transform into an embedding.
| `provider` | `STRING` | The GenAI provider to use.
| `configuration` | `MAP` | The provider specific settings.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `index` | `INTEGER` | The index of the corresponding element in the input list.
| `resource` | `STRING` | The name of the input resource.
| `vector` | `ANY` | The generated vector embedding for the resource.
| *Mode* 3+| DEFAULT
|===

For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/genai-integrations/#multiple-embeddings[Cypher Manual -> Generating a batch of embeddings].

.Known issue
[NOTE]
====
Procedure signatures from `SHOW PROCEDURES` renders the vector arguments with a type of `ANY` rather than the semantically correct type of `LIST<INTEGER | FLOAT>`.
The types are still enforced as `LIST<INTEGER | FLOAT>`.
====

[role=label--new-5.19]
[[procedure_genai_vector_listEncodingProviders]]
=== genai.vector.listEncodingProviders()


.Details
|===
| *Syntax* 3+m| genai.vector.listEncodingProviders() :: (name, requiredConfigType, otionalConfigType, defaultConfig)
| *Description* 3+a| List the available GenAI providers.
.5+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The name of the GenAI provider.
| `requiredConfigType` | `STRING` | The signature of the required config map.
| `optionalConfigType` | `STRING` | The signature of the optional config map.
| `defaultConfig` | `MAP` | The default values for the GenAI provider.
| *Mode* 3+| DEFAULT
|===


== Index management

For more information, see:

* xref:performance/index-configuration.adoc[]
* link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes/search-performance-indexes/overview/[Cypher Manual -> Search performance indexes]
* link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/indexes/semantic-indexes/full-text-indexes[Cypher Manual -> Full-text indexes]

[[procedure_db_awaitindex]]
=== db.awaitIndex()


.Details
|===
| *Syntax* 3+m| db.awaitIndex(indexName [, timeOutSeconds ])
| *Description* 3+a| Wait for an index to come online (for example: CALL db.awaitIndex("MyIndex", 300)).
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the awaited index.
| `timeOutSeconds` | `INTEGER` | The maximum time to wait.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_awaitIndexes]]
=== db.awaitIndexes()


.Details
|===
| *Syntax* 3+m| db.awaitIndexes([ timeOutSeconds ])
| *Description* 3+a| Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)).
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `timeOutSeconds` | `INTEGER` | The maximum time to wait.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


[[procedure_db_index_fulltext_awaiteventuallyconsistentindexrefresh]]
=== db.index.fulltext.waitEventuallyConsistentIndexRefresh()


.Details
|===
| *Syntax* 3+m| db.index.fulltext.awaitEventuallyConsistentIndexRefresh()
| *Description* 3+a| Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.
| *Mode* 3+| READ
|===

[[procedure_db_index_fulltext_listavailableanalyzers]]
=== db.index.fulltext.listAvailableAnalyzers()


.Details
|===
| *Syntax* 3+m| db.index.fulltext.listAvailableAnalyzers() :: (analyzer, description, stopwords)
| *Description* 3+a| List the available analyzers that the full-text indexes can be configured with.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `analyzer` | `STRING` | The name of the analyzer.
| `description` | `STRING` | The  description of the analyzer.
| `stopwords` | `LIST<STRING>` | The stopwords used by the analyzer to tokenize strings.
| *Mode* 3+| READ
|===


[[procedure_db_index_fulltext_querynodes]]
=== db.index.fulltext.queryNodes()


.Details
|===
| *Syntax* 3+m| db.index.fulltext.queryNodes(indexName, queryString [, options ]) :: (node, score)
| *Description* 3+a| Query the given full-text index. Returns the matching nodes and their Lucene query score, ordered by score.
Valid _key: value_ pairs for the `options` map are:

* 'skip' -- to skip the top N results.
* 'limit' -- to limit the number of results returned.
* 'analyzer' -- to use the specified analyzer as a search analyzer for this query.

The `options` map and any of the keys are optional.
An example of the `options` map: `{skip: 30, limit: 10, analyzer: 'whitespace'}`

.4+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the fulltext index.
| `queryString` | `STRING` | The string to find approximate matches for.
| `options` | `MAP` | {skip :: INTEGER, limit :: INTEGER, analyzer :: STRING}
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | A node which contains a property similar to the query string.
| `score` | `FLOAT` | The score measuring how similar the node property is to the query string.
| *Mode* 3+| READ
|===

[[procedure_db_index_fulltext_queryRelationships]]
=== db.index.fulltext.queryRelationships()


.Details
|===
| *Syntax* 3+m| db.index.fulltext.queryRelationships(indexName, queryString [, options ]) :: (relationship, score)
| *Description* 3+a| Query the given full-text index. Returns the matching relationships and their Lucene query score, ordered by score.
Valid _key: value_ pairs for the `options` map are:

* 'skip' -- to skip the top N results.
* 'limit' -- to limit the number of results returned.
* 'analyzer' -- to use the specified analyzer as a search analyzer for this query.

The `options` map and any of the keys are optional.
An example of the `options` map: `{skip: 30, limit: 10, analyzer: 'whitespace'}`

.4+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the fulltext index.
| `queryString` | `STRING` | The string to find approximate matches for.
| `options` | `MAP` | {skip :: INTEGER, limit :: INTEGER, analyzer :: STRING}
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `relationship` | `RELATIONSHIP` | A relationship which contains a property similar to the query string.
| `score` | `FLOAT` | The score measuring how similar the node property is to the query string.
| *Mode* 3+| READ
|===


[[procedure_db_resampleindex]]
=== db.resampleIndex()


.Details
|===
| *Syntax* 3+m| db.resampleIndex(indexName)
| *Description* 3+a| Schedule resampling of an index (for example: CALL db.resampleIndex("MyIndex")).
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the index.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


[[procedure_db_resampleoutdatedindexes]]
=== db.resampleOutdatedIndexes()


.Details
|===
| *Syntax* 3+m| db.resampleOutdatedIndexes()
| *Description* 3+a| Schedule resampling of all outdated indexes.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== Metrics

[[procedure_dbms_queryjmx]]
=== dbms.queryJmx()


.Details
|===
| *Syntax* 3+m| dbms.queryJmx(query) :: (name, description, attributes)
| *Description* 3+a| Query JMX management data by domain and name. For instance, use `\*:*` to find all JMX beans.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `query` | `STRING` | A query for MBeans on this MBeanServer (e.g. '\*:*,name=*neo4j*' for all metrics in neo4j database).
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The name of the metric.
| `description` | `STRING` | The description of the metric.
| `attributes` | `MAP` | A collection with the attributes (values) of that metric.
| *Mode* 3+| DBMS
|===

== Schema and metadata

[[procedure_db_schema_nodetypeproperties]]
=== db.schema.nodeTypeProperties()


.Details
|===
| *Syntax* 3+m| db.schema.nodeTypeProperties() :: (nodeType, nodeLabels, propertyName, propertyTypes, mandatory)
| *Description* 3+a| Show the derived property schema of the nodes in tabular form.
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `nodeType` | `STRING` | A name generated from the labels on the node.
| `nodeLabels` | `LIST<STRING>` | A list containing the labels on a category of node.
| `propertyName` | `STRING` | A property key on a category of node.
| `propertyTypes` | `LIST<STRING>` | All types of a property belonging to a node category.
| `mandatory` | `BOOLEAN` | Whether or not the property is present on all nodes belonging to a node category.
| *Mode* 3+| READ
|===


[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_schema_reltypeproperties]]
=== db.schema.relTypeProperties()


.Details
|===
| *Syntax* 3+m| db.schema.relTypeProperties() :: (relType, propertyName, propertyTypes, mandatory)
| *Description* 3+a| Show the derived property schema of the relationships in tabular form.
.5+| *Return arguments* | *Name* | *Type* | *Description*
| `relType` | `STRING` | A name generated from the type on the relationship.
| `propertyName` | `STRING` | A property key on a category of relationship.
| `propertyTypes` | `LIST<STRING>` | All types of a property belonging to a relationship category.
| `mandatory` | `BOOLEAN` | Whether or not the property is present on all relationships belonging to a relationship category.
| *Mode* 3+| READ
|===


[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_schema_visualization]]
=== db.schema.visualization()


.Details
|===
| *Syntax* 3+m| db.schema.visualization() :: (nodes, relationships)
| *Description* 3+a| Visualizes the schema of the data based on available statistics. A new node is returned for each label. The properties represented on the node include: `name` (label name), `indexes` (list of indexes), and `constraints` (list of constraints). A relationship of a given type is returned for all possible combinations of start and end nodes. The properties represented on the relationship include: `name` (type name). Note that this may include additional relationships that do not exist in the data due to the information available in the count store.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `nodes` | `LIST<NODE>` | A list of virtual nodes representing each label in the database.
| `relationships` | `LIST<RELATIONSHIP>` | A list of virtual relationships representing all combinations between start and end nodes in the database.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_createlabel]]
=== db.createLabel()


.Details
|===
| *Syntax* 3+m| db.createLabel(newLabel)
| *Description* 3+a| Create a label
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `newLabel` | `STRING` | A new label.
| *Mode* 3+| WRITE
|===

[[procedure_db_createproperty]]
=== db.createProperty()


.Details
|===
| *Syntax* 3+m| db.createProperty(newProperty)
| *Description* 3+a| Create a Property
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `newProperty` | `STRING` | A new property.
| *Mode* 3+| WRITE
|===

[[procedure_db_createRelationshiptype]]
=== db.createRelationshipType


.Details
|===
| *Syntax* 3+m| db.createRelationshipType(newRelationshipType)
| *Description* 3+a| Create a RelationshipType
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `newRelationshipType` | `STRING` | A new relationship type.
| *Mode* 3+| WRITE
|===

[[procedure_db_labels]]
=== db.labels()


.Details
|===
| *Syntax* 3+m| db.labels() :: (label)
| *Description* 3+a| List all labels attached to nodes within a database according to the user's access rights. The procedure returns empty results if the user is not authorized to view those labels.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `label` | `STRING` | A label within the database.
| *Mode* 3+| READ
|===


[[procedure_db_propertykeys]]
=== db.propertyKeys()


.Details
|===
| *Syntax* 3+m| db.propertyKeys() :: (propertyKey)
| *Description* 3+a| List all property keys in the database.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `propertyKey` | `STRING` | A property key in the database.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_relationshiptypes]]
=== db.relationshipTypes()


.Details
|===
| *Syntax* 3+m| db.relationshipTypes() :: (relationshipType)
| *Description* 3+a| List all types attached to relationships within a database according to the user's access rights. The procedure returns empty results if the user is not authorized to view those relationship types.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `relationshipType` | `STRING` | A relationship type in the database.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== Statistics and query planning

For more information, see xref:performance/statistics-execution-plans.adoc[]

[role=label--admin-only]
[[procedure_db_clearyquerycaches]]
=== db.clearQueryCaches()


.Details
|===
| *Syntax* 3+m| db.clearQueryCaches() :: (value)
| *Description* 3+a| Clears all query caches.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `value` | `STRING` | The number of cleared query caches.
| *Mode* 3+| DBMS
|===

[role=label--admin-only]
[[procedure_db_prepareforreplanning]]
=== db.prepareForReplanning()


.Details
|===
| *Syntax* 3+m| db.prepareForReplanning([ timeOutSeconds ])
| *Description* 3+a| Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `timeOutSeconds` | `INTEGER` | The maximum time to wait.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime (introduced in Neo4j 5.13).
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/{page-version}/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[role=label--admin-only]
[[procedure_db_stats_clear]]
=== db.stats.clear


.Details
|===
| *Syntax* 3+m| db.stats.clear(section) :: (section, success, message)
| *Description* 3+a| Clear collected data of a given data section. Valid sections are 'QUERIES'
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | Specify 'QUERIES'.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section cleared.
| `success` | `BOOLEAN` | Whether the section was successfully cleared.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| READ
|===

[role=label--admin-only]
[[procedure_db_stats_collect]]
=== db.stats.collect()


.Details
|===
| *Syntax* 3+m| db.stats.collect(section [, config ]) :: (section, success, message)
| *Description* 3+a| Start data collection of a given data section. Valid sections are 'QUERIES'
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | Specify 'QUERIES'.
| `config` | `MAP` | A map containing a single key `durationSeconds` (default value of -1).
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section collected.
| `success` | `BOOLEAN` | Whether the section was successfully collected.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| READ
|===

[role=label--admin-only]
[[procedure_db_stats_retrieve]]
=== db.stats.retrieve()


.Details
|===
| *Syntax* 3+m| db.stats.retrieve(section [, config ]) :: (section, data)
| *Description* 3+a| Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META'
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | A section of stats to retrieve: ('GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META').
| `config` | `MAP` | A map containing a single key `maxInvocations` (default value of 100).
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section retrieved.
| `data` | `MAP` | Data pertaining to the retrieved statistics.
| *Mode* 3+| READ
|===

[role=label--admin-only]
[[procedure_db_stats_retrieveallanonymized]]
=== db.stats.retrieveAllAnonymized()


.Details
|===
| *Syntax* 3+m| db.stats.retrieveAllAnonymized(graphToken [, config ]) :: (section, data)
| *Description* 3+a| Retrieve all available statistical data about the current database, in an anonymized form.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `graphToken` | `STRING` | The name of the graph token.
| `config` | `MAP` | A map containing a single key `maxInvocations` (default value of 100).
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section retrieved.
| `data` | `MAP` | Data pertaining to the retrieved statistics.
| *Mode* 3+| READ
|===


[role=label--admin-only]
[[procedure_db_stats_status]]
=== db.stats.status()


.Details
|===
| *Syntax* 3+m| db.stats.status() :: (section, status, data)
| *Description* 3+a| Retrieve the status of all available collector daemons, for this database.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | String with the message "QUERIES".
| `status` | `STRING` | The status of the QueryCollector: "idle" or "collecting".
| `data` | `MAP` | data :: MAP
| *Mode* 3+| READ
|===


[role=label--admin-only]
[[procedure_db_stats_stop]]
=== db.stats.stop()


.Details
|===
| *Syntax* 3+m| db.stats.stop(section) :: (section, success, message)
| *Description* 3+a| Stop data collection of a given data section. Valid sections are 'QUERIES'
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | Specify 'QUERIES'.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The stopped section.
| `success` | `BOOLEAN` | Whether the section was successfully stopped.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| READ
|===


== Transaction management

[[procedure_tx_getmetadata]]
=== tx.getMetaData()


.Details
|===
| *Syntax* 3+m| tx.getMetaData() :: (metadata)
| *Description* 3+a| Provides attached transaction metadata.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `metadata` | `MAP` | Metadata about the transaction.
| *Mode* 3+| DBMS
|===


[[procedure_tx_setmetadata]]
=== tx.setMetaData()


.Details
|===
| *Syntax* 3+m| tx.setMetaData(data)
| *Description* 3+a| Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `data` | `MAP` | Metadata to attach to the transaction.
| *Mode* 3+| DBMS
|===


[[deprecated-procedures]]
== List of deprecated procedures

Neo4j 5 contains several deprecated procedures.
These procedures have been replaced either by Cypher commands or different procedures.
The procedures deprecated in Neo4j 5 will be removed in the next major release of Neo4j.

.See all deprecated procedures
[%collapsible]
====
[options=header, cols="3m,1,1,3"]
|===
| Name
| Community Edition
| Enterprise Edition
| Comment

| xref:procedures.adoc#procedure_cdc_current[`cdc.current()`]
| label:no[]
| label:yes[]
| label:new[Introduced in 5.13] label:beta[] label:deprecated[Deprecated in 5.17]
Replaced by: xref:procedures.adoc#procedure_db_cdc_current[`db.cdc.current()`]

| xref:procedures.adoc#procedure_cdc_earliest[`cdc.earliest()`]
| label:no[]
| label:yes[]
| label:new[Introduced in 5.13] label:beta[] label:deprecated[Deprecated in 5.17]
Replaced by: xref:procedures.adoc#procedure_db_cdc_earliest[`db.cdc.earliest()`]

| xref:procedures.adoc#procedure_cdc_query[`cdc.query()`]
| label:no[]
| label:yes[]
| label:new[Introduced in 5.13] label:beta[] label:admin-only[] label:deprecated[Deprecated in 5.17]
Replaced by: xref:procedures.adoc#procedure_db_cdc_query[`db.cdc.query()`]

| xref:procedures.adoc#procedure_db_create_setVectorProperty[`db.create.setVectorProperty()`]
| label:yes[]
| label:yes[]
| label:new[Introduced in 5.11] label:beta[] label:deprecated[Deprecated in 5.13] Replaced by: xref:procedures.adoc#procedure_db_create_setNodeVectorProperty[`db.create.setNodeVectorProperty()`]

// New in 4.2
// com.neo4j.causaulclustering.discovery.procedures.ReadReplicaToggleProcedure
| xref:procedures.adoc#procedure_dbms_cluster_readreplicatoggle[`dbms.cluster.readReplicaToggle()`]
| label:no[]
| label:yes[]
| label:admin-only[] label:deprecated[Deprecated in 5.6]. +
Replaced by: xref:procedures.adoc#procedure_dbms_cluster_secondaryreplicationdisable[`dbms.cluster.secondaryReplicationDisable()`].

| xref:procedures.adoc#procedure_dbms_cluster_routing_getroutingtable[`dbms.cluster.routing.getRoutingTable()`]
| label:yes[]
| label:yes[]
| label:deprecated[Deprecated in 5.21]. +
Replaced by: xref:procedures.adoc#procedure_dbms_routing_getroutingtable[`dbms.routing.getRoutingTable()`].

| xref:procedures.adoc#procedure_dbms_cluster_uncordonServer[`dbms.cluster.uncordonServer()`]
| label:no[]
| label:yes[]
| label:deprecated[Deprecated in 5.23]. +
Before Neo4j 5.23, the procedure can be run only with the `Admin` privileges. +
Replaced by xref:clustering/server-syntax.adoc#server-management-syntax[`ENABLE SERVER`].

| xref:procedures.adoc#procedure_dbms_setDatabaseAllocator[`dbms.setDatabaseAllocator()`]
| label:no[]
| label:yes[]
| label:admin-only[] label:deprecated[Deprecated in 5.23]

// New in 4.1
| xref:procedures.adoc#procedure_dbms_upgrade[`dbms.upgrade()`]
| label:yes[]
| label:yes[]
| label:admin-only[] label:deprecated[Deprecated in 5.9]

// New in 4.1
| xref:procedures.adoc#procedure_dbms_upgradestatus[`dbms.upgradeStatus()`]
| label:yes[]
| label:yes[]
| label:admin-only[] label:deprecated[Deprecated in 5.9]

|===

====

[[removed-procedures]]
== List of removed procedures

Several procedures were removed with the release of Neo4j.
They were functionally replaced by Cypher commands or different procedures.

.See all procedures removed in Neo4j 5.0 and their replacements
[%collapsible]
====

[options=header,cols="3m,1,1,3"]
|===
| Name
| Community Edition
| Enterprise Edition
| Replaced by

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_constraints[`db.constraints()`]
| label:yes[]
| label:yes[]
| `SHOW CONSTRAINTS`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_createindex[`db.createIndex()`]
| label:yes[]
| label:yes[]
| `CREATE INDEX`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_createnodekey[`db.createNodeKey()`]
| label:no[]
| label:yes[]
| `CREATE CONSTRAINT ... IS NODE KEY`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_createuniquepropertyconstraint[`db.createUniquePropertyConstraint()`]
| label:yes[]
| label:yes[]
| `CREATE CONSTRAINT ... IS UNIQUE`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_indexes[`db.indexes()`]
| label:yes[]
| label:yes[]
| `SHOW INDEXES`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_indexdetails[`db.indexDetails()`]
| label:yes[]
| label:yes[]
| `SHOW INDEXES YIELD*`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_index_fulltext_createnodeindex[`db.index.fulltext.createNodeIndex()`]
| label:yes[]
| label:yes[]
| `CREATE FULLTEXT INDEX ...`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_index_fulltext_createrelationshipindex[`db.index.fulltext.createRelationshipIndex()`]
| label:yes[]
| label:yes[]
| `CREATE FULLTEXT INDEX ...`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_index_fulltext_drop[`db.index.fulltext.drop()`]
| label:yes[]
| label:yes[]
| `DROP INDEX ...`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_db_schemastatements[`db.schemaStatements()`]
| label:yes[]
| label:yes[]
| `SHOW INDEXES YIELD *` and `SHOW CONSTRAINTS YIELD *`

// New in 4.0
// com.neo4j.causaulclustering.discovery.procedures.ClusterOverviewProcedure
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_cluster_overview[`dbms.cluster.overview()`]
| label:no[]
| label:yes[]
| `SHOW SERVERS`


// New in 4.2
// com.neo4j.dbms.procedures.QuarantineProcedure
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_cluster_quarantinedatabase[`dbms.cluster.quarantineDatabase()`]
| label:no[]
| label:yes[]
| `dbms.quarantineDatabase()`


// New in 4.0
// Removed in 5.0
// com.neo4j.causaulclustering.discovery.procedures.RoleProcedure
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_cluster_role[`dbms.cluster.role()`]
| label:no[]
| label:yes[]
| `SHOW DATABASES`

// New in 4.1
// Removed in 5.0
// com.neo4j.dbms.procedures.ClusterSetDefaultDatabaseProcedure
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_cluster_setdefaultdatabase[`dbms.cluster.setDefaultDatabase()`]
| label:no[]
| label:yes[]
| `dbms.setDefaultDatabase`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_database_state[`dbms.database.state()`]
| label:yes[]
| label:yes[]
| `SHOW DATABASES`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_functions[`dbms.functions()`]
| label:yes[]
| label:yes[]
| `SHOW FUNCTIONS`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_killqueries[`dbms.killQueries()`]
| label:yes[]
| label:yes[]
| `TERMINATE TRANSACTIONS`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_killquery[`dbms.killQuery()`]
| label:yes[]
| label:yes[]
| `TERMINATE TRANSACTIONS`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_killtransaction[`dbms.killTransaction()`]
| label:yes[]
| label:yes[]
| `TERMINATE TRANSACTIONS`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_killtransactions[`dbms.killTransactions()`]
| label:yes[]
| label:yes[]
| `TERMINATE TRANSACTIONS`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_listqueries[`dbms.listQueries()`]
| label:yes[]
| label:yes[]
| `SHOW TRANSACTIONS`

| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_listtransactions[`dbms.listTransactions()`]
| label:yes[]
| label:yes[]
| `SHOW TRANSACTIONS`


| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_procedures[`dbms.procedures()`]
| label:no[]
| label:yes[]
| `SHOW PROCEDURES`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_activateuser[`dbms.security.activateUser()`]
| label:no[]
| label:yes[]
| `ALTER USER`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_addroletouser[`dbms.security.addRoleToUser()`]
| label:no[]
| label:yes[]
| `GRANT ROLE TO USER`

// Removed in 5.0
// newSet( READER, EDITOR, PUBLISHER, ARCHITECT, ADMIN )
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_changepassword[`dbms.security.changePassword()`]
| label:yes[]
| label:yes[]
| `ALTER CURRENT USER SET PASSWORD`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_changeuserpassword[`dbms.security.changeUserPassword()`]
| label:no[]
| label:yes[]
| `ALTER USER`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_createrole[`dbms.security.createRole()`]
| label:no[]
| label:yes[]
| `CREATE ROLE`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_createuser[`dbms.security.createUser()`]
| label:yes[]
| label:yes[]
| `CREATE USER`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_deleterole[`dbms.security.deleteRole()`]
| label:no[]
| label:yes[]
| `DROP ROLE`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_deleteuser[`dbms.security.deleteUser()`]
| label:yes[]
| label:yes[]
| `DROP USER`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_listroles[`dbms.security.listRoles()`]
| label:yes[]
| label:yes[]
| `SHOW ROLES`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_listrolesforuser[`dbms.security.listRolesForUser()`]
| label:no[]
| label:yes[]
| `SHOW USERS`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_listusers[`dbms.security.listUsers()`]
| label:yes[]
| label:yes[]
| `SHOW USERS`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_listusersforrole[`dbms.security.listUsersForRole()`]
| label:no[]
| label:yes[]
| `SHOW ROLES WITH USERS`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_removerolefromuser[`dbms.security.removeRoleFromUser()`]
| label:no[]
| label:yes[]
| `REVOKE ROLE FROM USER`

// Removed in 5.0
| link:{neo4j-docs-base-uri}/operations-manual/4.4/reference/#procedure_dbms_security_suspenduser[`dbms.security.suspendUser()`]
| label:no[]
| label:yes[]
| `ALTER USER`

|===

====

