= Procedures
:description: This page provides a complete reference to the Neo4j procedures.
:table-caption!:
:table-stripes: hover
:table-frame: topbot

:stem:
:mathjax-tex-packages: ams

This page provides a complete reference to Neo4j's built-in procedures.
// The procedures are grouped into the following categories:


// * <<#_authentication_and_authorization,Authentication and authorization>>
// * <<#_background_job_management,Background job management>>
// * <<#_change_data_capture_cdc,Change Data Capture (CDC)>>
// * <<#_cluster_management,Cluster management>>
// * <<#_configuration_and_dbms_info,Configuration and DBMS info>>
// * <<#_connection_management,Connection management>>
// * <<#_database_management,Database management>>
// * <<#_genai_and_vectors, GenAI and vectors>>
// * <<#_index_management,Index management>>
// * <<#_metrics, Metrics>>
// * <<#_schema_and_metadata,Schema and metadata>>
// * <<#_statistics_and_query_planning,Statistics and query planning>>
// * <<#_transaction_management,Transaction management>>

For lists of deprecated and removed procedures, refer to the page xref:changes-deprecations-removals.adoc[Changes, deprecations, and removals in Neo4j 2025.x].

The available procedures on a server depends on several factors:

* Neo4j Enterprise Edition provides a larger set of procedures than Neo4j Community Edition.
* Neo4j's link:{neo4j-docs-base-uri}/apoc/{page-version}/[APOC Core library] and link:{neo4j-docs-base-uri}/cypher-manual/5/genai-integrations/[GenAI plugin] are installed by default on link:{neo4j-docs-base-uri}/aura/[Aura] instances, but have to be installed separately on on-prem servers.
* Cluster members have procedures that are not available in standalone mode.

To check which procedures are available in your Neo4j DBMS, use the Cypher command link:{neo4j-docs-base-uri}/cypher-manual/5/clauses/listing-procedures[`SHOW PROCEDURES`]:

.List available procedures with default output columns
[source, cypher]
----
SHOW PROCEDURES
----

.List available procedures with full output columns
[source, cypher]
----
SHOW PROCEDURES YIELD *
----


[NOTE]
====
Some procedures can only be run by users with `Admin` privileges.
Specifically, either the `EXECUTE ADMIN PROCEDURES` privilege or both the `EXECUTE PROCEDURES` and `EXECUTE BOOSTED PROCEDURES` privileges.
These procedures are labeled with label:admin-only[].

For more information, see xref:authentication-authorization/dbms-administration.adoc#access-control-dbms-administration-execute[the `EXECUTE` privileges section].
====

== Authentication and authorization

For more information, see xref:authentication-authorization/index.adoc[Authentication and authorization].

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_security_clearauthcache]]
=== dbms.security.clearAuthCache()


.Details
|===
| *Syntax* 3+m| dbms.security.clearAuthCache()
| *Description* 3+a| Clears authentication and authorization cache.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition label--admin-only label--new-2025.03]
[[procedure_dbms_security_reloadTLS]]
=== dbms.security.reloadTLS()


.Details
|===
| *Syntax* 3+m| dbms.security.reloadTLS()
| *Description* 3+a| Trigger the dynamic reloading of all TLS certificates and configuration.
| *Mode* 3+| DBMS
|===


[[procedure_dbms_showCurrentUser]]
=== dbms.showCurrentUser()


.Details
|===
| *Syntax* 3+m| dbms.showCurrentUser() :: (username, roles, flags)
| *Description* 3+a| Show the current user.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `username` | `STRING` | The name of the current user.
| `roles` | `LIST<STRING>` | The roles assigned to the current user.
| `flags` | `LIST<STRING>` | The flags set on the current user.
| *Mode* 3+| DBMS
|===


== Background job management

For more information, see xref:monitoring/background-jobs.adoc[].

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_scheduler_failedJobs]]
=== dbms.scheduler.failedJobs()


.Details
|===
| *Syntax* 3+m| dbms.scheduler.failedJobs() :: (jobId, group, database, submitter, description, type, submitted, executionStart, failureTime, failureDescription)
| *Description* 3+a| List failed job runs. There is a limit for amount of historical data.
.11+| *Return arguments* | *Name* | *Type* | *Description*
| `jobId` | `STRING` | The id of the failed job.
| `group` | `STRING` | The category of the failed job.
| `database` | `STRING` | The name of the database the job failed in.
| `submitter` | `STRING` | The creator of the failed job.
| `description` | `STRING` | Information about the failed job.
| `type` | `STRING` | The interval of the failed job.
| `submitted` | `STRING` | The submission time of the failed job.
| `executionStart` | `STRING` | The start time of the failed job.
| `failureTime` | `STRING` | The failure time of the failed job.
| `failureDescription` | `STRING` | Information about the job failure.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_scheduler_groups]]
=== dbms.scheduler.groups()


.Details
|===
| *Syntax* 3+m| dbms.scheduler.groups() :: (group, threads)
| *Description* 3+a| List the job groups that are active in the database internal job scheduler.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `group` | `STRING` | The name of the job group.
| `threads` | `INTEGER` | The number of active threads in that job group.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_scheduler_jobs]]
=== dbms.scheduler.jobs()


.Details
|===
| *Syntax* 3+m| dbms.scheduler.jobs() :: (jobId, group, submitted, database, submitter, description, type, scheduledAt, period, state, currentStateDescription)
| *Description* 3+a| List all jobs that are active in the database internal job scheduler.
.12+| *Return arguments* | *Name* | *Type* | *Description*
| `jobId` | `STRING` | The id of the job.
| `group` | `STRING` | The category of the job.
| `submitted` | `STRING` | The submission time of the job.
| `database` | `STRING` | The name of the database the job is in.
| `submitter` | `STRING` | The creator of the job.
| `description` | `STRING` | Information about the job.
| `type` | `STRING` | The interval of the job.
| `scheduledAt` | `STRING` | The start time of the job.
| `period` | `STRING` | The interval for jobs run periodically.
| `state` | `STRING` | The state of the job: ('EXECUTING', 'SCHEDULED').
| `currentStateDescription` | `STRING` | A description of the job state.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


== Change Data Capture (CDC)

For more information, see the link:{neo4j-docs-base-uri}/cdc/current/[CDC documentation].

[role=label--enterprise-edition label--deprecated-5.17]
[[procedure_cdc_current]]
=== cdc.current()


.Details
|===
| *Syntax* 3+m| cdc.current() :: (id)
| *Description* 3+a| Returns the current change identifier that can be used to stream changes from.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
| *Replaced by* 3+| xref:procedures.adoc#procedure_db_cdc_current[`db.cdc.current()`]
|===

[role=label--enterprise-edition label--deprecated-5.17]
[[procedure_cdc_earliest]]
=== cdc.earliest()


.Details
|===
| *Syntax* 3+m| cdc.earliest() :: (id)
| *Description* 3+a| Returns the earliest change identifier that can be used to stream changes from.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
| *Replaced by* 3+| xref:procedures.adoc#procedure_db_cdc_earliest[`db.cdc.earliest()`]
|===

[role=label--enterprise-edition label--deprecated-5.17 label--admin-only]
[[procedure_cdc_query]]
=== cdc.query()


.Details
|===
| *Syntax* 3+m| cdc.query([ from selectors ]) :: (id, txId, seq, metadata, event)
| *Description* 3+a| Query changes happened from the provided change identifier.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `from` | `STRING` | The change identifier to query changes from.
| `selectors` | `LIST<MAP>` | An optional list of selectors to filter out changes.
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier for this change event. Used to continue querying from this change event.
| `txId` | `INTEGER` | A number identifying which transaction the change happened in, unique in combination with seq.
| `seq` | `INTEGER` | A number used for ordering changes that happened in the same transaction.
| `metadata` | `MAP` | Metadata from the transaction that caused this change event.
| `event` | `MAP` | The retrieved changes on the affected entity.
| *Mode* 3+| READ
| *Replaced by* 3+| xref:procedures.adoc#procedure_db_cdc_query[`db.cdc.query()`]
|===


[role=label--enterprise-edition]
[[procedure_db_cdc_current]]
=== db.cdc.current()


.Details
|===
| *Syntax* 3+m| db.cdc.current() :: (id)
| *Description* 3+a| Returns the current change identifier that can be used to stream changes from.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
|===


[role=label--enterprise-edition]
[[procedure_db_cdc_earliest]]
=== db.cdc.earliest()


.Details
|===
| *Syntax* 3+m| db.cdc.earliest() :: (id)
| *Description* 3+a| Returns the earliest change identifier that can be used to stream changes from.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
|===

[role=label--admin-only label--enterprise-edition]
[[procedure_db_cdc_query]]
=== db.cdc.query()


.Details
|===
| *Syntax* 3+m| db.cdc.query([ from selectors ]) :: (id, txId, seq, metadata, event)
| *Description* 3+a| Query changes happened from the provided change identifier.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `from` | `STRING` | The change identifier to query changes from.
| `selectors` | `LIST<MAP>` | An optional list of selectors to filter out changes.
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier for this change event. Used to continue querying from this change event.
| `txId` | `INTEGER` | A number identifying which transaction the change happened in, unique in combination with seq.
| `seq` | `INTEGER` | A number used for ordering changes that happened in the same transaction.
| `metadata` | `MAP` | Metadata from the transaction that caused this change event.
| `event` | `MAP` | The retrieved changes on the affected entity.
| *Mode* 3+| READ
|===


[role=label--admin-only label--enterprise-edition label--new-2025.04]
[[procedure_db_cdc_translateId]]
=== db.cdc.translateId()


.Details
|===
| *Syntax* 3+m| db.cdc.translateId(from :: STRING) :: (id :: STRING)
| *Description* 3+a| Translate any provided change identifier to match the queried database.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `from` | `STRING` | The change identifier to translate.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The change identifier.
| *Mode* 3+| READ
|===



== Cluster management

For more information, see xref:clustering/index.adoc[].

[role=label--admin-only label--enterprise-edition]
[[procedure_dbms_cluster_checkConnectivity]]
=== dbms.cluster.checkConnectivity()


.Details
|===
| *Syntax* 3+m| dbms.cluster.checkConnectivity([ port-name server ]) :: (serverId, name, address, mode-constraint, port-name, port-address, result)
| *Description* 3+a| Check the connectivity of this instance to other cluster members. Not all ports are relevant to all members. Valid values for 'port-name' are: [CLUSTER, INTRA_BOLT, RAFT]
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `port-name` | `STRING` | The name of the port: ('CLUSTER', 'RAFT').
| `server` | `STRING` | The id of the server to check connectivity of.
.8+| *Return arguments* | *Name* | *Type* | *Description*
| `serverId` | `STRING` | The id of the checked server.
| `name` | `STRING` | name :: STRING
| `address` | `STRING` | address :: STRING
| `mode-constraint` | `STRING` | The instance mode constraint of the server.
| `port-name` | `STRING` | The name of the checked port.
| `port-address` | `STRING` | The address of the checked port.
| `result` | `STRING` | Whether the check was successful or not.
| *Mode* 3+| DBMS
|===


[role=label--enterprise-edition]
[[procedure_dbms_cluster_cordonServer]]
=== dbms.cluster.cordonServer()


.Details
|===
| *Syntax* 3+m| dbms.cluster.cordonServer(server)
| *Description* 3+a| Mark a server in the topology as not suitable for new allocations. It will not force current allocations off the server. This is useful when deallocating databases when you have multiple unavailable servers.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The name or id of the server to be cordoned.
| *Mode* 3+| WRITE
|*Required privileges* 3+| `SERVER MANAGEMENT`
|===

[NOTE]
====
Running the procedure with an admin privilege is deprecated.
====


[role=label--enterprise-edition]
[[procedure_dbms_cluster_deallocateDatabaseFromServer]]
=== dbms.cluster.deallocateDatabaseFromServer()


.Details
|===
| *Syntax* 3+m| dbms.cluster.deallocateDatabaseFromServer(server, database [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Deallocate a specific user database from a specific server.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The id of the server to deallocate from.
| `database` | `STRING` | The name of the database to deallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required privileges* 3+| `SERVER MANAGEMENT`
|===


[role=label--enterprise-edition]
[[procedure_dbms_cluster_deallocateDatabaseFromServers]]
=== dbms.cluster.deallocateDatabaseFromServers()


.Details
|===
| *Syntax* 3+m| dbms.cluster.deallocateDatabaseFromServers(servers, database [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Deallocate a specific user database from a list of servers.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `servers` | `LIST<STRING>` | The ids of the servers to deallocate from.
| `database` | `STRING` | The id of the database to deallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required privileges* 3+| `SERVER MANAGEMENT`
|===


[role=label--enterprise-edition]
[[procedure_dbms_cluster_deallocateNumberOfDatabases]]
=== dbms.cluster.deallocateNumberOfDatabases()


.Details
|===
| *Syntax* 3+m| dbms.cluster.deallocateNumberOfDatabases(server, number [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Deallocate a number of user databases from a specific server.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The id of the server to deallocate from.
| `number` | `INTEGER` | The number of databases to deallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required privileges* 3+| `SERVER MANAGEMENT`
|===


[role=label--enterprise-edition]
[[procedure_dbms_cluster_protocols]]
=== dbms.cluster.protocols()


.Details
|===
| *Syntax* 3+m| dbms.cluster.protocols() :: (orientation, remoteAddress, applicationProtocol, applicationProtocolVersion, modifierProtocols)
| *Description* 3+a| Overview of installed protocols
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `orientation` | `STRING` | Direction of the protocol (inbound or outbound).
| `remoteAddress` | `STRING` | The socket address this protocol is available on.
| `applicationProtocol` | `STRING` | The name of the protocol.
| `applicationProtocolVersion` | `INTEGER` | The version of the protocol.
| `modifierProtocols` | `STRING` | Installed modifier protocols, for example, compression.
| *Mode* 3+| DBMS
|===

[role=label--admin-only label--deprecated-5.6 label--enterprise-edition label--removed-cypher-25]
[[procedure_dbms_cluster_readReplicaToggle]]
=== dbms.cluster.readReplicaToggle()


.Details
|===
| *Syntax* 3+m| dbms.cluster.readReplicaToggle(databaseName, pause) :: (state)
| *Description* 3+a| The toggle can pause or resume read replica (deprecated in favor of dbms.cluster.secondaryReplicationDisable)
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database to toggle the secondary replication process for.
| `pause` | `BOOLEAN` | Whether or not to enable/disable the secondary replication process.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `state` | `STRING` | The current state of the secondary replication process.
| *Mode* 3+| DBMS
|===


[TIP]
====
_What is it for?_

You can perform a point-in-time backup, as the backup will contain only the transactions up to the point where the transaction pulling was paused.
Follow these steps to do so:

. Connect directly to the server hosting the database in secondary mode. (Neo4j Driver use `bolt://` or use the HTTP API).
. Pause transaction pulling for the specified database.
. Back up the database, see xref:backup-restore/online-backup.adoc[Back up an online database].

If connected directly to a server hosting a database in secondary mode, Data Scientists can execute analysis on a specific database that is paused, the data will not unexpectedly change while performing the analysis.
====

[NOTE]
====
This procedure can only be executed on a database that runs in a secondary role on the connected server.
====


.Pause transaction pulling for database `neo4j`
[source, cypher, role="noheader"]
----
CALL dbms.cluster.readReplicaToggle("neo4j", true)
----


.Resume transaction pulling for database `neo4j`
[source, cypher, role="noheader"]
----
CALL dbms.cluster.readReplicaToggle("neo4j", false)
----


[role=label--enterprise-edition]
[[procedure_dbms_cluster_reallocateDatabase]]
=== dbms.cluster.reallocateDatabase()


.Details
|===
| *Syntax* 3+m| dbms.cluster.reallocateDatabase(database [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Reallocate a specific database.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database to reallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required privileges* 3+| `SERVER MANAGEMENT`
|===


[role=label--enterprise-edition]
[[procedure_dbms_cluster_reallocateNumberOfDatabases]]
=== dbms.cluster.reallocateNumberOfDatabases()

.Details
|===
| *Syntax* 3+m| dbms.cluster.reallocateNumberOfDatabases(number [, dryrun ]) :: (database, fromServerName, fromServerId, toServerName, toServerId, mode)
| *Description* 3+a| Reallocate a specified number of user databases.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `number` | `INTEGER` | The number of databases to reallocate.
| `dryrun` | `BOOLEAN` | Set to `true` to dry run the procedure.
.7+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database.
| `fromServerName` | `STRING` | The name of the server.
| `fromServerId` | `STRING` | The id of the server.
| `toServerName` | `STRING` | The name of the server.
| `toServerId` | `STRING` | The id of the server.
| `mode` | `STRING` | The mode in which the database is hosted.
| *Mode* 3+| WRITE
| *Required privileges* 3+| `SERVER MANAGEMENT`
|===


[role=label--deprecated-2025.04 label--enterprise-edition]
[[procedure_dbms_cluster_recreateDatabase]]
=== dbms.cluster.recreateDatabase()

.Details
|===
| *Syntax* 3+m| dbms.cluster.recreateDatabase(database :: STRING, options = {} :: MAP)
| *Description* 3+a| Recreates a database while keeping all RBAC settings.
The procedure initiates a process, which when complete, will have synchronized and started all database instances within the cluster.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database to recreate.
| `options` | `MAP` | The seeding and topology options to use for recreating the database.
| *Mode* 3+| WRITE
|===

[NOTE]
====
It is mandatory to specify either `seedURI` or `seedingServers` as seeding options in the `options` field.

If no topology option is defined, the database will be recreated with the previous topology.

Further details on how to use the `dbms.recreateDatabase()` procedure are provided in the section xref:database-administration/standard-databases/recreate-database.adoc[Database administration -> Recreate a database].
====

[role=label--deprecated-5.21 label--enterprise-edition]
[[procedure_dbms_cluster_routing_getRoutingTable]]
=== dbms.cluster.routing.getRoutingTable()


.Details
|===
| *Syntax* 3+m| dbms.cluster.routing.getRoutingTable(context [, database ]) :: (ttl, servers)
| *Description* 3+a| Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example, an endpoint may serve read queries, write queries, and/or future `getRoutingTable` requests.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `context` | `MAP` | Routing context, for example, routing policies.
| `database` | `STRING` | The database to get a routing table for.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `ttl` | `INTEGER` | Time to live (in seconds) for the routing table.
| `servers` | `LIST<MAP>` | Servers grouped by whether they are readers, writers, or routers.
| *Mode* 3+| DBMS
|===

[role=label--admin-only label--enterprise-edition]]
[[procedure_dbms_cluster_secondaryReplicationDisable]]
=== dbms.cluster.secondaryReplicationDisable()


.Details
|===
| *Syntax* 3+m| dbms.cluster.secondaryReplicationDisable(databaseName, pause) :: (state)
| *Description* 3+a| The toggle can pause or resume the secondary replication process.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database to toggle the secondary replication process for.
| `pause` | `BOOLEAN` | Whether or not to enable/disable the secondary replication process.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `state` | `STRING` | The current state of the secondary replication process.
| *Mode* 3+| DBMS
|===

[TIP]
====
_What is it for?_

You can perform a point-in-time backup, as the backup will contain only the transactions up to the point where the transaction pulling was paused.
Follow these steps to do so:

. Connect directly to the server hosting the database in secondary mode. (Neo4j Driver use `bolt://` or use the HTTP API).
. Pause transaction pulling for the specified database.
. Back up the database, see xref:backup-restore/online-backup.adoc[Back up an online database].

If connected directly to a server hosting a database in secondary mode, Data Scientists can execute analysis on a specific database that is paused, the data will not unexpectedly change while performing the analysis.
====

[NOTE]
====
This procedure can only be executed on a database that runs in a secondary role on the connected server.
====

.Pause transaction pulling for database `neo4j`
[source, cypher, role="noheader"]
----
CALL dbms.cluster.secondaryReplicationDisable("neo4j", true)
----

.Resume transaction pulling for database `neo4j`
[source, cypher, role="noheader"]
----
CALL dbms.cluster.secondaryReplicationDisable("neo4j", false)
----


[role=label--enterprise-edition]
[[procedure_dbms_cluster_setAutomaticallyEnableFreeServers]]
=== dbms.cluster.setAutomaticallyEnableFreeServers()


.Details
|===
| *Syntax* 3+m| dbms.cluster.setAutomaticallyEnableFreeServers(autoEnable)
| *Description* 3+a| With this method you can set whether free servers are automatically enabled.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `autoEnable` | `BOOLEAN` | Whether or not to automatically enable free servers.
| *Mode* 3+| WRITE
| *Required privileges* 3+| `SERVER MANAGEMENT`
|===


[NOTE]
====
Running the procedure with an admin privilege is deprecated.
====


[role=label--admin-only label--enterprise-edition]
[[procedure_dbms_cluster_statusCheck]]
=== dbms.cluster.statusCheck()

.Details
|===
| *Syntax* 3+m| dbms.cluster.statusCheck(databases, timeoutMilliseconds) :: (database, serverId, serverName, address, replicationSuccessful, memberStatus, recognisedLeader, recognisedLeaderTerm, requester, error)
| *Description* 3+a| Performs a rafted status check.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `databases` | `LIST<STRING>` | Databases for which the status check should run. Providing an empty list runs the status check for all clustered databases on that server, i.e. it does not run on singles or secondaries.
| `timeoutMilliseconds` | `INTEGER` | Specifies the maximum wait time for replication before marking it unsuccessful. Default value is 1000 milliseconds.
.11+| *Return arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The database for which a status check entry was replicated.
| `serverId` | `STRING` | The UUID of the server, which did or did not participate in a successful replication of the status check entry.
| `serverName` | `STRING` | The friendly name of the server, or its UUID if no name is set.
| `address` | `STRING` | The address of the Bolt port for the server.
| `replicationSuccessful` | `BOOLEAN` | Indicates if the server (on which the procedure is run) can replicate a transaction.
| `memberStatus` | `STRING` | The status of each primary member.
| `recognisedLeader` | `STRING` | The server id of the perceived leader of each primary member.
| `recognisedLeaderTerm` | `INTEGER` | The term of the perceived leader of each primary member. If the members report different leaders, the one with the highest term should be trusted.
| `requester` | `BOOLEAN` | Whether a server is the requester or not.
| `error` | `STRING` | Contains any error message if present. An example of an error is that one or more of the requested databases do not exist on the requester.
| *Mode* 3+| DBMS
|===


[role=label--deprecated-5.23 label--enterprise-edition label--removed-cypher-25]
[[procedure_dbms_cluster_uncordonServer]]
=== dbms.cluster.uncordonServer()


.Details
|===
| *Syntax* 3+m| dbms.cluster.uncordonServer(server)
| *Description* 3+a| Remove the cordon on a server, returning it to 'enabled'.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The name or id of the server to be uncordoned.
| *Mode* 3+| WRITE
| *Replaced by* 3+| xref:clustering/server-syntax.adoc#server-management-syntax[`ENABLE SERVER`]
|*Required privileges* 3+| `SERVER MANAGEMENT`
|===

[NOTE]
====
Running the procedure with an admin privilege is deprecated.
====


[role=label--enterprise-edition label--new-2025.04]
[[procedure_dbms_recreateDatabase]]
=== dbms.recreateDatabase()


.Details
|===
| *Syntax* 3+m| dbms.recreateDatabase(database :: STRING, options = {} :: MAP)
| *Description* 3+a| Recreates a database while keeping all RBAC settings.
The procedure initiates a process, which when complete, will have synchronized and started all database instances within the cluster.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `database` | `STRING` | The name of the database to recreate.
| `options` | `MAP` | The seeding and topology options to use for recreating the database.
| *Mode* 3+| WRITE
|===

[NOTE]
====
It is mandatory to specify either `seedURI`, `seedingServers`, or `clearData` in the `options` field to define what store(s) the recreation should be based on.
Further details on how to use the `dbms.recreateDatabase()` procedure are provided in the related section xref:database-administration/standard-databases/recreate-database.adoc[Database administration -> Recreate a database].
If no topology option is defined, the database will be recreated with the previous topology.
====


[role=label--admin-only label--enterprise-edition]
[[procedure_dbms_setDefaultAllocationNumbers]]
=== dbms.setDefaultAllocationNumbers()


.Details
|===
| *Syntax* 3+m| dbms.setDefaultAllocationNumbers(primaries, secondaries)
| *Description* 3+a| With this method you can set the default number of primaries and secondaries.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `primaries` | `INTEGER` | The default number of primaries.
| `secondaries` | `INTEGER` | The default number of secondaries.
| *Mode* 3+| WRITE
|===

[role=label--admin-only label--enterprise-edition]
[[procedure_dbms_showTopologyGraphConfig]]
=== dbms.showTopologyGraphConfig()


.Details
|===
| *Syntax* 3+m| dbms.showTopologyGraphConfig() :: (allocator, defaultPrimariesCount, defaultSecondariesCount, defaultDatabase, autoEnableFreeServers)
| *Description* 3+a| With this method the configuration of the Topology Graph can be displayed.
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `allocator` | `STRING` | The name of the allocator.
| `defaultPrimariesCount` | `INTEGER` | The default number of primaries.
| `defaultSecondariesCount` | `INTEGER` | The default number of secondaries.
| `defaultDatabase` | `STRING` | The name of the default database.
| `autoEnableFreeServers` | `BOOLEAN` | Whether or not to automatically enable free servers.
| *Mode* 3+| READ
|===

[NOTE]
====
Starting with Neo4j 2025.04, the default database can also be set to a local or remote database alias.
====

== Configuration and DBMS info

For more information, see xref:configuration/index.adoc[].

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_checkConfigValue]]
=== dbms.checkConfigValue()


.Details
|===
| *Syntax* 3+m| dbms.checkConfigValue(setting, value) :: (valid, message)
| *Description* 3+a| Check if a potential config setting value is valid.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `setting` | `STRING` | The name of the setting.
| `value` | `STRING` | The setting value to verify.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `valid` | `BOOLEAN` | Whether or not the setting value is valid.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


[[procedure_dbms_components]]
=== dbms.components()


.Details
|===
| *Syntax* 3+m| dbms.components() :: (name, versions, edition)
| *Description* 3+a| List DBMS components and their versions.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The name of the component.
| `versions` | `LIST<STRING>` | The installed versions of the component.
| `edition` | `STRING` | The Neo4j edition of the DBMS.
| *Mode* 3+| DBMS
|===

[NOTE]
====
As of Neo4j 2025.05, `dbms.components()` returns the supported Cypher versions in a row where the `name` column has the value `"Cypher"`.
As of Neo4j 2025.06, the row has the value `["5", "25"]`, indicating that both Cypher 5 and Cypher 25 are supported from this release onward.
For more information about Cypher versions, see the link:{neo4j-docs-base-uri}/cypher-manual/5/queries/select-version/[Cypher Manual -> Select Cypher version].
====

[[procedure_dbms_info]]
=== dbms.info()


.Details
|===
| *Syntax* 3+m| dbms.info() :: (id, name, creationDate)
| *Description* 3+a| Provides information regarding the DBMS.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The id of the DBMS.
| `name` | `STRING` | The name of the DBMS.
| `creationDate` | `STRING` | The creation date of the DBMS.
| *Mode* 3+| DBMS
|===

[[procedure_dbms_listCapabilities]]
=== dbms.listCapabilities()


.Details
|===
| *Syntax* 3+m| dbms.listCapabilities() :: (name, description, value)
| *Description* 3+a| List capabilities.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The full name of the capability (e.g. "dbms.instance.version").
| `description` | `STRING` | The capability description (e.g. "Neo4j version this instance is running").
| `value` | `ANY` | The capability object if it is present in the system (e.g. "5.20.0").
| *Mode* 3+| DBMS
|===

[role=label--admin-only]
[[procedure_dbms_listConfig]]
=== dbms.listConfig()


.Details
|===
| *Syntax* 3+m| dbms.listConfig([ searchString ]) :: (name, description, value, dynamic, defaultValue, startupValue, explicitlySet, validValues)
| *Description* 3+a| List the currently active configuration settings of Neo4j.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `searchString` | `STRING` | A string that filters on the name of config settings.
.9+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The name of the setting.
| `description` | `STRING` | The description of the setting.
| `value` | `STRING` | The set value of the setting.
| `dynamic` | `BOOLEAN` | If the setting can be set dynamically or not.
| `defaultValue` | `STRING` | The default value of the setting.
| `startupValue` | `STRING` | The value of the setting when the database started.
| `explicitlySet` | `BOOLEAN` | Whether or not the setting was explicitly set.
| `validValues` | `STRING` | A description of the valid values.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition label--admin-only label--not-on-aura]
[[procedure_dbms_setConfigValue]]
=== dbms.setConfigValue()


.Details
|===
| *Syntax* 3+m| dbms.setConfigValue(setting, value)
| *Description* 3+a| Update a given setting value. Passing an empty value results in removing the configured value and falling back to the default value. Changes do not persist and are lost if the server is restarted. In a clustered environment, `dbms.setConfigValue` affects only the cluster member it is run against.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `setting` | `STRING` | The name of the setting.
| `value` | `STRING` | The value to set.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition]
[[procedure_dbms_listPools]]
=== dbms.listPools()


.Details
|===
| *Syntax* 3+m| dbms.listPools() :: (pool, databaseName, heapMemoryUsed, heapMemoryUsedBytes, nativeMemoryUsed, nativeMemoryUsedBytes, freeMemory, freeMemoryBytes, totalPoolMemory, totalPoolMemoryBytes)
| *Description* 3+a| List all memory pools, including sub pools, currently registered at this instance that are visible to the user.
.11+| *Return arguments* | *Name* | *Type* | *Description*
| `pool` | `STRING` | The name of the memory pool.
| `databaseName` | `STRING` | The name of the database.
| `heapMemoryUsed` | `STRING` | The amount of heap memory used.
| `heapMemoryUsedBytes` | `STRING` | The amount of heap memory used in bytes.
| `nativeMemoryUsed` | `STRING` | The amount of native memory used.
| `nativeMemoryUsedBytes` | `STRING` | The amount of native memory used in bytes.
| `freeMemory` | `STRING` | The amount of free memory.
| `freeMemoryBytes` | `STRING` | The amount of free memory in bytes.
| `totalPoolMemory` | `STRING` | The total pool memory.
| `totalPoolMemoryBytes` | `STRING` | The total pool memory in bytes.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== Connection management

For more information, see xref:monitoring/connection-management.adoc[].

[[procedure_dbms_listConnections]]
=== dbms.listConnections()


.Details
|===
| *Syntax* 3+m| dbms.listConnections() :: (connectionId, connectTime, connector, username, userAgent, serverAddress, clientAddress)
| *Description* 3+a| List all accepted network connections at this instance that are visible to the user.
.8+| *Return arguments* | *Name* | *Type* | *Description*
| `connectionId` | `STRING` | The id of the connection.
| `connectTime` | `STRING` | The time the connection was established, formatted according to the ISO-8601 Standard.
| `connector` | `STRING` | The protocol of the connector.
| `username` | `STRING` | The username of the connected user.
| `userAgent` | `STRING` | The active agent.
| `serverAddress` | `STRING` | The address of the connected server.
| `clientAddress` | `STRING` | The address of the connected client.
| *Mode* 3+| DBMS
|===

[[procedure_dbms_killConnection]]
=== dbms.killConnection()


.Details
|===
| *Syntax* 3+m| dbms.killConnection(id) :: (connectionId, username, message)
| *Description* 3+a| Kill network connection with the given connection id.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The id of the connection to kill.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `connectionId` | `STRING` | The id of the connection killed.
| `username` | `STRING` | The username of the user of the killed connection.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===

[[procedure_dbms_killConnections]]
=== dbms.killConnections()


.Details
|===
| *Syntax* 3+m| dbms.killConnections(ids) :: (connectionId, username, message)
| *Description* 3+a| Kill all network connections with the given connection ids.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `ids` | `LIST<STRING>` | The ids of the connections to kill.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `connectionId` | `STRING` | The id of the connection killed.
| `username` | `STRING` | The username of the user of the killed connection.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===


== Database management

For more information, see xref:database-administration/index.adoc[] and xref:database-internals/index.adoc[].

[role=label--enterprise-edition]
[[procedure_db_checkpoint]]
=== db.checkpoint()


.Details
|===
| *Syntax* 3+m| db.checkpoint() :: (success, message)
| *Description* 3+a| Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `db.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `success` | `BOOLEAN` | Whether the checkpoint has successfully completed.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_info]]
=== db.info()


.Details
|===
| *Syntax* 3+m| db.info() :: (id, name, creationDate)
| *Description* 3+a| Provides information regarding the database.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `id` | `STRING` | The id of the database.
| `name` | `STRING` | The name of the database.
| `creationDate` | `STRING` | The creation date of the database, formatted according to the ISO-8601 Standard.
| *Mode* 3+| READ
|===

[role=label--enterprise-edition]
[[procedure_dbms_listActiveLocks]]
=== dbms.listActiveLocks()


.Details
|===
| *Syntax* 3+m| dbms.listActiveLocks(queryId) :: (mode, resourceType, resourceId)
| *Description* 3+a| List the active lock requests granted for the transaction executing the query with the given query id.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `queryId` | `STRING` | The id of the query to check for active locks on.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `mode` | `STRING` | The lock type: ('SHARED', 'EXCLUSIVE').
| `resourceType` | `STRING` | The locked resource.
| `resourceId` | `INTEGER` | The id of the locked resource.
| *Mode* 3+| DBMS
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[role=label--enterprise-edition label--admin-only]
[[procedure_db_listLocks]]
=== db.listLocks()


.Details
|===
| *Syntax* 3+m| db.listLocks() :: (mode, resourceType, resourceId, transactionId)
| *Description* 3+a| List all locks at this database.
.5+| *Return arguments* | *Name* | *Type* | *Description*
| `mode` | `STRING` | The locking mode this lock is using, either "SHARED" or "EXCLUSIVE".
| `resourceType` | `STRING` | The type of resource (e.g. nodes, relationships, labels) this lock protects.
| `resourceId` | `INTEGER` | The id of the resource this lock protects.
| `transactionId` | `STRING` | The id of the transaction that owns this lock.
| *Mode* 3+| DBMS
|===

[[procedure_db_ping]]
=== db.ping()


.Details
|===
| *Syntax* 3+m| db.ping() :: (success)
| *Description* 3+a| This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `success` | `BOOLEAN` | Whether or not the connection call to the database has been successful.
| *Mode* 3+| READ
|===

[[procedure_dbms_routing_getRoutingTable]]
=== dbms.routing.getRoutingTable()


.Details
|===
| *Syntax* 3+m| dbms.routing.getRoutingTable(context [, database ]) :: (ttl, servers)
| *Description* 3+a| Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example, an endpoint may serve read queries, write queries, and/or future `getRoutingTable` requests.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `context` | `MAP` | Routing context, for example, routing policies.
| `database` | `STRING` | The database to get a routing table for.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `ttl` | `INTEGER` | Time to live (in seconds) for the routing table.
| `servers` | `LIST<MAP>` | Servers grouped by whether they are readers, writers, or routers.
| *Mode* 3+| DBMS
|===

[role=label--enterprise-edition label--admin-only]
[[procedure_dbms_setDefaultDatabase]]
=== dbms.setDefaultDatabase()


.Details
|===
| *Syntax* 3+m| dbms.setDefaultDatabase(databaseName) :: (result)
| *Description* 3+a| Change the default database to the provided value. The database must exist and the old default database must be stopped.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `result` | `STRING` | Information about the default database.
| *Mode* 3+| WRITE
|===

[NOTE]
====
Starting with Neo4j 2025.04, the default database can also be set to a local or remote database alias.
====

[role=label--enterprise-edition label--admin-only label--deprecated-2025.01 label--removed-cypher-25]
[[procedure_dbms_quarantineDatabase]]
=== dbms.quarantineDatabase()


.Details
|===
| *Syntax* 3+m| dbms.quarantineDatabase(databaseName, setStatus [, reason ]) :: (databaseName, quarantined, result)
| *Description* 3+a| Place a database into quarantine or remove it from it.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database to set the quarantine status of.
| `setStatus` | `BOOLEAN` | Whether or not to quarantine the database.
| `reason` | `STRING` | The reason to quarantine the database.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `databaseName` | `STRING` | The name of the database.
| `quarantined` | `BOOLEAN` | Whether or not the database is quarantined.
| `result` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| DBMS
| *Replaced by* 3+| <<#procedure_dbms_unquarantineDatabase, `dbms.unquarantineDatabase()`>>
|===

[NOTE]
====
It is recommended to use <<#procedure_dbms_unquarantineDatabase,`dbms.unquarantineDatabase()`>> over `dbms.quarantineDatabase()` due to its improvements and new features (see the `operation` option).
// The deprecated `dbms.quarantineDatabase()` procedure is available in Cypher 5, but not in Cypher 25.
====

[role=label--enterprise-edition label--admin-only label--new-2025.01]
[[procedure_dbms_unquarantineDatabase]]
=== dbms.unquarantineDatabase()


.Details
|===
| *Syntax* 3+m| dbms.unquarantineDatabase(server, databaseName, operation) :: ()
| *Description* 3+a| Lift quarantine from a database on a given server.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `server` | `STRING` | The identifier of the server where the quarantine for database will be lifted.
| `database` | `STRING` | The name of the database for the quarantine will be lifted.
| `operation` | `STRING` | Optional operation to apply while lifting the quarantine.
| *Mode* 3+| DBMS
|===

[NOTE]
====
The possible values for the optional operation are:

* `keepStateKeepStore` -- do nothing; leave store and cluster state as they are.
* `replaceStateKeepStore` -- join as a new member, clearing the current cluster state but keeping the store.
* `replaceStateReplaceStore` -- join as a new member, clearing both the current cluster state and the store.

If you choose to clear the current cluster state, the defined database allocation will try to join as a new member.
This joining process can succeed if and only if a majority of the existing members allow the new member to join.
Assume your database has a topology with three primary allocations.
If there is only one allocation in `quarantined` mode, then it is safe to choose `replaceStateKeepStore` or `replaceStateReplaceStore`.
If there are two allocations in `quarantined` mode (meaning that the database is `quarantined` on two servers), then you should not use concurrently `replaceStateKeepStore` or `replaceStateReplaceStore` for both of them because there would be no majority to let them in.
====

[role=label--admin-only label--deprecated-5.9 label--removed-cypher-25]
[[procedure_dbms_upgrade]]
=== dbms.upgrade()


.Details
|===
| *Syntax* 3+m| dbms.upgrade() :: (status, upgradeResult)
| *Description* 3+a| Upgrade the system database schema if it is not the current schema.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `status` | `STRING` | The upgrade status of the system database.
| `upgradeResult` | `STRING` | Information about the upgrade outcome.
| *Mode* 3+| WRITE
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


[role=label--admin-only label--deprecated-5.9 label--removed-cypher-25]
[[procedure_dbms_upgradeStatus]]
=== dbms.upgradeStatus()


.Details
|===
| *Syntax* 3+m| dbms.upgradeStatus() :: (status, description, resolution)
| *Description* 3+a| Report the current status of the system database sub-graph schema.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `status` | `STRING` | The upgrade status of the system database.
| `description` | `STRING` | Information describing the upgrade status.
| `resolution` | `STRING` | Information about the steps necessary to upgrade.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== Vectors

For more information, see:

* link:{neo4j-docs-base-uri}/cypher-manual/5/indexes/semantic-indexes/vector-indexes/[Cypher Manual -> Vector indexes]
* link:{neo4j-docs-base-uri}/cypher-manual/5/functions/vector/[Cypher Manual -> Vector functions]
* link:{neo4j-docs-base-uri}/cypher-manual/5/genai-integrations[Cypher Manual -> GenAI integrations]
* link:{neo4j-docs-base-uri}/cypher-manual/5/functions/[Cypher Manual -> GenAI functions]
* link:{neo4j-docs-base-uri}/genai/tutorials/embeddings-vector-indexes/[GenAI documentation -> Embeddings & Vector Indexes Tutorial]

[[procedure_db_create_setNodeVectorProperty]]
=== db.create.setNodeVectorProperty


.Details
|===
| *Syntax* 3+m| db.create.setNodeVectorProperty(node, key, vector)
| *Description* 3+a| Set a vector property on a given node in a more space efficient representation than Cypher's `SET`.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | The node on which the new property will be stored.
| `key` | `STRING` | The name of the new property.
| `vector` | `ANY` | The object containing the embedding.
| *Mode* 3+| WRITE
|===

.Known issue
[NOTE]
====
Procedure signatures from `SHOW PROCEDURES` renders the vector arguments with a type of `ANY` rather than the semantically correct type of `LIST<INTEGER | FLOAT>`.
The types are still enforced as `LIST<INTEGER | FLOAT>`.
====

[[procedure_db_create_setRelationshipVectorProperty]]
=== db.create.setRelationshipVectorProperty()


.Details
|===
| *Syntax* 3+m| db.create.setRelationshipVectorProperty(relationship, key, vector)
| *Description* 3+a| Set a vector property on a given relationship in a more space efficient representation than Cypher's `SET`.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `relationship` | `RELATIONSHIP` | The relationship on which the new property will be stored.
| `key` | `STRING` | The name of the new property.
| `vector` | `ANY` | The object containing the embedding.
| *Mode* 3+| WRITE
|===

.Known issue
[NOTE]
====
Procedure signatures from `SHOW PROCEDURES` renders the vector arguments with a type of `ANY` rather than the semantically correct type of `LIST<INTEGER | FLOAT>`.
The types are still enforced as `LIST<INTEGER | FLOAT>`.
====

[role=label--beta label--deprecated-5.13 label--removed-cypher-25]
[[procedure_db_create_setVectorProperty]]
=== db.create.setVectorProperty()


.Details
|===
| *Syntax* 3+m| db.create.setVectorProperty(node, key, vector) :: (node)
| *Description* 3+a| Set a vector property on a given node in a more space efficient representation than Cypher's SET.
.4+| *Input arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | The node on which the new property will be stored.
| `key` | `STRING` | The name of the new property.
| `vector` | `ANY` | The object containing the embedding.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | The node on which the vector property was set.
| *Mode* 3+| WRITE
| *Replaced by* 3+| <<#procedure_db_create_setNodeVectorProperty, `db.create.setNodeVectorProperty()`>> and <<#procedure_db_create_setRelationshipVectorProperty, `db.create.setRelationshipVectorProperty()`>>
|===

.Known issue
[NOTE]
====
Procedure signatures from `SHOW PROCEDURES` renders the vector arguments with a type of `ANY` rather than the semantically correct type of `LIST<INTEGER | FLOAT>`.
The types are still enforced as `LIST<INTEGER | FLOAT>`.
====


[role=label--deprecated-5.26 label--removed-cypher-25]
[[procedure_db_index_vector_createNodeIndex]]
=== db.index.vector.createNodeIndex()


.Details
|===
| *Syntax* 3+m| db.index.vector.createNodeIndex(indexName, label, propertyKey, vectorDimension, vectorSimilarityFunction)
| *Description* 3+a| Create a named node vector index for the specified label and property with the given vector dimensionality using either the EUCLIDEAN or COSINE similarity function.
Both similarity functions are case-insensitive.
Use the `db.index.vector.queryNodes` procedure to query the named index.

.6+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | indexName :: STRING
| `label` | `STRING` | label :: STRING
| `propertyKey` | `STRING` | propertyKey :: STRING
| `vectorDimension` | `INTEGER` | vectorDimension :: INTEGER
| `vectorSimilarityFunction` | `STRING` | vectorSimilarityFunction :: STRING
| *Mode* 3+| SCHEMA
| *Replaced by* 3+| the Cypher command `CREATE VECTOR INDEX`. For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/indexes/semantic-indexes/vector-indexes/#create-vector-index[Cypher Manual -> Create a vector index].
|===

[[procedure_db_index_vector_queryNodes]]
=== db.index.vector.queryNodes()


.Details
|===
| *Syntax* 3+m| db.index.vector.queryNodes(indexName, numberOfNearestNeighbours, query) :: (node, score)
| *Description* 3+a| Query the given node vector index.
Returns requested number of nearest neighbors to the provided query vector, and their similarity score to that query vector, based on the configured similarity function for the index.
The similarity score is a value between [0, 1]; where 0 indicates least similar, 1 most similar.

.4+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the vector index.
| `numberOfNearestNeighbours` | `INTEGER` | The size of the vector neighbourhood.
| `query` | `ANY` | The object to find approximate matches for.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | A node which contains a vector property similar to the query object.
| `score` | `FLOAT` | The score measuring how similar the node property is to the query object.
| *Mode* 3+| READ
|===


[[procedure_db_index_vector_queryRelationships]]
=== db.index.vector.queryRelationships()


.Details
|===
| *Syntax* 3+m| db.index.vector.queryRelationships(indexName, numberOfNearestNeighbours, query) :: (relationship, score)
| *Description* 3+a| Query the given relationship vector index.
Returns requested number of nearest neighbors to the provided query vector,
and their similarity score to that query vector, based on the configured similarity function for the index.
The similarity score is a value between [0, 1]; where 0 indicates least similar, 1 most similar.

.4+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the vector index.
| `numberOfNearestNeighbours` | `INTEGER` | The size of the vector neighbourhood.
| `query` | `ANY` | The object to find approximate matches for.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `relationship` | `RELATIONSHIP` | A relationship which contains a vector property similar to the query object.
| `score` | `FLOAT` | The score measuring how similar the relationship property is to the query object.
| *Mode* 3+| READ
|===


== Index management

For more information, see:

* xref:performance/index-configuration.adoc[]
* link:{neo4j-docs-base-uri}/cypher-manual/5/indexes/search-performance-indexes/[Cypher Manual -> Search performance indexes]
* link:{neo4j-docs-base-uri}/cypher-manual/5/indexes/semantic-indexes/full-text-indexes[Cypher Manual -> Full-text indexes]

[[procedure_db_awaitIndex]]
=== db.awaitIndex()


.Details
|===
| *Syntax* 3+m| db.awaitIndex(indexName [, timeOutSeconds ])
| *Description* 3+a| Wait for an index to come online (for example: CALL db.awaitIndex("MyIndex", 300)).
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the awaited index.
| `timeOutSeconds` | `INTEGER` | The maximum time to wait in seconds.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_awaitIndexes]]
=== db.awaitIndexes()


.Details
|===
| *Syntax* 3+m| db.awaitIndexes([ timeOutSeconds ])
| *Description* 3+a| Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)).
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `timeOutSeconds` | `INTEGER` | The maximum time to wait in seconds.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


[[procedure_db_index_fulltext_awaitEventuallyConsistentIndexRefresh]]
=== db.index.fulltext.awaitEventuallyConsistentIndexRefresh()


.Details
|===
| *Syntax* 3+m| db.index.fulltext.awaitEventuallyConsistentIndexRefresh()
| *Description* 3+a| Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.
| *Mode* 3+| READ
|===

[[procedure_db_index_fulltext_listAvailableAnalyzers]]
=== db.index.fulltext.listAvailableAnalyzers()


.Details
|===
| *Syntax* 3+m| db.index.fulltext.listAvailableAnalyzers() :: (analyzer, description, stopwords)
| *Description* 3+a| List the available analyzers that the full-text indexes can be configured with.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `analyzer` | `STRING` | The name of the analyzer.
| `description` | `STRING` | The  description of the analyzer.
| `stopwords` | `LIST<STRING>` | The stopwords used by the analyzer to tokenize strings.
| *Mode* 3+| READ
|===


[[procedure_db_index_fulltext_queryNodes]]
=== db.index.fulltext.queryNodes()


.Details
|===
| *Syntax* 3+m| db.index.fulltext.queryNodes(indexName, queryString [, options ]) :: (node, score)
| *Description* 3+a| Query the given full-text index. Returns the matching nodes and their Lucene query score, ordered by score.
Valid _key: value_ pairs for the `options` map are:

* 'skip' -- to skip the top N results.
* 'limit' -- to limit the number of results returned.
* 'analyzer' -- to use the specified analyzer as a search analyzer for this query.

The `options` map and any of the keys are optional.
An example of the `options` map: `{skip: 30, limit: 10, analyzer: 'whitespace'}`

.4+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the full-text index.
| `queryString` | `STRING` | The string to find approximate matches for.
| `options` | `MAP` | {skip :: INTEGER, limit :: INTEGER, analyzer :: STRING}
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `node` | `NODE` | A node which contains a property similar to the query string.
| `score` | `FLOAT` | The score measuring how similar the node property is to the query string.
| *Mode* 3+| READ
|===

[[procedure_db_index_fulltext_queryRelationships]]
=== db.index.fulltext.queryRelationships()


.Details
|===
| *Syntax* 3+m| db.index.fulltext.queryRelationships(indexName, queryString [, options ]) :: (relationship, score)
| *Description* 3+a| Query the given full-text index. Returns the matching relationships and their Lucene query score, ordered by score.
Valid _key: value_ pairs for the `options` map are:

* 'skip' -- to skip the top N results.
* 'limit' -- to limit the number of results returned.
* 'analyzer' -- to use the specified analyzer as a search analyzer for this query.

The `options` map and any of the keys are optional.
An example of the `options` map: `{skip: 30, limit: 10, analyzer: 'whitespace'}`

.4+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the full-text index.
| `queryString` | `STRING` | The string to find approximate matches for.
| `options` | `MAP` | {skip :: INTEGER, limit :: INTEGER, analyzer :: STRING}
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `relationship` | `RELATIONSHIP` | A relationship which contains a property similar to the query string.
| `score` | `FLOAT` | The score measuring how similar the relationship property is to the query string.
| *Mode* 3+| READ
|===


[[procedure_db_resampleIndex]]
=== db.resampleIndex()


.Details
|===
| *Syntax* 3+m| db.resampleIndex(indexName)
| *Description* 3+a| Schedule resampling of an index (for example: CALL db.resampleIndex("MyIndex")).
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `indexName` | `STRING` | The name of the index.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====


[[procedure_db_resampleOutdatedIndexes]]
=== db.resampleOutdatedIndexes()


.Details
|===
| *Syntax* 3+m| db.resampleOutdatedIndexes()
| *Description* 3+a| Schedule resampling of all outdated indexes.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== Metrics

[[procedure_dbms_queryJmx]]
=== dbms.queryJmx()


.Details
|===
| *Syntax* 3+m| dbms.queryJmx(query) :: (name, description, attributes)
| *Description* 3+a| Query JMX management data by domain and name. For instance, use *:* to find all JMX beans.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `query` | `STRING` | A query for MBeans on this MBeanServer (e.g. '*:*,name=*neo4j*' for all metrics in neo4j database).
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `name` | `STRING` | The name of the metric.
| `description` | `STRING` | The description of the metric.
| `attributes` | `MAP` | A collection with the attributes (values) of that metric.
| *Mode* 3+| DBMS
|===

== Schema and metadata

[[procedure_db_schema_nodeTypeProperties]]
=== db.schema.nodeTypeProperties()


.Details
|===
| *Syntax* 3+m| db.schema.nodeTypeProperties() :: (nodeType, nodeLabels, propertyName, propertyTypes, mandatory)
| *Description* 3+a| Show the derived property schema of the nodes in tabular form.
.6+| *Return arguments* | *Name* | *Type* | *Description*
| `nodeType` | `STRING` | A name generated from the labels on the node.
| `nodeLabels` | `LIST<STRING>` | A list containing the labels on a category of node.
| `propertyName` | `STRING` | A property key on a category of node.
| `propertyTypes` | `LIST<STRING>` | All types of a property belonging to a node category.
| `mandatory` | `BOOLEAN` | Whether or not the property is present on all nodes belonging to a node category.
| *Mode* 3+| READ
|===

[NOTE]
In Cypher 5, the `propertyTypes` column returns the potential Java types for a given property.
In Cypher 25, it returns the potential Cypher types instead.
For information about Cypher's property types, see the link:{neo4j-docs-base-uri}/cypher-manual/current/values-and-types/property-structural-constructed/#property-types[Cypher Manual -> Property types].

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_schema_relTypeProperties]]
=== db.schema.relTypeProperties()


.Details
|===
| *Syntax* 3+m| db.schema.relTypeProperties() :: (relType, propertyName, propertyTypes, mandatory)
| *Description* 3+a| Show the derived property schema of the relationships in tabular form.
.5+| *Return arguments* | *Name* | *Type* | *Description*
| `relType` | `STRING` | A name generated from the type on the relationship.
| `propertyName` | `STRING` | A property key on a category of relationship.
| `propertyTypes` | `LIST<STRING>` | All types of a property belonging to a relationship category.
| `mandatory` | `BOOLEAN` | Whether or not the property is present on all relationships belonging to a relationship category.
| *Mode* 3+| READ
|===

[NOTE]
In Cypher 5, the `propertyTypes` column returns the potential Java types for a given property.
In Cypher 25, it returns the potential Cypher types instead.
For information about Cypher's property types, see the link:{neo4j-docs-base-uri}/cypher-manual/current/values-and-types/property-structural-constructed/#property-types[Cypher Manual -> Property types].


[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_schema_visualization]]
=== db.schema.visualization()


.Details
|===
| *Syntax* 3+m| db.schema.visualization() :: (nodes, relationships)
| *Description* 3+a| Visualizes the schema of the data based on available statistics. A new node is returned for each label. The properties represented on the node include: `name` (label name), `indexes` (list of indexes), and `constraints` (list of constraints). A relationship of a given type is returned for all possible combinations of start and end nodes. The properties represented on the relationship include: `name` (type name). Note that this may include additional relationships that do not exist in the data due to the information available in the count store.
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `nodes` | `LIST<NODE>` | A list of virtual nodes representing each label in the database.
| `relationships` | `LIST<RELATIONSHIP>` | A list of virtual relationships representing all combinations between start and end nodes in the database.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_createLabel]]
=== db.createLabel()


.Details
|===
| *Syntax* 3+m| db.createLabel(newLabel)
| *Description* 3+a| Create a label
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `newLabel` | `STRING` | Label name.
| *Mode* 3+| WRITE
|===

[[procedure_db_createProperty]]
=== db.createProperty()


.Details
|===
| *Syntax* 3+m| db.createProperty(newProperty)
| *Description* 3+a| Create a Property
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `newProperty` | `STRING` | Property name.
| *Mode* 3+| WRITE
|===

[[procedure_db_createRelationshipType]]
=== db.createRelationshipType


.Details
|===
| *Syntax* 3+m| db.createRelationshipType(newRelationshipType)
| *Description* 3+a| Create a RelationshipType
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `newRelationshipType` | `STRING` | Relationship type name.
| *Mode* 3+| WRITE
|===

[[procedure_db_labels]]
=== db.labels()


.Details
|===
| *Syntax* 3+m| db.labels() :: (label)
| *Description* 3+a| List all labels attached to nodes within a database according to the user's access rights. The procedure returns empty results if the user is not authorized to view those labels.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `label` | `STRING` | A label within the database.
| *Mode* 3+| READ
|===


[[procedure_db_propertyKeys]]
=== db.propertyKeys()


.Details
|===
| *Syntax* 3+m| db.propertyKeys() :: (propertyKey)
| *Description* 3+a| List all property keys in the database.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `propertyKey` | `STRING` | A property key in the database.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[[procedure_db_relationshipTypes]]
=== db.relationshipTypes()


.Details
|===
| *Syntax* 3+m| db.relationshipTypes() :: (relationshipType)
| *Description* 3+a| List all types attached to relationships within a database according to the user's access rights. The procedure returns empty results if the user is not authorized to view those relationship types.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `relationshipType` | `STRING` | A relationship type in the database.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

== Statistics and query planning

For more information, see xref:performance/statistics-execution-plans.adoc[]

[role=label--admin-only]
[[procedure_db_clearQueryCaches]]
=== db.clearQueryCaches()


.Details
|===
| *Syntax* 3+m| db.clearQueryCaches() :: (value)
| *Description* 3+a| Clears all query caches.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `value` | `STRING` | Information about the number of cleared query caches.
| *Mode* 3+| DBMS
|===

[role=label--admin-only]
[[procedure_db_prepareForReplanning]]
=== db.prepareForReplanning()


.Details
|===
| *Syntax* 3+m| db.prepareForReplanning([ timeOutSeconds ])
| *Description* 3+a| Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `timeOutSeconds` | `INTEGER` | The maximum time to wait in seconds.
| *Mode* 3+| READ
|===

[NOTE]
====
This procedure is not considered safe to run from multiple threads.
It is therefore not supported by the parallel runtime.
For more information, see the link:{neo4j-docs-base-uri}/cypher-manual/5/planning-and-tuning/runtimes/concepts#runtimes-parallel-runtime[Cypher Manual -> Parallel runtime].
====

[role=label--admin-only]
[[procedure_db_stats_clear]]
=== db.stats.clear


.Details
|===
| *Syntax* 3+m| db.stats.clear(section) :: (section, success, message)
| *Description* 3+a| Clear collected data of a given data section. Valid sections are 'QUERIES'
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section to clear. The only available section is: 'QUERIES'.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section cleared.
| `success` | `BOOLEAN` | Whether the section was successfully cleared.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| READ
|===

[role=label--admin-only]
[[procedure_db_stats_collect]]
=== db.stats.collect()


.Details
|===
| *Syntax* 3+m| db.stats.collect(section [, config ]) :: (section, success, message)
| *Description* 3+a| Start data collection of a given data section. Valid sections are 'QUERIES'
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section to collect. The only available section is: 'QUERIES'.
| `config` | `MAP` | {durationSeconds = -1 INTEGER}
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section collected.
| `success` | `BOOLEAN` | Whether the section was successfully collected.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| READ
|===

[role=label--admin-only]
[[procedure_db_stats_retrieve]]
=== db.stats.retrieve()


.Details
|===
| *Syntax* 3+m| db.stats.retrieve(section [, config ]) :: (section, data)
| *Description* 3+a| Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META'
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | A section of stats to retrieve: ('GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META').
| `config` | `MAP` | {maxInvocations = 100 INTEGER}
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section retrieved.
| `data` | `MAP` | Data pertaining to the retrieved statistics.
| *Mode* 3+| READ
|===

[role=label--admin-only]
[[procedure_db_stats_retrieveAllAnonymized]]
=== db.stats.retrieveAllAnonymized()


.Details
|===
| *Syntax* 3+m| db.stats.retrieveAllAnonymized(graphToken [, config ]) :: (section, data)
| *Description* 3+a| Retrieve all available statistical data about the current database, in an anonymized form.
.3+| *Input arguments* | *Name* | *Type* | *Description*
| `graphToken` | `STRING` | The name of the graph token.
| `config` | `MAP` | {maxInvocations = 100 INTEGER}
.3+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section retrieved.
| `data` | `MAP` | Data pertaining to the retrieved statistics.
| *Mode* 3+| READ
|===


[role=label--admin-only]
[[procedure_db_stats_status]]
=== db.stats.status()


.Details
|===
| *Syntax* 3+m| db.stats.status() :: (section, status, data)
| *Description* 3+a| Retrieve the status of all available collector daemons, for this database.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | String with the message "QUERIES".
| `status` | `STRING` | The status of the QueryCollector: "idle" or "collecting".
| `data` | `MAP` | data :: MAP
| *Mode* 3+| READ
|===


[role=label--admin-only]
[[procedure_db_stats_stop]]
=== db.stats.stop()


.Details
|===
| *Syntax* 3+m| db.stats.stop(section) :: (section, success, message)
| *Description* 3+a| Stop data collection of a given data section. Valid sections are 'QUERIES'
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The section to stop. The only available section is: 'QUERIES'.
.4+| *Return arguments* | *Name* | *Type* | *Description*
| `section` | `STRING` | The stopped section.
| `success` | `BOOLEAN` | Whether the section was successfully stopped.
| `message` | `STRING` | Details about the outcome of the procedure.
| *Mode* 3+| READ
|===


== Transaction management

[[procedure_tx_getMetaData]]
=== tx.getMetaData()


.Details
|===
| *Syntax* 3+m| tx.getMetaData() :: (metadata)
| *Description* 3+a| Provides attached transaction metadata.
.2+| *Return arguments* | *Name* | *Type* | *Description*
| `metadata` | `MAP` | Metadata about the transaction.
| *Mode* 3+| DBMS
|===


[[procedure_tx_setMetaData]]
=== tx.setMetaData()


.Details
|===
| *Syntax* 3+m| tx.setMetaData(data)
| *Description* 3+a| Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log.
.2+| *Input arguments* | *Name* | *Type* | *Description*
| `data` | `MAP` | Metadata to attach to the transaction.
| *Mode* 3+| DBMS
|===



