:page-role: new-2025.10 enterprise-edition not-on-aura
:description: This page describes the concepts behind scalability with Neo4j.
= Concepts

Scalability is a crucial aspect of database management, allowing a system to handle changing demands by adding and removing resources to meet the demands of a database's workload.
Neo4j supports multiple strategies to achieve scalability, enabling systems to handle larger datasets, more concurrent users, and higher query complexity without compromising performance or availability, i.e. the system's resiliency.
The three main strategies are:

* xref:clustering/setup/analytics-cluster.adoc[Analytics clustering] -- for horizontal read scalability.
* xref:scalability/composite-databases/concepts.adoc[Composite databases] -- for federated queries and distributed data management.
* xref:scalability/sharded-property-databases/overview.adoc[Property sharding] -- for handling massive property-heavy graphs.

== What is scalability?

Scalability is a system's ability to handle an increasing workload without compromising performance.
There are two primary methods to achieve scalability:

.Scaling methods
[options="header", cols="1,1,1a,1a"]
|===
| Method
| Description
| Pros
| Cons

| Vertical Scaling (Scaling Up / Down)
| Increase or decrease the capacity of a single server by adding or removing CPUs, memory, or storage.
| Simple to manage.
| * Physical limits. +
* Difficult to make online changes.

| Horizontal Scaling (Scaling Out / In)
| Distribute the workload by adding more servers or reduce the infrastructure by removing existing servers.
| * Greater scalability and fault tolerance. +
* Easier to make online changes.
| More complex to manage.
|===

== What is database scalability?

Database scalability is the ability of a database management system (DBMS) to handle changing demands.
To scale properly, a database must apply strategies that cover all areas: data access, data manipulation in memory, and database computing.

Strategies include:

* **Vertical Scaling**
** Optimize usage (e.g., granular locks, partitioning)
** Optimize physical resources (multi-threading, tiered storage)

* **Horizontal Scaling** (distributed computing architectures):

** *Shared Everything*: All servers share data and memory.
Flexible, but prone to contention. +
In this model, data is shared between disk and memory across all servers in a cluster.
Requests are satisfied by any combination of servers.
This approach introduces complexity, as the cluster must implement a way to avoid contention when multiple servers try to update the same data simultaneously.

** *Shared Nothing*: Each server manages its own partition (shard).
More fault-tolerant, eliminates single points of failure. +
Every update request is handled by a single cluster member, which eliminates single points of failure.
Each part of the database on a single cluster member is called a *shard*.

image::scalability/horizontal-scaling-strategies.svg[title="Example of a sharing approach where all the servers share the storage vs a shared-nothing approach (e.g., property sharding).", role="middle"]

== What is graph database scalability?

Graph database scalability refers to the ability of a database to handle different amounts of data and workloads without compromising performance.
It includes:

* *Data volume* -  involves ensuring a consistent SLA in both query and administration response times, even as the size of the data for storage and retrieval expands. +
Volume depends on data type(s).
Vectors occupy a large data space.

* *Query volume*
** Read queries + write queries.
** Queries and user concurrency -- the aim is to ensure a linear response time during the execution of concurrent queries against the same database.
** Query complexity -- provide response time in line with the complexity of a query. The complexity of a query can be set by the combination of:
*** Steps to execute
*** Rows to retrieve
*** Total DB hits
*** Total memory allocation
*** Total execution time

* *Admin volume*
** Data ingestion/extraction -- When scaling data ingestion/extraction, the goal is to maintain a linear response time when ingesting or extracting an increasing set of data.
This objective remains true regardless of the volume of stored data, provided a similar data structure is used.
** Multi-tenancy -- In SaaS and AaaS environments, the scaling cost for tenants should exhibit linearity.
For more general services, such as DBaaS (e.g., Aura), scalability should also be linear, considering all five scalability factors mentioned here.



