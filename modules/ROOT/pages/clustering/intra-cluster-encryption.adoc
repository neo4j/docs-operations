[role=enterprise-edition]
[[causal-clustering-intra-cluster-encryption]]
= Intra-cluster encryption
:description: How to secure the cluster communication between server instances. 

[CAUTION]
====
Securing client to server communication is not covered in this chapter (e.g. Bolt, HTTPS, Backup).
====


[[causal-clustering-intra-cluster-encryption-introduction]]
== Introduction

The security solution for cluster communication is based on standard SSL/TLS technology (referred to jointly as SSL).
Encryption is in fact just one aspect of security, with the other cornerstones being authentication and integrity.
A secure solution will be based on a key infrastructure which is deployed together with a requirement of authentication.

The SSL support in the platform is documented in detail in xref:security/ssl-framework.adoc[SSL framework].
This section will cover the specifics as they relate to securing a cluster.

Under SSL, an endpoint can authenticate itself using certificates managed by a xref:security/ssl-framework.adoc#term-ssl-pki[Public Key Infrastructure (_PKI_)].

It should be noted that the deployment of a secure key management infrastructure is beyond the scope of this manual, and should be entrusted to experienced security professionals.
The example deployment illustrated below is for reference purposes only.

[TIP]
====
If setting up intra-cluster encryption as part of a cluster configuration, ensure that the certificates used on the cluster endpoint support server and client usage.
This is because when connecting between the Neo4j servers for clustering, each server uses its own certificate to authenticate as a client on the connection to another server.

This could be verified from within the certificate details:

----
openssl x509 -in public.crt -noout -text
----

We should see that the X509v3 Extended Key Usage section shows both the usages listed:

----
X509v3 Extended Key Usage:
    TLS Web Server Authentication, TLS Web Client Authentication
----
====

[[causal-clustering-intra-cluster-encryption-example-deployment]]
== Example deployment

The following steps will create an example deployment, and each step is expanded in further detail below.

 - Generate and install xref:security/ssl-framework.adoc#term-ssl-cryptographic-objects[cryptographic objects]
 - Configure Causal Clustering with the SSL policy
 - Validate the secure operation of the cluster


[[causal-clustering-intra-cluster-encryption-cryptographic]]
=== Generate and install cryptographic objects

The generation of cryptographic objects is for the most part outside the scope of this manual.
It will generally require having a PKI with a xref:security/ssl-framework.adoc#term-ssl-certificate-authority[Certificate Authority (_CA_)] within the organization and they should be able to advise here.
Please note that the information in this manual relating to the PKI is mainly for illustrative purposes.

When the certificates and private keys have been obtained they can be installed on each of the servers.
Each server will have a certificate of its own, signed by a CA, and the corresponding private key.
The certificate of the CA is installed into the `trusted` directory, and any certificate signed by the CA will thus be trusted.
This means that the server now has the capability of establishing trust with other servers.

[CAUTION]
====
Please be sure to exercise caution when using CA certificates in the `trusted` directory, as any certificates signed by that CA will then be trusted to join the cluster.
For this reason, never use a public CA to sign certificates for your cluster.
Instead, use an intermediate certificate or a CA certificate which originates from and is controlled by your organization.
====

In this example we will deploy a mutual authentication setup, which means that both ends of a channel have to authenticate.
To enable mutual authentication the SSL policy must have `client_auth` set to `REQUIRE` (which is the default).
Servers are by default required to authenticate themselves, so there is no corresponding server setting.

If the certificate for a particular server is compromised it is possible to revoke it by installing a xref:security/ssl-framework.adoc#term-ssl-certificate-revocation-list[Certificate Revocation List (_CRL_)] in the `revoked` directory.
It is also possible to redeploy using a new CA.
For contingency purposes, it is advised that you have a separate intermediate CA specifically for the cluster which can be substituted in its entirety should it ever become necessary.
This approach would be much easier than having to handle revocations and ensuring their propagation.

.Generate and install cryptographic objects
====
In this example we assume that the private key and certificate file are named _private.key_ and _public.crt_, respectively.
If you want to use different names you may override the policy configuration for the key and certificate names/locations.
We want to use the default configuration for this server so we create the appropriate directory structure and install the certificate:

[source, shell]
----
$neo4j-home> mkdir certificates/cluster
$neo4j-home> mkdir certificates/cluster/trusted
$neo4j-home> mkdir certificates/cluster/revoked

$neo4j-home> cp $some-dir/private.key certificates/cluster
$neo4j-home> cp $some-dir/public.crt certificates/cluster
----
====


[[causal-clustering-intra-cluster-encryption-ssl-config]]
=== Configure the cluster SSL policy

By default, cluster communication is unencrypted.
To configure a Causal Cluster to encrypt its intra-cluster communication, set `dbms.ssl.policy.cluster.enabled` to `true`.

An SSL policy utilizes the installed cryptographic objects and additionally allows parameters to be configured.
We will use the following parameters in our configuration:

.Example settings
[options="header"]
|===
| Setting suffix   | Value     | Comment
| `client_auth`    | `REQUIRE` | Setting this to `REQUIRE` effectively enables mutual authentication for servers.
| `ciphers`        | `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384` |
We can enforce a particular single strong cipher and remove any doubt about which cipher gets negotiated and chosen.
The cipher chosen above offers Perfect Forward Secrecy (PFS) which is generally desirable.
It also uses  Advanced Encryption Standard (_AES_) for symmetric encryption which has great support for acceleration in hardware and thus allows performance to generally be negligibly affected.
| `tls_versions`   | `TLSv1.2` |
Since we control the entire cluster we can enforce the latest TLS standard without any concern for backwards compatibility.
It has no known security vulnerabilities and uses the most modern algorithms for key exchanges, etc.
|===

In the following example we will create and configure an SSL policy that we will use in our cluster.

.Configure the cluster SSL policy
====
In this example we assume that the directory structure has been created, and certificate files have been installed, as per the previous example.

We add the following content to our _neo4j.conf_ file:

[source, properties]
----
dbms.ssl.policy.cluster.enabled=true
dbms.ssl.policy.cluster.tls_versions=TLSv1.2
dbms.ssl.policy.cluster.ciphers=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
dbms.ssl.policy.cluster.client_auth=REQUIRE
----

Any user data communicated between instances will now be secured.
Please note that an instance which is not correctly setup would not be able to communicate with the others.
====

Note that the policy must be configured on every server with the same settings.
The actual cryptographic objects installed will be mostly different since they do not share the same private keys and corresponding certificates.
The trusted CA certificate will be shared however.


[[causal-clustering-intra-cluster-encryption-validate]]
=== Validate the secure operation of the cluster

To make sure that everything is secured as intended it makes sense to validate using external tooling such as, for example, the open source assessment tools `nmap` or `OpenSSL`.

.Validate the secure operation of the cluster
====

In this example we will use the `nmap` tool to validate the secure operation of our cluster.
A simple test to perform is a cipher enumeration using the following command:

[source, shell]
----
nmap --script ssl-enum-ciphers -p <port> <hostname>
----

The hostname and port have to be adjusted according to our configuration.
This can prove that TLS is in fact enabled and that the only the intended cipher suites are enabled.
All servers and all applicable ports should be tested.
====

For testing purposes we could also attempt to utilize a separate testing instance of Neo4j which, for example, has an untrusted certificate in place.
The expected result of this test is that the test server is not able to participate in replication of user data.
The debug logs will generally indicate an issue by printing an SSL or certificate-related exception.
