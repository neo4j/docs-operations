:description: How to change your Neo4j configuration while Neo4j is running, and which settings can be changed.
[role=enterprise-edition]
[[dynamic-settings]]
= Dynamic settings

Neo4j Enterprise Edition supports changing some configuration settings at runtime, without restarting the service.

[NOTE]
====
Changes to the configuration at runtime are not persisted.
To avoid losing changes when restarting Neo4j, make sure you update xref:configuration/file-locations.adoc[_neo4j.conf_] as well.

In a clustered environment, `CALL dbms.setConfigValue` affects only the cluster member it is run against, and it is not propagated to other members.
If you want to change the configuration settings on all cluster members, you have to run the procedure against each of them and update their _neo4j.conf_ file.
====


[[dynamic-settings-discover]]
== Discover dynamic settings

Use the procedure `dbms.listConfig()` to discover which configuration values can be dynamically updated, or consult xref:configuration/dynamic-settings.adoc#dynamic-settings-reference[Dynamic settings reference].

.Discover dynamic settings
====

[source, cypher]
----
CALL dbms.listConfig()
YIELD name, dynamic
WHERE dynamic
RETURN name
ORDER BY name
LIMIT 4;
----

[queryresult]
----
+----------------------------------------------+
| name                                         |
+----------------------------------------------+
| "db.checkpoint.iops.limit"                 |
| "db.logs.query.enabled"                    |
+----------------------------------------------+
4 rows
----

====


[[dynamic-settings-procedure]]
== Update dynamic settings

An xref:authentication-authorization/terminology.adoc#term-administrator[administrator] is able to change some configuration settings at runtime, without restarting the service.

*Syntax:*

`CALL dbms.setConfigValue(_setting_, _value_)`

*Returns:*

Nothing on success.

*Exceptions:*

|===
| Unknown or invalid setting name.
| The setting is not dynamic and can not be changed at runtime.
| Invalid setting value.
|===

The following example shows how to dynamically enable query logging.

.Set a config value
====
[source, cypher]
----
CALL dbms.setConfigValue('db.logs.query.enabled', 'info')
----
====

If an invalid value is passed, the procedure will show a message to that effect.

.Try to set invalid config value
====
[source, cypher]
----
CALL dbms.setConfigValue('db.logs.query.enabled', 'yes')
----

[queryresult]
----
Failed to invoke procedure `dbms.setConfigValue`: Caused by: org.neo4j.graphdb.config.InvalidSettingException: Bad value 'yes' for setting 'db.logs.query.enabled': 'yes' not one of [OFF, INFO, VERBOSE]
----
====

To reset a config value to its default, pass an empty string as the _value_ argument.

.Reset a config value to default
====
[source, cypher]
----
CALL dbms.setConfigValue('db.logs.query.enabled', '')
----
====


[[dynamic-settings-reference]]
== Dynamic settings reference

//include::partial$/neo4j-config/dynamic-settings.adoc[tags=reference-dynamic-settings-reference]
//
//This file can be found in:
//neo4j-documentation/config-docs/target/docs/ops/dynamic-settings.adoc

[options="header"]
|===
|Name|Description
|xref:reference/configuration-settings.adoc#config_db.checkpoint.iops.limit[db.checkpoint.iops.limit]|Limit the number of IOs the background checkpoint process will consume per second.
|xref:reference/configuration-settings.adoc#config_db.format[db.format]|Database format.
|xref:reference/configuration-settings.adoc#config_db.lock.acquisition.timeout[db.lock.acquisition.timeout]|The maximum time interval within which lock should be acquired.
|xref:reference/configuration-settings.adoc#config_db.logs.query.early_raw_logging_enabled[db.logs.query.early_raw_logging_enabled]|Log query text and parameters without obfuscating passwords.
|xref:reference/configuration-settings.adoc#config_db.logs.query.enabled[db.logs.query.enabled]|Log executed queries.
|xref:reference/configuration-settings.adoc#config_db.logs.query.max_parameter_length[db.logs.query.max_parameter_length]|Sets a maximum character length use for each parameter in the log.
|xref:reference/configuration-settings.adoc#config_db.logs.query.obfuscate_literals[db.logs.query.obfuscate_literals]|Obfuscates all literals of the query before writing to the log.
|xref:reference/configuration-settings.adoc#config_db.logs.query.parameter_logging_enabled[db.logs.query.parameter_logging_enabled]|Log parameters for the executed queries being logged.
|xref:reference/configuration-settings.adoc#config_db.logs.query.plan_description_enabled[db.logs.query.plan_description_enabled]|Log query plan description table, useful for debugging purposes.
|xref:reference/configuration-settings.adoc#config_db.logs.query.threshold[db.logs.query.threshold]|If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO.
|xref:reference/configuration-settings.adoc#config_db.logs.query.transaction.enabled[db.logs.query.transaction.enabled]|Log the start and end of a transaction.
|xref:reference/configuration-settings.adoc#config_db.logs.query.transaction.threshold[db.logs.query.transaction.threshold]|If the transaction is open for more time than this threshold, the transaction is logged once completed - provided transaction logging (db.logs.query.transaction.enabled) is set to `INFO`.
|xref:reference/configuration-settings.adoc#config_db.memory.transaction.max[db.memory.transaction.max]|Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|xref:reference/configuration-settings.adoc#config_db.memory.transaction.total.max[db.memory.transaction.total.max]|Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|xref:reference/configuration-settings.adoc#config_db.track_query_cpu_time[db.track_query_cpu_time]|Enables or disables tracking of how much time a query spends actively executing on the CPU.
|xref:reference/configuration-settings.adoc#config_db.transaction.bookmark_ready_timeout[db.transaction.bookmark_ready_timeout]|The maximum amount of time to wait for the database state represented by the bookmark.
|xref:reference/configuration-settings.adoc#config_db.transaction.concurrent.maximum[db.transaction.concurrent.maximum]|The maximum number of concurrently running transactions.
|xref:reference/configuration-settings.adoc#config_db.transaction.sampling.percentage[db.transaction.sampling.percentage]|Transaction sampling percentage.
|xref:reference/configuration-settings.adoc#config_db.transaction.timeout[db.transaction.timeout]|The maximum time interval of a transaction within which it should be completed.
|xref:reference/configuration-settings.adoc#config_db.transaction.tracing.level[db.transaction.tracing.level]|Transaction creation tracing level.
|xref:reference/configuration-settings.adoc#config_db.tx_log.preallocate[db.tx_log.preallocate]|Specify if Neo4j should try to preallocate logical log file in advance.
|xref:reference/configuration-settings.adoc#config_db.tx_log.rotation.retention_policy[db.tx_log.rotation.retention_policy]|Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
|xref:reference/configuration-settings.adoc#config_db.tx_log.rotation.size[db.tx_log.rotation.size]|Specifies at which file size the logical log will auto-rotate.
|xref:configuration/dynamic-settings.adoc#config_dbms.cluster.num_primaries[dbms.cluster.num_primaries]|Default number of primaries in Large Cluster.
|xref:configuration/dynamic-settings.adoc#config_dbms.cluster.num_secondaries[dbms.cluster.num_secondaries]|Default number of secondaries in Large Cluster.
|xref:reference/configuration-settings.adoc#config_dbms.cypher.render_plan_description[dbms.cypher.render_plan_description]|If set to `true` a textual representation of the plan description will be rendered on the server for all queries running with `EXPLAIN` or `PROFILE`.
|xref:reference/configuration-settings.adoc#config_server.databases.default_to_read_only[server.databases.default_to_read_only]|Whether or not any database on this instance are read_only by default.
|xref:reference/configuration-settings.adoc#config_server.databases.read_only[server.databases.read_only]|List of databases for which to prevent write queries.
|xref:configuration/dynamic-settings.adoc#config_dbms.databases.writable[dbms.databases.writable]|List of databases for which to allow write queries.
|xref:reference/configuration-settings.adoc#config_dbms.memory.transaction.total.max[dbms.memory.transaction.total.max]|Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|xref:reference/configuration-settings.adoc#config_dbms.routing.client_side.enforce_for_domains[dbms.routing.client_side.enforce_for_domains]|Always use client side routing (regardless of the default router) for neo4j:// protocol connections to these domains.
|xref:reference/configuration-settings.adoc#config_dbms.routing.reads_on_writers_enabled[dbms.routing.reads_on_writers_enabled]|Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authentication.attribute[dbms.security.ldap.authentication.attribute]|The attribute to use when looking up users.
Using this setting requires `dbms.security.ldap.authentication.search_for_attribute` to be true and thus `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` to be configured.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authentication.user_dn_template[dbms.security.ldap.authentication.user_dn_template]|LDAP user DN template.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authorization.access_permitted_group[dbms.security.ldap.authorization.access_permitted_group]|The LDAP group to which a user must belong to get any access to the system.Set this to restrict access to a subset of LDAP users belonging to a particular group.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authorization.group_membership_attributes[dbms.security.ldap.authorization.group_membership_attributes]|A list of attribute names of a user object that contains groups to be used for mapping roles when LDAP authorization is enabled. This setting is ignored when `dbms.ldap_authorization_nested_groups_enabled` is `true`.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authorization.nested_groups_enabled[dbms.security.ldap.authorization.nested_groups_enabled]|This setting determines whether multiple LDAP search results will be processed (as required for the lookup of nested groups). If set to `true`, instead of using attributes on the user object to determine group membership (as specified by `dbms.security.ldap.authorization.group_membership_attributes`), the `user` object will only be used to determine the user's Distinguished Name. This will subsequently be used with `dbms.security.ldap.authorization.nested_groups_search_filter` in order to perform a nested group search. The Distinguished Names of the resultant group search results will be used to determine roles.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authorization.nested_groups_search_filter[dbms.security.ldap.authorization.nested_groups_search_filter]|The search template that will be used to find the nested groups which the user is a member of. The filter should contain the placeholder token `{0}`, which will be substituted with the user's Distinguished Name (found for the specified user principle by using `dbms.security.ldap.authorization.user_search_filter`). The default value specifies Active Directory's LDAP_MATCHING_RULE_IN_CHAIN (aka 1.2.840.113556.1.4.1941) implementation which will walk the ancestry of group membership for the specified user.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authorization.group_to_role_mapping[dbms.security.ldap.authorization.group_to_role_mapping]|An authorization mapping from LDAP group names to Neo4j role names.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authorization.user_search_base[dbms.security.ldap.authorization.user_search_base]|The name of the base object or named context to search for user objects when LDAP authorization is enabled.
|xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authorization.user_search_filter[dbms.security.ldap.authorization.user_search_filter]|The LDAP search filter to search for a user principal when LDAP authorization is enabled.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.audience[dbms.security.oidc.<provider>.audience]|Expected values of the Audience (aud) claim in the id token.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.auth_endpoint[dbms.security.oidc.<provider>.auth_endpoint]|The OIDC authorization endpoint.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.auth_flow[dbms.security.oidc.<provider>.auth_flow]|The OIDC flow to use.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.auth_params[dbms.security.oidc.<provider>.auth_params]|Optional additional parameters that the auth endpoint requires.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.authorization.group_to_role_mapping[dbms.security.oidc.<provider>.authorization.group_to_role_mapping]|An authorization mapping from IdP group names to Neo4j role names.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.claims.groups[dbms.security.oidc.<provider>.claims.groups]|The claim to use as the list of groups in Neo4j.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.claims.username[dbms.security.oidc.<provider>.claims.username]|The claim to use as the username in Neo4j.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.client_id[dbms.security.oidc.<provider>.client_id]|Client id needed if token contains multiple Audience (aud) claims.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.config[dbms.security.oidc.<provider>.config]|The accepted values (all optional) are: `principal`, `code_challenge_method`, `token_type_principal`, `token_type_authentication`, and `implicit_flow_requires_nonce`.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.get_groups_from_user_info[dbms.security.oidc.<provider>.get_groups_from_user_info]|When turned on, Neo4j gets the groups from the provider user info endpoint.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.get_username_from_user_info[dbms.security.oidc.<provider>.get_username_from_user_info]|When turned on, Neo4j gets the username from the provider user info endpoint.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.issuer[dbms.security.oidc.<provider>.issuer]|The expected value of the iss claim in the id token.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.jwks_uri[dbms.security.oidc.<provider>.jwks_uri]|The location of the JWK public key set for the identity provider.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.params[dbms.security.oidc.<provider>.params]|The map is a semicolon separated list of key-value pairs.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.token_endpoint[dbms.security.oidc.<provider>.token_endpoint]|The OIDC token endpoint.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.token_params[dbms.security.oidc.<provider>.token_params]|Optional query parameters that the token endpoint requires.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.user_info_uri[dbms.security.oidc.<provider>.user_info_uri]|The identity providers user info uri.
|xref:reference/configuration-settings.adoc#config_dbms.security.oidc.-provider-.well_known_discovery_uri[dbms.security.oidc.<provider>.well_known_discovery_uri]|The 'well known' OpenID Connect Discovery endpoint used to fetch identity provider settings.
|xref:configuration/dynamic-settings.adoc#config_dbms.dbms.security.key.name[dbms.dbms.security.key.name]|Name of the 256 length AES encryption key, which is used for the symmetric encryption.
|xref:configuration/dynamic-settings.adoc#config_dbms.dbms.security.keystore.password[dbms.dbms.security.keystore.password]|Password for accessing the keystore holding a 256 length AES encryption key, which is used for the symmetric encryption.
|xref:configuration/dynamic-settings.adoc#config_dbms.dbms.security.keystore.path[dbms.dbms.security.keystore.path]|Location of the keystore holding a 256 length AES encryption key, which is used for the symmetric encryption of secrets held in system database.
|xref:reference/configuration-settings.adoc#config_server.cluster.catchup.connect_randomly_to_server_group[server.cluster.catchup.connect_randomly_to_server_group]|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
|xref:reference/configuration-settings.adoc#config_server.groups[server.groups]|A list of group names for the server used when configuring load balancing and replication policies.
|xref:reference/configuration-settings.adoc#config_server.memory.pagecache.flush.buffer.enabled[server.memory.pagecache.flush.buffer.enabled]|Page cache can be configured to use a temporal buffer for flushing purposes.
|xref:reference/configuration-settings.adoc#config_server.memory.pagecache.flush.buffer.size_in_pages[server.memory.pagecache.flush.buffer.size_in_pages]|Page cache can be configured to use a temporal buffer for flushing purposes.
|===

[[config_db.checkpoint.iops.limit]]
.db.checkpoint.iops.limit
[cols="<1s,<4"]
|===
|Description
a|Limit the number of IOs the background checkpoint process will consume per second. This setting is advisory, is ignored in Neo4j Community Edition, and is followed to best effort in Enterprise Edition. An IO is in this case a 8 KiB (mostly sequential) write. Limiting the write IO in this way will leave more bandwidth in the IO subsystem to service random-read IOs, which is important for the response time of queries when the database cannot fit entirely in memory. The only drawback of this setting is that longer checkpoint times may lead to slightly longer recovery times in case of a database or system crash. A lower number means lower IO pressure, and consequently longer checkpoint times. Set this to -1 to disable the IOPS limit and remove the limitation entirely; this will let the checkpointer flush data as fast as the hardware will go. Removing the setting, or commenting it out, will set the default value of 600.
|Valid values
a|db.checkpoint.iops.limit, an integer
|Dynamic a|true
|Default value
m|+++600+++
|===

[[config_db.format]]
.db.format
[cols="<1s,<4"]
|===
|Description
a|Database format. This is the format that will be used for new databases. Valid values are `standard`, `aligned`, or `high_limit`.The `aligned` format is essentially the `standard` format with some minimal padding at the end of pages such that a single record will never cross a page boundary. The `high_limit` format is available for Enterprise Edition only. It is required if you have a graph that is larger than 34 billion nodes, 34 billion relationships, or 68 billion properties.
|Valid values
a|db.format, a string
|Dynamic a|true
|Default value
m|+++aligned+++
|===

[[config_db.lock.acquisition.timeout]]
.db.lock.acquisition.timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum time interval within which lock should be acquired. Zero (default) means timeout is disabled.
|Valid values
a|db.lock.acquisition.timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_db.logs.query.early_raw_logging_enabled]]
.db.logs.query.early_raw_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log query text and parameters without obfuscating passwords. This allows queries to be logged earlier before parsing starts.
|Valid values
a|db.logs.query.early_raw_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_db.logs.query.enabled]]
.db.logs.query.enabled
[cols="<1s,<4"]
|===
|Description
a|Log executed queries. Valid values are `OFF`, `INFO`, or `VERBOSE`.

`OFF`::  no logging.
`INFO`:: log queries at the end of execution, that take longer than the configured threshold, `xref:reference/configuration-settings.adoc#config_db.logs.query.threshold[db.logs.query.threshold]`.
`VERBOSE`:: log queries at the start and end of execution, regardless of `xref:reference/configuration-settings.adoc#config_db.logs.query.threshold[db.logs.query.threshold]`.

This feature is available in the Neo4j Enterprise Edition.
|Valid values
a|db.logs.query.enabled, one of [OFF, INFO, VERBOSE]
|Dynamic a|true
|Default value
m|+++VERBOSE+++
|===

[[config_db.logs.query.max_parameter_length]]
.db.logs.query.max_parameter_length
[cols="<1s,<4"]
|===
|Description
a|Sets a maximum character length use for each parameter in the log. This only takes effect if `xref:reference/configuration-settings.adoc#config_db.logs.query.parameter_logging_enabled[db.logs.query.parameter_logging_enabled] = true`.
|Valid values
a|db.logs.query.max_parameter_length, an integer
|Dynamic a|true
|Default value
m|+++2147483647+++
|===

[[config_db.logs.query.obfuscate_literals]]
.db.logs.query.obfuscate_literals
[cols="<1s,<4"]
|===
|Description
a|Obfuscates all literals of the query before writing to the log. Note that node labels, relationship types and map property keys are still shown. Changing the setting will not affect queries that are cached. So, if you want the switch to have immediate effect, you must also call `CALL db.clearQueryCaches()`.
|Valid values
a|db.logs.query.obfuscate_literals, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_db.logs.query.parameter_logging_enabled]]
.db.logs.query.parameter_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log parameters for the executed queries being logged.
|Valid values
a|db.logs.query.parameter_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_db.logs.query.plan_description_enabled]]
.db.logs.query.plan_description_enabled
[cols="<1s,<4"]
|===
|Description
a|Log query plan description table, useful for debugging purposes.
|Valid values
a|db.logs.query.plan_description_enabled, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_db.logs.query.threshold]]
.db.logs.query.threshold
[cols="<1s,<4"]
|===
|Description
a|If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO. Defaults to 0 seconds, that is all queries are logged.
|Valid values
a|db.logs.query.threshold, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_db.logs.query.transaction.enabled]]
.db.logs.query.transaction.enabled
[cols="<1s,<4"]
|===
|Description
a|Log the start and end of a transaction. Valid values are 'OFF', 'INFO', or 'VERBOSE'.
OFF:  no logging.
INFO: log start and end of transactions that take longer than the configured threshold, xref:reference/configuration-settings.adoc#config_db.logs.query.transaction.threshold[db.logs.query.transaction.threshold].
VERBOSE: log start and end of all transactions.
This feature is available in the Neo4j Enterprise Edition.
|Valid values
a|db.logs.query.transaction.enabled, one of [OFF, INFO, VERBOSE]
|Dynamic a|true
|Default value
m|+++OFF+++
|===

[[config_db.logs.query.transaction.threshold]]
.db.logs.query.transaction.threshold
[cols="<1s,<4"]
|===
|Description
a|If the transaction is open for more time than this threshold, the transaction is logged once completed - provided transaction logging (xref:reference/configuration-settings.adoc#config_db.logs.query.transaction.enabled[db.logs.query.transaction.enabled]) is set to `INFO`. Defaults to 0 seconds (all transactions are logged).
|Valid values
a|db.logs.query.transaction.threshold, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_db.memory.transaction.max]]
.db.memory.transaction.max
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'largest possible value'. When `server.cluster.initial_mode_constraint=CORE` or `server.cluster.initial_mode_constraint=SINGLE` and `dbms.clustering.enable=true` this is '2G', in other cases this is 'unlimited'.
|Valid values
a|db.memory.transaction.max, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `1.00MiB` or is `0B` and depends on server.cluster.initial_mode_constraint. If server.cluster.initial_mode_constraint one of `[CORE]` then it is maximum `2.00GiB` otherwise it depends on server.cluster.initial_mode_constraint. If server.cluster.initial_mode_constraint one of `[SINGLE]` then it depends on dbms.clustering.enable. If dbms.clustering.enable is `true` then it is maximum `2.00GiB` otherwise it is unconstrained. otherwise it is unconstrained..
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_db.memory.transaction.total.max]]
.db.memory.transaction.total.max
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'unlimited'.
|Valid values
a|db.memory.transaction.total.max, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `10.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_db.track_query_cpu_time]]
.db.track_query_cpu_time
[cols="<1s,<4"]
|===
|Description
a|Enables or disables tracking of how much time a query spends actively executing on the CPU. Calling `SHOW TRANSACTIONS` will display the time. This information is also available in the query log by default.
|Valid values
a|db.track_query_cpu_time, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_db.transaction.bookmark_ready_timeout]]
.db.transaction.bookmark_ready_timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum amount of time to wait for the database state represented by the bookmark.
|Valid values
a|db.transaction.bookmark_ready_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`) which is minimum `1s`
|Dynamic a|true
|Default value
m|+++30s+++
|===

[[config_db.transaction.concurrent.maximum]]
.db.transaction.concurrent.maximum
[cols="<1s,<4"]
|===
|Description
a|The maximum number of concurrently running transactions. If set to 0, limit is disabled.
|Valid values
a|db.transaction.concurrent.maximum, an integer
|Dynamic a|true
|Default value
m|+++1000+++
|===

[[config_db.transaction.sampling.percentage]]
.db.transaction.sampling.percentage
[cols="<1s,<4"]
|===
|Description
a|Transaction sampling percentage.
|Valid values
a|db.transaction.sampling.percentage, an integer which is in the range `1` to `100`
|Dynamic a|true
|Default value
m|+++5+++
|===

[[config_db.transaction.timeout]]
.db.transaction.timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum time interval of a transaction within which it should be completed.
|Valid values
a|db.transaction.timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_db.transaction.tracing.level]]
.db.transaction.tracing.level
[cols="<1s,<4"]
|===
|Description
a|Transaction creation tracing level.
|Valid values
a|db.transaction.tracing.level, one of [DISABLED, SAMPLE, ALL]
|Dynamic a|true
|Default value
m|+++DISABLED+++
|===

[[config_db.tx_log.preallocate]]
.db.tx_log.preallocate
[cols="<1s,<4"]
|===
|Description
a|Specify if Neo4j should try to preallocate logical log file in advance.
|Valid values
a|db.tx_log.preallocate, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_db.tx_log.rotation.retention_policy]]
.db.tx_log.rotation.retention_policy
[cols="<1s,<4"]
|===
|Description
a|Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
|Valid values
a|db.tx_log.rotation.retention_policy, a string which matches the pattern `^(true{vbar}keep_all{vbar}false{vbar}keep_none{vbar}(\d+[KkMmGg]?( (files{vbar}size{vbar}txs{vbar}entries{vbar}hours{vbar}days))))$` (Must be `true` or `keep_all`, `false` or `keep_none`, or of format `<number><optional unit> <type>`. Valid units are `K`, `M` and `G`. Valid types are `files`, `size`, `txs`, `entries`, `hours` and `days`. For example, `100M size` will limit logical log space on disk to 100MB per database,and `200K txs` will limit the number of transactions kept to 200 000 per database.)
|Dynamic a|true
|Default value
m|+++7 days+++
|===

[[config_db.tx_log.rotation.size]]
.db.tx_log.rotation.size
[cols="<1s,<4"]
|===
|Description
a|Specifies at which file size the logical log will auto-rotate. Minimum accepted value is 128 KiB.
|Valid values
a|db.tx_log.rotation.size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `128.00KiB`
|Dynamic a|true
|Default value
m|+++250.00MiB+++
|===

[[config_dbms.cluster.num_primaries]]
.dbms.cluster.num_primaries
[cols="<1s,<4"]
|===
|Description
a|Default number of primaries in Large Cluster.
|Valid values
a|dbms.cluster.num_primaries, an integer which is minimum `2` and is maximum `11`
|Dynamic a|true
|Default value
m|+++3+++
|===

[[config_dbms.cluster.num_secondaries]]
.dbms.cluster.num_secondaries
[cols="<1s,<4"]
|===
|Description
a|Default number of secondaries in Large Cluster.
|Valid values
a|dbms.cluster.num_secondaries, an integer which is minimum `0` and is maximum `20`
|Dynamic a|true
|Default value
m|+++0+++
|===

[[config_dbms.cypher.render_plan_description]]
.dbms.cypher.render_plan_description
[cols="<1s,<4"]
|===
|Description
a|If set to `true` a textual representation of the plan description will be rendered on the server for all queries running with `EXPLAIN` or `PROFILE`. This allows clients such as the neo4j browser and Cypher shell to show a more detailed plan description.
|Valid values
a|dbms.cypher.render_plan_description, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_server.databases.default_to_read_only]]
.server.databases.default_to_read_only
[cols="<1s,<4"]
|===
|Description
a|Whether or not any database on this instance are read_only by default. If false, individual databases may be marked as read_only using dbms.database.read_only. If true, individual databases may be marked as writable using xref:configuration/dynamic-settings.adoc#config_dbms.databases.writable[dbms.databases.writable].
|Valid values
a|server.databases.default_to_read_only, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_server.databases.read_only]]
.server.databases.read_only
[cols="<1s,<4"]
|===
|Description
a|List of databases for which to prevent write queries. Databases not included in this list maybe read_only anyway depending upon the value of xref:reference/configuration-settings.adoc#config_server.databases.default_to_read_only[server.databases.default_to_read_only].
|Valid values
a|server.databases.read_only, a ',' separated set with elements of type 'A valid database name containing only alphabetic characters, numbers, dots and dashes with a length between 3 and 63 characters, starting with an alphabetic character but not with the name 'system''. which Value 'system' can't be included in read only databases collection!
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.databases.writable]]
.dbms.databases.writable
[cols="<1s,<4"]
|===
|Description
a|List of databases for which to allow write queries. Databases not included in this list will allow write queries anyway, unless xref:reference/configuration-settings.adoc#config_server.databases.default_to_read_only[server.databases.default_to_read_only] is set to true.
|Valid values
a|dbms.databases.writable, a ',' separated set with elements of type 'A valid database name containing only alphabetic characters, numbers, dots and dashes with a length between 3 and 63 characters, starting with an alphabetic character but not with the name 'system''.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.memory.transaction.total.max]]
.dbms.memory.transaction.total.max
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'unlimited'.
|Valid values
a|dbms.memory.transaction.total.max, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `10.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_dbms.routing.client_side.enforce_for_domains]]
.dbms.routing.client_side.enforce_for_domains
[cols="<1s,<4"]
|===
|Description
a|Always use client side routing (regardless of the default router) for neo4j:// protocol connections to these domains. A comma separated list of domains. Wildcards (*) are supported.
|Valid values
a|dbms.routing.client_side.enforce_for_domains, a ',' separated set with elements of type 'a string'.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.routing.reads_on_writers_enabled]]
.dbms.routing.reads_on_writers_enabled
[cols="<1s,<4"]
|===
|Description
a|Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers. Note: leader is returned as read endpoint if no other member is present all.
|Valid values
a|dbms.routing.reads_on_writers_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.security.ldap.authentication.attribute]]
.dbms.security.ldap.authentication.attribute
[cols="<1s,<4"]
|===
|Description
a|The attribute to use when looking up users.
Using this setting requires `dbms.security.ldap.authentication.search_for_attribute` to be true and thus `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` to be configured.
|Valid values
a|dbms.security.ldap.authentication.attribute, a string which matches the pattern `[A-Za-z0-9-]*` (has to be a valid LDAP attribute name, only containing letters [A-Za-z], digits [0-9] and hyphens [-].)
|Dynamic a|true
|Default value
m|+++samaccountname+++
|===

[[config_dbms.security.ldap.authentication.user_dn_template]]
.dbms.security.ldap.authentication.user_dn_template
[cols="<1s,<4"]
|===
|Description
a|LDAP user DN template. An LDAP object is referenced by its distinguished name (DN), and a user DN is an LDAP fully-qualified unique user identifier. This setting is used to generate an LDAP DN that conforms with the LDAP directory's schema from the user principal that is submitted with the authentication token when logging in. The special token {0} is a placeholder where the user principal will be substituted into the DN string.
|Valid values
a|dbms.security.ldap.authentication.user_dn_template, a string which must contain '{0}' to understand where to insert the runtime authentication principal.
|Dynamic a|true
|Default value
m|+++uid={0},ou=users,dc=example,dc=com+++
|===

[[config_dbms.security.ldap.authorization.access_permitted_group]]
.dbms.security.ldap.authorization.access_permitted_group
[cols="<1s,<4"]
|===
|Description
a|The LDAP group to which a user must belong to get any access to the system.Set this to restrict access to a subset of LDAP users belonging to a particular group. If this is not set, any user to successfully authenticate via LDAP will have access to the PUBLIC role and any other roles assigned to them via xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authorization.group_to_role_mapping[dbms.security.ldap.authorization.group_to_role_mapping].
|Valid values
a|dbms.security.ldap.authorization.access_permitted_group, a string
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.security.ldap.authorization.group_membership_attributes]]
.dbms.security.ldap.authorization.group_membership_attributes
[cols="<1s,<4"]
|===
|Description
a|A list of attribute names of a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled.
This setting is ignored when `dbms.ldap_authorization_nested_groups_enabled` is `true`.
|Valid values
a|dbms.security.ldap.authorization.group_membership_attributes, a ',' separated list with elements of type 'a string'. which Can not be empty
|Dynamic a|true
|Default value
m|+++memberOf+++
|===

[[config_dbms.security.ldap.authorization.nested_groups_enabled]]
.dbms.security.ldap.authorization.nested_groups_enabled
[cols="<1s,<4"]
|===
|Description
a|This setting determines whether multiple LDAP search results will be processed (as required for the lookup of nested groups). If set to `true`, instead of using attributes of the user object to determine group membership (as specified by `dbms.security.ldap.authorization.group_membership_attributes`), the `user` object will only be used to determine the user's Distinguished Name. This will subsequently be used with `dbms.security.ldap.authorization.nested_groups_search_filter` in order to perform a nested group search. The Distinguished Names of the resultant group search results will be used to determine roles.
|Valid values
a|dbms.security.ldap.authorization.nested_groups_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.security.ldap.authorization.nested_groups_search_filter]]
.dbms.security.ldap.authorization.nested_groups_search_filter
[cols="<1s,<4"]
|===
|Description
a|The search template that will be used to find the nested groups which the user is a member of.
The filter should contain the placeholder token `{0}`, which will be substituted with the user's Distinguished Name (found for the specified user principle by using `dbms.security.ldap.authorization.user_search_filter`).
The default value specifies Active Directory's `LDAP_MATCHING_RULE_IN_CHAIN` (aka 1.2.840.113556.1.4.1941) implementation which will walk the ancestry of group membership for the specified user.
|Valid values
a|`dbms.security.ldap.authorization.nested_groups_search_filter`, a string which must contain `{0}` to understand where to insert the user's Distinguished Name.
|Dynamic a|true
|Default value
m|+++(&(objectclass=group)(member:1.2.840.113556.1.4.1941:={0}))+++
|===

[[config_dbms.security.ldap.authorization.group_to_role_mapping]]
.dbms.security.ldap.authorization.group_to_role_mapping
[cols="<1s,<4"]
|===
|Description
a|An authorization mapping from LDAP group names to Neo4j role names. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the LDAP group name and the value is a comma separated list of corresponding role names. For example: group1=role1;group2=role2;group3=role3,role4,role5
You could also use whitespaces and quotes around group names to make this mapping more readable, for example:
----
`dbms.security.ldap.authorization.group_to_role_mapping`=\
         "cn=Neo4j Read Only,cn=users,dc=example,dc=com"      = reader;    \
         "cn=Neo4j Read-Write,cn=users,dc=example,dc=com"     = publisher; \
         "cn=Neo4j Schema Manager,cn=users,dc=example,dc=com" = architect; \
         "cn=Neo4j Administrator,cn=users,dc=example,dc=com"  = admin
----
|Valid values
a|dbms.security.ldap.authorization.group_to_role_mapping, a string which must be semicolon separated list of key-value pairs or empty
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.security.ldap.authorization.user_search_base]]
.dbms.security.ldap.authorization.user_search_base
[cols="<1s,<4"]
|===
|Description
a|The name of the base object or named context to search for user objects when LDAP authorization is enabled. A common case is that this matches the last part of `xref:reference/configuration-settings.adoc#config_dbms.security.ldap.authentication.user_dn_template[dbms.security.ldap.authentication.user_dn_template]`.
|Valid values
a|dbms.security.ldap.authorization.user_search_base, a string which Can not be empty
|Dynamic a|true
|Default value
m|+++ou=users,dc=example,dc=com+++
|===

[[config_dbms.security.ldap.authorization.user_search_filter]]
.dbms.security.ldap.authorization.user_search_filter
[cols="<1s,<4"]
|===
|Description
a|The LDAP search filter to search for a user principal when LDAP authorization is enabled. The filter should contain the placeholder token {0} which will be substituted for the user principal.
|Valid values
a|dbms.security.ldap.authorization.user_search_filter, a string
|Dynamic a|true
|Default value
m|+++(&(objectClass=*)(uid={0}))+++
|===

[[config_dbms.security.oidc.-provider-.audience]]
.dbms.security.oidc.<provider>.audience
[cols="<1s,<4"]
|===
|Description
a|Expected values of the Audience (aud) claim in the id token.
|Valid values
a|dbms.security.oidc.<provider>.audience, a ',' separated list with elements of type 'a string'. which Can not be empty
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.auth_endpoint]]
.dbms.security.oidc.<provider>.auth_endpoint
[cols="<1s,<4"]
|===
|Description
a|The OIDC authorization endpoint. If this is not supplied Neo4j will attempt to discover it from the well_known_discovery_uri.
|Valid values
a|dbms.security.oidc.<provider>.auth_endpoint, a URI
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.auth_flow]]
.dbms.security.oidc.<provider>.auth_flow
[cols="<1s,<4"]
|===
|Description
a|The OIDC flow to use. This is exposed to clients via the discovery endpoint. Supported values are `pkce` and `implicit`
|Valid values
a|dbms.security.oidc.<provider>.auth_flow, one of [PKCE, IMPLICIT]
|Dynamic a|true
|Default value
m|+++PKCE+++
|===

[[config_dbms.security.oidc.-provider-.auth_params]]
.dbms.security.oidc.<provider>.auth_params
[cols="<1s,<4"]
|===
|Description
a|Optional additional parameters that the auth endpoint requires. Please use params instead. The map is a semicolon separated list of key-value pairs. For example: `k1=v1;k2=v2`.
|Valid values
a|dbms.security.oidc.<provider>.auth_params, A simple key value map pattern `k1=v1;k2=v2`.
|Dynamic a|true
|Default value
m|+++{}+++
|Deprecated
a|The `dbms.security.oidc.<provider>.auth_params` configuration setting has been deprecated.
|===

[[config_dbms.security.oidc.-provider-.authorization.group_to_role_mapping]]
.dbms.security.oidc.<provider>.authorization.group_to_role_mapping
[cols="<1s,<4"]
|===
|Description
a|An authorization mapping from IdP group names to Neo4j role names. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the IdP group name and the value is a comma separated list of corresponding role names. For example: group1=role1;group2=role2;group3=role3,role4,role5
You could also use whitespaces and quotes around group names to make this mapping more readable, for example:
----
dbms.security.oidc.<provider>.authorization.group_to_role_mapping=\
         "Neo4j Read Only"      = reader;    \
         "Neo4j Read-Write"     = publisher; \
         "Neo4j Schema Manager" = architect; \
         "Neo4j Administrator"  = admin
----
|Valid values
a|dbms.security.oidc.<provider>.authorization.group_to_role_mapping, a string which must be semicolon separated list of key-value pairs or empty
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.claims.groups]]
.dbms.security.oidc.<provider>.claims.groups
[cols="<1s,<4"]
|===
|Description
a|The claim to use as the list of groups in Neo4j. These could be Neo4J roles directly, or can be mapped using dbms.security.oidc.<provider>.authorization.group_to_role_mapping.
|Valid values
a|dbms.security.oidc.<provider>.claims.groups, a string
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.claims.username]]
.dbms.security.oidc.<provider>.claims.username
[cols="<1s,<4"]
|===
|Description
a|The claim to use as the username in Neo4j. This would typically be sub, but in some situations it may be be desirable to use something else such as email.
|Valid values
a|dbms.security.oidc.<provider>.claims.username, a string
|Dynamic a|true
|Default value
m|+++sub+++
|===

[[config_dbms.security.oidc.-provider-.client_id]]
.dbms.security.oidc.<provider>.client_id
[cols="<1s,<4"]
|===
|Description
a|Client id needed if token contains multiple Audience (aud) claims.
|Valid values
a|dbms.security.oidc.<provider>.client_id, a string
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.config]]
.dbms.security.oidc.<provider>.config
[cols="<1s,<4"]
|===
|Description
a|The accepted values (all optional) are:
----
  principal: in which JWT claim the user's email address is specified,
             email is the default. This is the value that will be shown in browser.
  code_challenge_method: default is `S256` and it's the only supported method
                         at this moment. This setting applies only for pkce auth flow
  token_type_principal: the options are almost always either access_token,
                        which is the default, or id_token.
  token_type_authentication: the options are almost always either access_token,
                             which is the default, or id_token.
  implicit_flow_requires_nonce: true or false. Defaults to false.
----
|Valid values
a|dbms.security.oidc.<provider>.config, A simple key value map pattern `k1=v1;k2=v2`. Valid key options are: `[principal, code_challenge_method, implicit_flow_requires_nonce, token_type_authentication, token_type_principal]`.
|Dynamic a|true
|Default value
m|+++{}+++
|===

[[config_dbms.security.oidc.-provider-.get_groups_from_user_info]]
.dbms.security.oidc.<provider>.get_groups_from_user_info
[cols="<1s,<4"]
|===
|Description
a|When turned on, Neo4j gets the groups from the provider user info endpoint.
|Valid values
a|dbms.security.oidc.<provider>.get_groups_from_user_info, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.security.oidc.-provider-.get_username_from_user_info]]
.dbms.security.oidc.<provider>.get_username_from_user_info
[cols="<1s,<4"]
|===
|Description
a|When turned on, Neo4j gets the username from the provider user info endpoint.
|Valid values
a|dbms.security.oidc.<provider>.get_username_from_user_info, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.security.oidc.-provider-.issuer]]
.dbms.security.oidc.<provider>.issuer
[cols="<1s,<4"]
|===
|Description
a|The expected value of the iss claim in the id token. If this is not supplied Neo4j will attempt to discover it from the well_known_discovery_uri.
|Valid values
a|dbms.security.oidc.<provider>.issuer, a string
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.jwks_uri]]
.dbms.security.oidc.<provider>.jwks_uri
[cols="<1s,<4"]
|===
|Description
a|The location of the JWK public key set for the identity provider. If this is not supplied Neo4j will attempt to discover it from the well_known_discovery_uri.
|Valid values
a|dbms.security.oidc.<provider>.jwks_uri, a URI
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.params]]
.dbms.security.oidc.<provider>.params
[cols="<1s,<4"]
|===
|Description
a|The map is a semicolon separated list of key-value pairs. For example: `k1=v1;k2=v2`.
The user should at least provide:
----
  client_id: the SSO Idp client idenfifier.
  response_type: code if auth_flow is pkce or token for implicit auth_flow.
  scope: often containing a subset of 'email profile openid groups'.
----
For example: `client_id=my-client-id;response_type=code;scope=openid profile email`.
|Valid values
a|dbms.security.oidc.<provider>.params, A simple key value map pattern `k1=v1;k2=v2`. Required key options are: `[client_id, response_type, scope]`.
|Dynamic a|true
|Default value
m|+++{}+++
|===

[[config_dbms.security.oidc.-provider-.token_endpoint]]
.dbms.security.oidc.<provider>.token_endpoint
[cols="<1s,<4"]
|===
|Description
a|The OIDC token endpoint. If this is not supplied Neo4j will attempt to discover it from the well_known_discovery_uri.
|Valid values
a|dbms.security.oidc.<provider>.token_endpoint, a URI
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.token_params]]
.dbms.security.oidc.<provider>.token_params
[cols="<1s,<4"]
|===
|Description
a|Optional query parameters that the token endpoint requires. The map is a semicolon separated list of key-value pairs. For example: `k1=v1;k2=v2`.If the token endpoint requires a client_secret then this parameter should contain `client_secret=super-secret`
|Valid values
a|dbms.security.oidc.<provider>.token_params, A simple key value map pattern `k1=v1;k2=v2`.
|Dynamic a|true
|Default value
m|+++{}+++
|===

[[config_dbms.security.oidc.-provider-.user_info_uri]]
.dbms.security.oidc.<provider>.user_info_uri
[cols="<1s,<4"]
|===
|Description
a|The identity providers user info uri.
|Valid values
a|dbms.security.oidc.<provider>.user_info_uri, a URI
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.well_known_discovery_uri]]
.dbms.security.oidc.<provider>.well_known_discovery_uri
[cols="<1s,<4"]
|===
|Description
a|The 'well known' OpenID Connect Discovery endpoint used to fetch identity provider settings. If not provided, `issuer`, `jwks_uri`, `auth_endpoint` should be present. If the auth_flow is pkce, `token_endpoint` should also be provided.
|Valid values
a|dbms.security.oidc.<provider>.well_known_discovery_uri, a URI
|Dynamic a|true
|===

[[config_dbms.dbms.security.key.name]]
.dbms.dbms.security.key.name
[cols="<1s,<4"]
|===
|Description
a|Name of the 256 length AES encryption key, which is used for the symmetric encryption.
|Valid values
a|dbms.dbms.security.key.name, a string
|Dynamic a|true
|Default value
m|+++aesKey+++
|===

[[config_dbms.dbms.security.keystore.password]]
.dbms.dbms.security.keystore.password
[cols="<1s,<4"]
|===
|Description
a|Password for accessing the keystore holding a 256 length AES encryption key, which is used for the symmetric encryption.
|Valid values
a|dbms.dbms.security.keystore.password, a secure string
|Dynamic a|true
|===

[[config_dbms.dbms.security.keystore.path]]
.dbms.dbms.security.keystore.path
[cols="<1s,<4"]
|===
|Description
a|Location of the keystore holding a 256 length AES encryption key, which is used for the symmetric encryption of secrets held in system database.
|Valid values
a|dbms.dbms.security.keystore.path, a path
|Dynamic a|true
|===

[[config_server.cluster.catchup.connect_randomly_to_server_group]]
.server.cluster.catchup.connect_randomly_to_server_group
[cols="<1s,<4"]
|===
|Description
a|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`server.cluster.catchup.upstream_strategy`) includes the value `connect-randomly-to-server-group`.
|Valid values
a|server.cluster.catchup.connect_randomly_to_server_group, a ',' separated list with elements of type 'a string identifying a Server Group'.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_server.groups]]
.server.groups
[cols="<1s,<4"]
|===
|Description
a|A list of group names for the server used when configuring load balancing and replication policies.
|Valid values
a|server.groups, a ',' separated list with elements of type 'a string identifying a Server Group'.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_server.memory.pagecache.flush.buffer.enabled]]
.server.memory.pagecache.flush.buffer.enabled
[cols="<1s,<4"]
|===
|Description
a|Page cache can be configured to use a temporal buffer for flushing purposes. It is used to combine, if possible, sequence of several cache pages into one bigger buffer to minimize the number of individual IOPS performed and better utilization of available I/O resources, especially when those are restricted.
|Valid values
a|server.memory.pagecache.flush.buffer.enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_server.memory.pagecache.flush.buffer.size_in_pages]]
.server.memory.pagecache.flush.buffer.size_in_pages
[cols="<1s,<4"]
|===
|Description
a|Page cache can be configured to use a temporal buffer for flushing purposes. It is used to combine, if possible, sequence of several cache pages into one bigger buffer to minimize the number of individual IOPS performed and better utilization of available I/O resources, especially when those are restricted. Use this setting to configure individual file flush buffer size in pages (8KiB). To be able to utilize this buffer during page cache flushing, buffered flush should be enabled.
|Valid values
a|server.memory.pagecache.flush.buffer.size_in_pages, an integer which is in the range `1` to `512`
|Dynamic a|true
|Default value
m|+++128+++
|===
