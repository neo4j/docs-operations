[role=enterprise-edition]
[[dynamic-settings]]
= Update dynamic settings
:description: How to change your Neo4j configuration while Neo4j is running, and which settings can be changed.


[[dynamic-settings-introduction]]
== Introduction

Neo4j Enterprise Edition supports changing some configuration settings at runtime, without restarting the service.
Changes to the configuration at runtime are not persisted.
To avoid losing changes when restarting Neo4j, you must ensure that the xref:configuration/file-locations.adoc[_neo4j.conf_ file] is also updated.


[NOTE]
====
label:cluster[Cluster]

In a clustered environment, `CALL dbms.setConfigValue` affects only the cluster member it is run against, and it is not propagated to other members.
Therefore, you should connect using `bolt://` rather than `neo4j://` to ensure that the setting is changed on the member connected to, and not on the unintended leader.
If you want to change the configuration settings on all cluster members, you have to run the procedure against each of them and update their _neo4j.conf_ file.
====


[[dynamic-settings-discover]]
== Discover dynamic settings

Use the procedure `dbms.listConfig()` to discover which configuration values can be dynamically updated, or consult xref:configuration/dynamic-settings.adoc[Dynamic settings reference].

.Discover dynamic settings
====

[source, cypher]
----
CALL dbms.listConfig()
YIELD name, dynamic
WHERE dynamic
RETURN name
ORDER BY name;
----

[queryresult]
----
+-----------------------------------------------------------------+
| name                                                            |
+-----------------------------------------------------------------+
| "causal_clustering.cluster_allow_reads_on_leader"               |
| "causal_clustering.connect_randomly_to_server_group"            |
| "causal_clustering.server_groups"                               |
| "dbms.allow_single_automatic_upgrade"                           |
| "dbms.allow_upgrade"                                            |
| "dbms.backup.incremental.strategy"                              |
| "dbms.checkpoint.iops.limit"                                    |
| "dbms.databases.default_to_read_only"                           |
| "dbms.databases.read_only"                                      |
| "dbms.databases.writable"                                       |
| "dbms.lock.acquisition.timeout"                                 |
| "dbms.logs.debug.level"                                         |
| "dbms.logs.query.allocation_logging_enabled"                    |
| "dbms.logs.query.early_raw_logging_enabled"                     |
| "dbms.logs.query.enabled"                                       |
| "dbms.logs.query.max_parameter_length"                          |
| "dbms.logs.query.obfuscate_literals"                            |
| "dbms.logs.query.page_logging_enabled"                          |
| "dbms.logs.query.parameter_full_entities"                       |
| "dbms.logs.query.parameter_logging_enabled"                     |
| "dbms.logs.query.plan_description_enabled"                      |
| "dbms.logs.query.rotation.keep_number"                          |
| "dbms.logs.query.rotation.size"                                 |
| "dbms.logs.query.runtime_logging_enabled"                       |
| "dbms.logs.query.threshold"                                     |
| "dbms.logs.query.time_logging_enabled"                          |
| "dbms.logs.query.transaction.enabled"                           |
| "dbms.logs.query.transaction.threshold"                         |
| "dbms.logs.query.transaction_id.enabled"                        |
| "dbms.memory.pagecache.flush.buffer.enabled"                    |
| "dbms.memory.pagecache.flush.buffer.size_in_pages"              |
| "dbms.memory.transaction.database_max_size"                     |
| "dbms.memory.transaction.global_max_size"                       |
| "dbms.memory.transaction.max_size"                              |
| "dbms.routing.client_side.enforce_for_domains"                  |
| "dbms.security.ldap.authentication.attribute"                   |
| "dbms.security.ldap.authentication.user_dn_template"            |
| "dbms.security.ldap.authorization.access_permitted_group"       |
| "dbms.security.ldap.authorization.group_membership_attributes"  |
| "dbms.security.ldap.authorization.group_to_role_mapping"        |
| "dbms.security.ldap.authorization.user_search_base"             |
| "dbms.security.ldap.authorization.user_search_filter"           |
| "dbms.track_query_allocation"                                   |
| "dbms.track_query_cpu_time"                                     |
| "dbms.transaction.bookmark_ready_timeout"                       |
| "dbms.transaction.concurrent.maximum"                           |
| "dbms.transaction.sampling.percentage"                          |
| "dbms.transaction.timeout"                                      |
| "dbms.transaction.tracing.level"                                |
| "dbms.tx_log.preallocate"                                       |
| "dbms.tx_log.rotation.retention_policy"                         |
| "dbms.tx_log.rotation.size"                                     |
| "dbms.upgrade_max_processors"                                   |
| "fabric.routing.servers"                                        |
| "systemdb.secrets.key.name"                                     |
| "systemdb.secrets.keystore.password"                            |
| "systemdb.secrets.keystore.path"                                |
+-----------------------------------------------------------------+
57 rows
----

====


[[dynamic-settings-procedure]]
== Update dynamic settings

An xref:authentication-authorization/terminology.adoc#term-administrator[administrator] is able to change some configuration settings at runtime, without restarting the service.

*Syntax:*

`CALL dbms.setConfigValue(_setting_, _value_)`

*Returns:*

Nothing on success.

*Exceptions:*

|===
| Unknown or invalid setting name.
| The setting is not dynamic and can not be changed at runtime.
| Invalid setting value.
|===

The following example shows how to dynamically enable query logging.

.Set a config value
====
[source, cypher]
----
CALL dbms.setConfigValue('dbms.logs.query.enabled', 'info')
----
====

If an invalid value is passed, the procedure will show a message to that effect.

.Try to set invalid config value
====
[source, cypher]
----
CALL dbms.setConfigValue('dbms.logs.query.enabled', 'yes')
----

[queryresult]
----
Failed to invoke procedure `dbms.setConfigValue`: Caused by: org.neo4j.graphdb.config.InvalidSettingException: Bad value 'yes' for setting 'dbms.logs.query.enabled': 'yes' not one of [OFF, INFO, VERBOSE]
----
====

To reset a config value to its default, pass an empty string as the _value_ argument.

.Reset a config value to default
====
[source, cypher]
----
CALL dbms.setConfigValue('dbms.logs.query.enabled', '')
----
====