:description: How to set up SSL within your environment, how to view, validate, and test the certificates.
[[ssl-framework]]
= SSL framework
:description: Describes how to set up SSL within your environment, how to view, validate, and test the certificates.

The SSL framework provides support for securing the following Neo4j communication channels using standard SSL/TLS technology:

* `bolt` (port - `7687`)
* `https` (port - `7473`)
* `cluster` (ports - `5000`, `6000`, `7000`, and `7688`)
* `backups` (port - `6362`)

This page describes how to set up SSL within your environment, how to view, validate, and test the certificates.

[[ssl-providers]]
== SSL providers

The secure networking in Neo4j is provided through the Netty library, which supports both the native JDK SSL provider as well as Netty-supported OpenSSL derivatives.

Follow these steps to use OpenSSL:

- Install a suitable dependency into the `plugins/` folder of Neo4j.

[NOTE]
====
Dependencies can be downloaded from https://netty.io/wiki/forked-tomcat-native.html.
Which dependencies you need depends upon the Neo4j version.
Each version of Neo4j ships with a version of Netty and Netty requires specific tcnative versions.
Make sure to install the version that matches your OS processor.
For more details, see the <<table, Netty support per Neo4j version>>.
====

- Using non static versions of tcnative will require installation of platform-specific OpenSSL dependencies as described in https://netty.io/wiki/forked-tomcat-native.html.
- Set `xref:configuration/configuration-settings.adoc#config_dbms.netty.ssl.provider[dbms.netty.ssl.provider]=OPENSSL`.
- Restart Neo4j.

[NOTE]
====
From Neo4j 5.21 on, required Netty and tcnative files are included in the _/lib_ directory.
====

The following table includes detailed information about supported Neo4j versions:

[[table]]
.Netty support per Neo4j version
[options="header", cols="1,1,2,3"]
|===
| Neo4j version
| Netty version
| tcnative version
| Direct link

| 5.22
| 4.1.111.Final
| 2.0.65.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.65.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.65.Final/jar

| 5.21
| 4.1.110.Final
| 2.0.65.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.65.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.65.Final/jar

| 5.20
| 4.1.109.Final
| 2.0.65.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.65.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.65.Final/jar

| 5.19
| 4.1.107.Final
| 2.0.61.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.61.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.61.Final/jar

| 5.18
| 4.1.106.Final
| 2.0.61.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.61.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.61.Final/jar

| 5.16
| 4.1.101.Final
| 2.0.61.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.61.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.61.Final/jar

| 5.13
| 4.1.100.Final
| 2.0.61.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.61.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.61.Final/jar

| 5.12
| 4.1.96.Final
| 2.0.61.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.61.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.61.Final/jar

| 5.11
| 4.1.94.Final
| 2.0.61.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.61.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.61.Final/jar

| 5.10
| 4.1.93.Final
| 2.0.61.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.61.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.61.Final/jar

| 5.8
| 4.1.92.Final
| 2.0.60.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.60.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.60.Final/jar

| 5.7
| 4.1.89.Final
| 2.0.56.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.56.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.56.Final/jar

| 5.5
| 4.1.87.Final
| 2.0.56.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.56.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.56.Final/jar

| 5.4
| 4.1.85.Final
| 2.0.54.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.54.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.54.Final/jar

| 5.2
| 4.1.84.Final
| 2.0.54.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.54.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.54.Final/jar

| 5.1
| 4.1.82.Final
| 2.0.54.Final. Both netty-tcnative-boringssl-static and netty-tcnative-classes are required.
| https://search.maven.org/artifact/io.netty/netty-tcnative-boringssl-static/2.0.54.Final/jar
https://search.maven.org/artifact/io.netty/netty-tcnative-classes/2.0.54.Final/jar
|===


[NOTE]
====
Using OpenSSL can significantly improve performance, especially for AES-GCM-cryptos, e.g. TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256.
====

[[ssl-certificates]]
== Certificates and private keys

=== Certificates
The SSL configuration requires SSL xref:security/ssl-framework.adoc#term-ssl-certificate[certificates] to be issued by a Certificate Authority (CA).
All certificates must follow the xref:security/ssl-framework.adoc#term-ssl-x509[X.509] standard and be saved in a `PEM-encoded` file.

[TIP]
====
Valid trusted certificates can be generated for free using non-profit CAs such as Let's Encrypt.
====

.Example public.crt file
[source, text]
----
-----BEGIN CERTIFICATE-----
MIIDojCCAoqgAwIBAgIBATANBgkqhkiG9w0BAQsFADBhMQswCQYDVQQGEwJTRTEQ
     ...
xsUBvcQuyxewlvWRS18YB51J+yu0Xg==
-----END CERTIFICATE-----
----

The instructions on this page assume that you have already obtained the required certificates from the CA and added them to the _public.crt_ file.
To achieve this, you should concatenate each PEM-encoded certificate, starting from the leaf certificate and moving up the chain toward the root.

[TIP]
====
If the same certificates are used across all instances of the cluster, make sure that when generating the certificates to include the DNS names of all the cluster instances in the certificates.
Multi-host and wildcard certificates are also supported.
====

[TIP]
====
If setting up intra-cluster encryption as part of a cluster configuration, ensure that the certificates used on the cluster endpoint support server and client usage.
This is because when connecting between the Neo4j servers for clustering, each server uses its own certificate to authenticate as a client on the connection to another server.

This could be verified from within the certificate details:

----
openssl x509 -in public.crt -noout -text
----
We should see that the X509v3 Extended Key Usage section shows both the usages listed:

----
X509v3 Extended Key Usage:
    TLS Web Server Authentication, TLS Web Client Authentication
----
====

==== Transformations

Neo4j requires all SSL certificates to be in the `PEM` format.
If your certificate is in the binary `DER` format, you must transform it into `PEM` format.

.Transform `DER` format certificate to `PEM` format
[source, shell]
----
openssl x509 -in cert.der -inform der -outform pem -out cert.crt
----


=== Private keys
Private keys must be in the standard format xref:security/ssl-framework.adoc#term-ssl-pkcs8[PKCS #8] and saved as a `PEM-encoded` file.

.Example private.key file
[source, text]
----
-----BEGIN PRIVATE KEY-----
MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAN5D0I4bgdQK4In6
     ...
oaMe91ZPQ1JI
-----END PRIVATE KEY-----
----

Private keys can also be encrypted with a passphrase according to the xref:security/ssl-framework.adoc#term-ssl-pkcs5[PKCS #5] standard.

.Example private.key file with passphrase encryption
[source, text]
----
-----BEGIN ENCRYPTED PRIVATE KEY-----
MIICojAcBgoqhkiG9w0BDAEEMA4ECL3eSAoRlJ18AgIIAASCAoCj7WDyjsgcawdv
     ...
lYeSjVah
-----END ENCRYPTED PRIVATE KEY-----
----

==== Transformation

If the private key is encoded with the old xref:security/ssl-framework.adoc#term-ssl-pkcs1[PKCS #1] format, the file will typically start with the line:

[source, text]
----
-----BEGIN RSA PRIVATE KEY-----
----

You can convert it to PKCS #8 format with the following command:

.Convert a PKCS #1 key to a PKCS #8 key
[source, shell]
----
openssl pkcs8 -topk8 -in pkcs1.key -out pkcs8.key
----

An unencrypted private key could be PKCS #1 or PKCS #8.
It can be encrypted with the following command:

.Convert an unencrypted key to an encrypted PKCS #8 key using 256bit AES in cipher-block-chaining (CBC) mode
[source, shell]
----
openssl pkcs8 -topk8 -v2 aes-256-cbc -v2prf hmacWithSHA512 -in pkcs1or8.key -out pkcs8.encrypted.key
----

.Supported encryption arguments to openssl are:
* `-v2 aes-128-cbc -v2prf hmacWithSHA1`
* `-v2 aes-128-cbc -v2prf hmacWithSHA224`
* `-v2 aes-128-cbc -v2prf hmacWithSHA256`
* `-v2 aes-128-cbc -v2prf hmacWithSHA384`
* `-v2 aes-128-cbc -v2prf hmacWithSHA512`
* `-v2 aes-256-cbc -v2prf hmacWithSHA224`
* `-v2 aes-256-cbc -v2prf hmacWithSHA256`
* `-v2 aes-256-cbc -v2prf hmacWithSHA384`
* `-v2 aes-256-cbc -v2prf hmacWithSHA512`

[NOTE]
====
Versions before Neo4j 5.0 allow keys to be stored with the old PKCS #1 standard.
You can identify them by the line `-----BEGIN RSA PRIVATE KEY-----` at the beginning of the file.
While Neo4j 5.0 can load and use those keys, they are considered deprecated and will be removed in a future version.
====


=== Validate the key and the certificate

If you need, you can validate the key file and the certificate as follows:

.Validate the key
[source, shell]
----
openssl rsa -in private.key -check
----

.Validate certificate in the PEM format
[source, shell]
----
openssl x509 -in public.crt –text –noout
----

[[ssl-connectors]]
== Connectors

Before enabling SSL support, you must ensure the following connector configurations to avoid errors:

* Set `server.https.enabled` to `true` when using HTTPS.
* Set `server.bolt.tls_level` to `REQUIRED` or `OPTIONAL` when using Bolt.

For more information on configuring connectors, see xref:configuration/connectors.adoc[Configure connectors].

[[ssl-configuration]]
== Configuration

The SSL policies are configured by assigning values to parameters of the following format:

`dbms.ssl.policy.<scope>.<setting-suffix>`

* `scope` is the name of the communication channel, such as `bolt`, `https`, `cluster`, and `backup`.
* `setting-suffix` can be any of the following:
+
[options="header"]
|===
| Setting suffix         | Description                                                                            | Default value
3+^.^| *Basic*
| `enabled`              | Setting this to `true` enables this policy.                                        | `false`
| `base_directory`       | The base directory under which <<term-ssl-cryptographic-objects, cryptographic objects>> are searched for by default.      | `certificates/<scope>`
| `private_key`          | The private key used for authenticating and securing this instance.                    | `private.key`
| `private_key_password` | The passphrase to decode the private key.
                           Only applicable for encrypted private keys.                                            |
| `public_certificate`   | A public certificate matching the private key signed by a CA.  | `public.crt`
| `trusted_dir`          | A directory populated with certificates of trusted parties.                            | `trusted/`
| `revoked_dir`          | A directory populated with certificate revocation lists (CRLs).                        | `revoked/`
3+^.^| *Advanced*
| `verify_hostname`      | Enabling this setting turns on client-side hostname verification.
                           After receiving the server's public certificate, the client compares the
                           address it uses against the certificate Common Name (CN) and Subject Alternative
                           Names (SAN) fields.
                           If the address does not match those fields, the client disconnects.            | `false`
| `ciphers`              | A comma-separated list of ciphers suites allowed during cipher negotiation.
                           Valid values depend on the current JRE and SSL provider.
                           For Ciphers supported by the Oracle JRE, see the link:https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#jsse-cipher-suite-names[Oracle official documentation].
| Java platform default allowed cipher suites.
| `tls_versions`         | A comma-separated list of allowed TLS versions.                                        | `TLSv1.2`
| `client_auth`          | Whether or not clients must be authenticated.
                           Setting this to `REQUIRE` enables mutual authentication for servers.
                           Other possible values are `NONE` and `OPTIONAL`.           | `OPTIONAL` for `bolt` and `https`; +
                            `REQUIRE` for `cluster` and `backup`.
| `trust_all`            | Setting this to `true` results in all clients and servers to be trusted and the content of the `trusted_dir` directory to be ignored.
                           Use this only as a mean of debugging, since it does not offer security.
| `false`
|===

[NOTE]
====
For security reasons, Neo4j does not automatically create any of these directories.
Therefore, the creation of an SSL policy requires the appropriate file system structure to be set up manually.
Note that the existence of the directories, the certificate file, and the private key are mandatory.
Ensure that only the Neo4j user can read the private key.
====

Each policy needs to be explicitly enabled by setting:

`dbms.ssl.policy.<scope>.enabled=true`

[[ssl-bolt-config]]
=== Configure SSL over Bolt

Bolt protocol is based on the link:https://neo4j.com/docs/bolt/current/packstream/[PackStream serialization] and supports the Cypher type system, protocol versioning, authentication, and TLS via certificates.
For Neo4j clusters, Bolt provides smart client routing with load balancing and failover.
When server side routing is enabled, an additional Bolt port is open on `7688`.
It can be used only within the cluster and with all the same settings as the external Bolt port.

Bolt connector is used by Cypher Shell, Neo4j Browser, and by the officially supported language drivers.
Bolt connector is enabled by default but its encryption is disabled.
To enable the encryption over Bolt, create the folder structure and place the key file and the certificates under those.
Then, you need to configure the SSL Bolt policies in the _neo4j.conf_ file.

. Enable the Bolt connector to enable SSL over Bolt:
+
[source, properties]
----
server.bolt.enabled=true (default is true)
----

. Set up the _bolt_ folder under _certificates_.
.. Create a directory _bolt_ under _<NEO4J_HOME>/certificates_ folder:
+
[source, shell]
----
mkdir certificates/bolt
----

.. Create a directory _trusted_ and _revoked_ under _<NEO4J_HOME>/certificates/bolt_ folder:
+
[source, shell]
----
mkdir certificates/bolt/trusted
mkdir certificates/bolt/revoked
----

. Place the certificates _private.key_ and the _public.crt_ files under _<NEO4J_HOME>/certificates/bolt_ folder:
+
[source, shell]
----
cp /path/to/certs/private.key certificates/bolt
cp /path/to/certs/public.crt certificates/bolt
----
. Place the _public.crt_ file under the _<NEO4J_HOME>/certificates/bolt/trusted_ folder.
+
[source, shell]
----
cp /path/to/certs/public.crt certificates/bolt/trusted
----
. (Optional) If a particular certificate is revoked, then place it under _<NEO4J_HOME>/certificates/bolt/revoked_ folder.
+
[source, shell]
----
cp /path/to/certs/public.crt certificates/bolt/revoked
----
+
The folder structure should look like this with the right file permissions and the groups and ownerships:
+
[options="header", cols="3,1,4*m"]
|===
| Path
| Directory/File
| Owner
| Group
| Permission
| Unix/Linux View

| /data/neo4j/certificates/bolt
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x

| /data/neo4j/certificates/bolt/public.crt
| File
| neo4j
| neo4j
| 0644
| -rw-r--r--

| /data/neo4j/certificates/bolt/private.key
| File
| neo4j
| neo4j
| 0400
| -r--------

| /data/neo4j/certificates/bolt/trusted
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x

| /data/neo4j/certificates/bolt/trusted/public.crt
| File
| neo4j
| neo4j
| 0644
| -rw-r--r--

| /data/neo4j/certificates/bolt/revoked
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x
|===
+
[TIP]
====
The owner/group should be configured to the user/group that will be running the `neo4j` service.
Default user/group is neo4j/neo4j.
====

. Set the Bolt SSL configuration in _neo4j.conf_.
.. Set the SSL Bolt policy to `true`:
+
[source, properties]
----
dbms.ssl.policy.bolt.enabled=true
----
.. Set the appropriate certificates path and the right key and cert files:
+
[source, properties]
----
dbms.ssl.policy.bolt.base_directory=certificates/bolt
dbms.ssl.policy.bolt.private_key=private.key
dbms.ssl.policy.bolt.public_certificate=public.crt
----
+
[TIP]
====
If the certificate is a different path outside of NEO4J_HOME, then set the absolute path for the certificates directory.
====

.. Set the Bolt client authentication to `NONE` to disable the mutual authentication:
+
[source, properties]
----
dbms.ssl.policy.bolt.client_auth=NONE
----

.. Set the Bolt TLS level to allow the connector to accept encrypted and/or unencrypted connections:
+
[source, properties]
----
server.bolt.tls_level=REQUIRED (default is DISABLED)
----
+
[TIP]
====
In Neo4j version 3.5, the default value is `OPTIONAL`.
In the Neo4j 4.x versions, the default value is `DISABLED`, where only unencrypted client connections are to be accepted by this connector, and all encrypted connections will be rejected.
Use `REQUIRED` when only encrypted client connections are to be accepted by this connector, and all unencrypted connections will be rejected.
Use `OPTIONAL` where either encrypted or unencrypted client connections are accepted by this connector.
====

. Test the SSL connection to the specified host and Bolt port and view the certificate:
+
[source, shell]
----
openssl s_client -connect my_domain.com:7687
----

[[ssl-bolt-connect]]
=== Connect with SSL over Bolt

Each of the `neo4j` and `bolt` URI schemes permit variants that contain extra encryption and trust information.
The `+s` variants enable encryption with a full certificate check.
The `+ssc` variants enable encryption with no certificate check.
This latter variant is designed specifically for use with self-signed certificates.

[options="header", cols="1m,1,3"]
|===
| URI Scheme
| Routing
| Description

| neo4j
| Yes
| Unsecured

| neo4j+s
| Yes
| Secured with full certificate

| neo4j+ssc
| Yes
| Secured with self-signed certificate

| bolt
| No
| Unsecured

| bolt+s
| No
| Secured with full certificate

| bolt+ssc
| No
| Secured with self-signed certificate
|===

Once SSL is enabled over Bolt, you can connect to the Neo4j DBMS using `neo4j+s` or `bolt+s`:

Cypher Shell::
[source, shell]
----
cypher-shell -a neo4j+s://<Server DNS or IP>:<Bolt port>

or

cypher-shell -a bolt+s://<Server DNS or IP>:<Bolt port>
----

Neo4j Browser::
From the *Connect URL* dropdown menu, select the URI scheme you want to use (`neo4j+s` or `bolt+s`).
+
[NOTE]
====
URI schemes ending `+ssc` are not supported by Neo4j Browser since the browser’s OS handles certificate trust.
If it is necessary to connect to a Neo4j instance using a self-signed certificate from Neo4j Browser, first visit a web page that uses the self-signed certificate in order to prompt the browser to request that certificate trust be granted.
Once that trust has been granted, you can connect with URI schemes ending `+s`.
====

[[ssl-https-config]]
=== Configure SSL over HTTPS

HTTP(s) is used by the Neo4j Browser and the HTTP API.
HTTPS (secure HTTP) is set to encrypt network communications.
To enable the encryption over HTTPS, create the folder structure and place the key file and the certificates under those.
Then, you need to configure the SSL HTTPS policies in the _neo4j.conf_ file and disable the HTTP connector.

[NOTE]
====
The HTTPS configuration requires that Bolt is also set.
Refer to xref:/security/ssl-framework.adoc#ssl-bolt-config[Configure SSL over Bolt] for more instructions.
====

. Enable the HTTPS connector to enable SSL over HTTPS:
+
[source, properties]
----
server.https.enabled=true (default is false)
----

. Set up the _https_ folder under _certificates_.
.. Create a directory _https_ under _<NEO4J_HOME>/certificates_ folder:
+
[source, shell]
----
mkdir certificates/https
----

.. Create a directory _trusted_ and _revoked_ under _<NEO4J_HOME>/certificates/https_ folder:
+
[source, shell]
----
mkdir certificates/https/trusted
mkdir certificates/https/revoked
----

. Place the certificates _private.key_ and the _public.crt_ files under _<NEO4J_HOME>/certificates/https_ folder:
+
[source, shell]
----
cp /path/to/certs/private.key certificates/https
cp /path/to/certs/public.crt certificates/https
----
. Place the _public.crt_ file under the _<NEO4J_HOME>/certificates/https/trusted_ folder.
+
[source, shell]
----
cp /path/to/certs/public.crt certificates/https/trusted
----
. (Optional) If a particular certificate is revoked, then place it under _<NEO4J_HOME>/certificates/https/revoked_ folder.
+
[source, shell]
----
cp /path/to/certs/public.crt certificates/https/revoked
----
+
The folder structure should look like this with the right file permissions and the groups and ownerships:
+
[options="header", cols="3,1,4*m"]
|===
| Path
| Directory/File
| Owner
| Group
| Permission
| Unix/Linux View

| /data/neo4j/certificates/https
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x

| /data/neo4j/certificates/https/public.crt
| File
| neo4j
| neo4j
| 0644
| -rw-r--r--

| /data/neo4j/certificates/https/private.key
| File
| neo4j
| neo4j
| 0400
| -r--------

| /data/neo4j/certificates/https/trusted
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x

| /data/neo4j/certificates/https/trusted/public.crt
| File
| neo4j
| neo4j
| 0644
| -rw-r--r--

| /data/neo4j/certificates/https/revoked
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x
|===
+
[TIP]
====
The owner/group should be configured to the user/group that will be running the `neo4j` service.
Default user/group is neo4j/neo4j.
====

. Set the HTTPS SSL configuration in _neo4j.conf_.
.. Set the SSL HTTPS policy to `true`:
+
[source, properties]
----
dbms.ssl.policy.https.enabled=true
----
.. Set the appropriate certificates path and the right key and cert files:
+
[source, properties]
----
dbms.ssl.policy.https.base_directory=certificates/https
dbms.ssl.policy.https.private_key=private.key
dbms.ssl.policy.https.public_certificate=public.crt
----
+
[TIP]
====
If the certificate is a different path outside of NEO4J_HOME, then set the absolute path for the certificates directory.
====

.. Set the HTTPS client authentication to `NONE` to disable the mutual authentication:
+
[source, properties]
----
dbms.ssl.policy.https.client_auth=NONE
----

.. Disable HTTP connector:
+
[source, properties]
----
server.http.enabled=false
----

. Test the SSL connection to the specified host and HTTPS port and view the certificate:
+
[source, shell]
----
openssl s_client -connect my_domain.com:7473
----


[[ssl-cluster-config]]
=== Configure SSL for intra-cluster communications

Intra-cluster encryption is the security solution for the cluster communication.
The Neo4j cluster communicates on 4 ports:

* 5000 - Discovery management
* 6000 - Transactions
* 7000 - Raft communications
* 7688 - Server side routing

To set up intra-cluster encryption, on each server create the folder structure and place the key file and the certificates under those.
Then, you need to configure the SSL cluster policies in the _neo4j.conf_ file and test that the intra-cluster communication is encrypted.

. Set up the _cluster_ folder under _certificates_.
.. Create a directory _cluster_ under_<NEO4J_HOME>/certificates_ folder:
+
[source, shell]
----
mkdir certificates/cluster
----

.. Create a directory _trusted_ and _revoked_ under _<NEO4J_HOME>/certificates/cluster_ folder:
+
[source, shell]
----
mkdir certificates/cluster/trusted
mkdir certificates/cluster/revoked
----

. Place the certificates _private.key_ and the _public.crt_ files under _<NEO4J_HOME>/certificates/cluster_ folder:
+
[source, shell]
----
cp /path/to/certs/private.key certificates/cluster
cp /path/to/certs/public.crt certificates/cluster
----
. Place the _public.crt_ file under the _<NEO4J_HOME>/certificates/cluster/trusted_ folder.
+
[source, shell]
----
cp /path/to/certs/public.crt certificates/cluster/trusted
----
+
[TIP]
====
If each server has a certificate of its own, signed by a CA, then each server's public certificate has to be put in the _trusted_ folder on each instance of the cluster.
Thus, the servers are able to establish trust relationships with each other.
====
. (Optional) If a particular certificate is revoked, then place it under _<NEO4J_HOME>/certificates/cluster/revoked_ folder.
+
[source, shell]
----
cp /path/to/certs/public.crt certificates/cluster/revoked
----
+
The folder structure should look like this with the right file permissions and the groups and ownerships:
+
[options="header", cols="3,1,4*m"]
|===
| Path
| Directory/File
| Owner
| Group
| Permission
| Unix/Linux View

| /data/neo4j/certificates/cluster
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x

| /data/neo4j/certificates/cluster/public.crt
| File
| neo4j
| neo4j
| 0644
| -rw-r--r--

| /data/neo4j/certificates/cluster/private.key
| File
| neo4j
| neo4j
| 0400
| -r--------

| /data/neo4j/certificates/cluster/trusted
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x

| /data/neo4j/certificates/cluster/trusted/public.crt
| File
| neo4j
| neo4j
| 0644
| -rw-r--r--

| /data/neo4j/certificates/cluster/revoked
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x
|===
+
[TIP]
====
The owner/group should be configured to the user/group that will be running the `neo4j` service.
Default user/group is neo4j/neo4j.
====

. Set the cluster SSL configuration in _neo4j.conf_.
.. Set the cluster SSL policy to `true`:
+
[source, properties]
----
dbms.ssl.policy.cluster.enabled=true
----
.. Set the appropriate certificates path and the right key and cert files:
+
[source, properties]
----
dbms.ssl.policy.cluster.base_directory=certificates/cluster
dbms.ssl.policy.cluster.private_key=private.key
dbms.ssl.policy.cluster.public_certificate=public.crt
----
+
[TIP]
====
If the certificate is a different path outside of NEO4J_HOME, then set the absolute path for the certificates directory.
====

.. Set the cluster client authentication to `REQUIRE` to enable the mutual authentication, which means that both ends of a channel have to authenticate:
+
[source, properties]
----
dbms.ssl.policy.cluster.client_auth=REQUIRE
----
+
[NOTE]
====
The policy must be configured on every server with the same settings.
The actual xref:security/ssl-framework.adoc#term-ssl-cryptographic-objects[cryptographic objects] installed will be mostly different since they do not share the same private keys and corresponding certificates.
The trusted CA certificate will be shared however.
====

.. Verify that the intra-cluster communication is encrypted.
You may use an external tooling, such as Nmap (https://nmap.org/download.html):
+
[source, shell]
----
nmap --script ssl-enum-ciphers -p <port> <hostname>
----
+
[NOTE]
====
The hostname and port have to be adjusted according to your configuration.
This can prove that TLS is in fact enabled and that only the intended cipher suites are enabled.
All servers and all applicable ports should be tested.
If the intra-cluster encryption is enabled, the output should indicate the port is open and it is using TLS with the ciphers used.
====

[TIP]
====
For more details on securing the comunication between the cluster servers, see xref:clustering/setup/encryption.adoc[Intra-cluster encryption].
====

[[ssl-backup-config]]
=== Configure SSL for backup communication

In a single instance, by default the backup communication happens on port `6362`.
In a cluster topology, it is possible to take a backup from any server, and each server has two configurable ports capable of serving a backup.
These ports are configured by `dbms.backup.listen.address` (port `6362`) and `server.cluster.listen_address` (port `6000`) respectively.
If the intra-cluster encryption is enabled and the backup communication is using port `6000`, then your communication channels are already encrypted.
The following steps assumes that your backup is set up on a different port.

To set up SSL for backup communication, create the folder structure and place the key file and the certificates under those.
Then, you need to configure the SSL backup policies in the _neo4j.conf_ file.

. Set up the _backup_ folder under _certificates_.
.. Create a directory _backup_ under _<NEO4J_HOME>/certificates_ folder:
+
[source, shell]
----
mkdir certificates/backup
----

.. Create a directory _trusted_ and _revoked_ under _<NEO4J_HOME>/certificates/backup_ folder:
+
[source, shell]
----
mkdir certificates/backup/trusted
mkdir certificates/backup/revoked
----

. Place the certificates _private.key_ and the _public.crt_ files under _<NEO4J_HOME>/certificates/backup_ folder:
+
[source, shell]
----
cp /path/to/certs/private.key certificates/backup
cp /path/to/certs/public.crt certificates/backup
----
. Place the _public.crt_ file under the _<NEO4J_HOME>/certificates/backup/trusted_ folder.
+
[source, shell]
----
cp /path/to/certs/public.crt certificates/backup/trusted
----
. (Optional) If a particular certificate is revoked, then place it under _<NEO4J_HOME>/certificates/backup/revoked_ folder.
+
[source, shell]
----
cp /path/to/certs/public.crt certificates/backup/revoked
----
+
The folder structure should look like this with the right file permissions and the groups and ownerships:
+
[options="header", cols="3,1,4*m"]
|===
| Path
| Directory/File
| Owner
| Group
| Permission
| Unix/Linux View

| /data/neo4j/certificates/backup
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x

| /data/neo4j/certificates/backup/public.crt
| File
| neo4j
| neo4j
| 0644
| -rw-r--r--

| /data/neo4j/certificates/backup/private.key
| File
| neo4j
| neo4j
| 0400
| -r--------

| /data/neo4j/certificates/backup/trusted
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x

| /data/neo4j/certificates/backup/trusted/public.crt
| File
| neo4j
| neo4j
| 0644
| -rw-r--r--

| /data/neo4j/certificates/backup/revoked
| Directory
| neo4j
| neo4j
| 0755
| drwxr-xr-x
|===
+
[TIP]
====
The owner/group should be configured to the user/group that will be running the `neo4j` service.
Default user/group is neo4j/neo4j.
====

. Set the backup SSL configuration in _neo4j.conf_.
.. Set the backup SSL policy to `true`:
+
[source, properties]
----
dbms.ssl.policy.backup.enabled=true
----
.. Set the appropriate certificates path and the right key and cert files:
+
[source, properties]
----
dbms.ssl.policy.backup.base_directory=certificates/backup
dbms.ssl.policy.backup.private_key=private.key
dbms.ssl.policy.backup.public_certificate=public.crt
----
+
[TIP]
====
If the certificate is a different path outside of NEO4J_HOME, then set the absolute path for the certificates directory.
====

.. Set the backup client authentication to `REQUIRE` to enable the mutual authentication, which means that both ends of a channel have to authenticate:
+
[source, properties]
----
dbms.ssl.policy.backup.client_auth=REQUIRE
----

[[ssl-other-configs]]
=== Other configurations for SSL

==== Using encrypted private key

To use an encrypted private key, configure the following settings.
The private key password must be clear text format without any quotes.

.Bolt
[source, properties]
----
dbms.ssl.policy.bolt.private_key_password=<clear text password>
----

.HTTPS
[source, properties]
----
dbms.ssl.policy.https.private_key_password=<password>
----

.Intra-cluster encryption
[source, properties]
----
dbms.ssl.policy.cluster.private_key_password=<password>
----

.Backup
[source, properties]
----
dbms.ssl.policy.backup.private_key_password=<password>
----

If hardcoding of clear text private key password is not feasible due to security constraints, it can be set up to use dynamic password pickup by following these steps:

. Create a file containing the `cleartext` password for the private key password and encrypt it with the certificate (assuming private key for cert has password set and certificate is in `pwd`):
+
[source]
----
echo "password123" > passwordfile

base64 -w 0 certificate.crt | openssl aes-256-cbc -a -salt -in passwordfile -out password.enc -pass stdin
----
+
[NOTE]
====
Delete the password file and set file permissions for `password.enc` to `400` (e.g. `chmod 400 password.enc`).
====

. Verify that encrypted password can be read from password.enc:
+
[source]
----
base64 -w 0 certificate.crt | openssl aes-256-cbc -a -d -in password.enc -pass stdin
----

. Set the neo4j.conf `dbms.ssl.policy.<type>.private_key_password` to be able to read out encrypted password.
To adjust paths to cert and encrypted password file, use full paths:
+
[source]
----
dbms.ssl.policy.bolt.private_key_password=$(base64 -w 0 certificate.crt | openssl aes-256-cbc -a -d -in password.enc -pass stdin)
----

[NOTE]
====
Using a dynamic command requires Neo4j to be started with the `--expand-commands` option.
For more information, see xref:configuration/command-expansion.adoc[Command expansion].
====

==== Using specific cipher

There are cases where Neo4j Enterprise requires the use of specific ciphers for encryptions.
One can set up a Neo4j configuration by specifying the list of cipher suites that will be allowed during cipher negotiation.
Valid values depend on the current JRE and SSL provider.
For Oracle JRE here is the list of supported ones - https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#jsse-cipher-suite-names.

.Bolt
[source, properties]
----
dbms.ssl.policy.bolt.ciphers=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
----

.HTTPS
[source, properties]
----
dbms.ssl.policy.https.ciphers=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
----

.Intra-cluster encryption
[source, properties]
----
dbms.ssl.policy.cluster.ciphers=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
----

.Backup
[source, properties]
----
dbms.ssl.policy.backup.ciphers=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
----

[[ssl-ocsp-config]]
=== Using OCSP stapling

From Neo4j 4.2, Neo4j supports OCSP stapling, which is implemented on the server side, and can be configured in the _neo4j.config_ file.
OCSP stapling is also available for Java Bolt driver and HTTP API.

On the server side in the _neo4j.conf_ file, configure the following settings:

. Set the SSL Bolt policy to `true`:
+
[source, properties]
----
dbms.ssl.policy.bolt.enabled=true
----
. Enable the OCSP stapling for Bolt:
+
[source, properties]
----
server.bolt.ocsp_stapling_enabled=true (default = false)
----

[[ssl-logging]]
== SSL logs

All information related to SSL can be found in the _debug.log_ file.
You can also enable additional debug logging for SSL by adding the following configuration to the _neo4j.conf_ file and restarting Neo4j.

[source, properties]
----
server.jvm.additional=-Djavax.net.debug=ssl:handshake
----

This will log additional information in the _neo4j.log_ file.
In some installations done using `rpm` based installs, _neo4j.log_ is not created.
To get the contents of this, since _neo4j.log_ just contains `STDOUT` content, look for the `neo4j` service log contents using `journalctl`:

[source]
----
neo4j@ubuntu:/var/log/neo4j$ journalctl -u neo4j -b > neo4j.log
neo4j@ubuntu:/var/log/neo4j$ vi neo4j.log
----

[WARNING]
====
Beware that the SSL debug option logs a new statement every time a client connects over SSL, which can make _neo4j.log_ grow large reasonably quickly.
To avoid that scenario, make sure this setting is only enabled for a short term duration.
====

[[ssl-terminology]]
== Terminology

The following terms are relevant to SSL support within Neo4j:

[.compact]
[[term-ssl-certificate-authority]]Certificate Authority (_CA_)::
A trusted entity that issues electronic documents that can verify the identity of a digital entity.
The term commonly refers to globally recognized CAs, but can also include internal CAs that are trusted inside of an organization.
The electronic documents are digital xref:security/ssl-framework.adoc#term-ssl-certificate[certificates].
They are an essential part of secure communication, and play an important part in the xref:security/ssl-framework.adoc#term-ssl-pki[Public Key Infrastructure].

[[term-ssl-certificate-revocation-list]]Certificate Revocation List (_CRL_)::
In the event of a certificate being compromised, that certificate can be revoked.
This is done by means of a list (located in one or several files) spelling out which certificates are revoked.
The CRL is always issued by the xref:security/ssl-framework.adoc#term-ssl-certificate-authority[CA] which issues the corresponding certificates.

[[term-ssl-cipher]]cipher::
An algorithm for performing encryption or decryption.
In the most general implementation of encrypted communications, Neo4j makes implicit use of ciphers that are included as part of the Java platform.
The configuration of the SSL framework also allows for the explicit declaration of allowed ciphers.

[[term-ssl-channel]]communication channel::
A means for communicating with the Neo4j database.
Available channels are:
* Bolt client traffic
* HTTPS client traffic
* intra-cluster communication
* backup traffic

[[term-ssl-cryptographic-objects]]cryptographic objects::
A term denoting the artifacts xref:security/ssl-framework.adoc#term-ssl-private-key[private keys], xref:security/ssl-framework.adoc#term-ssl-certificate[certificates] and xref:security/ssl-framework.adoc#term-ssl-certificate-revocation-list[CRLs].

[[term-ssl-configuration-parameters]]configuration parameters::
These are the parameters defined for a certain xref:security/ssl-framework.adoc#term-ssl-policy[ssl policy] in _neo4j.conf_.

[[term-ssl-certificate]]certificate::
SSL certificates are issued by a trusted xref:security/ssl-framework.adoc#term-ssl-certificate-authority[certificate authority (_CA_)].
The public key can be obtained and used by anyone to encrypt messages intended for a particular recipient.
The certificate is commonly stored in a file named _<file name>.crt_.
This is also referred to as the xref:security/ssl-framework.adoc#term-ssl-public-key[public key].

[[term-ssl-san]]SAN::
SAN is an acronym for _Subject Alternative Names_.
It is an extension to certificates that one can include optionally.
When presented with a certificate that includes SAN entries, it is recommended that the address of the host is checked against this field.
Verifying that the hostname matches the certificate SAN helps prevent attacks where a rogue machine has access to a valid key pair.

[[term-ssl]]SSL::
SSL is an acronym for _Secure Sockets Layer_, and is the predecessor of xref:security/ssl-framework.adoc#term-ssl-tls-protocol[TLS].
It is common to refer to SSL/TLS as just SSL.
However, the modern and secure version is TLS, which is also the default in Neo4j.

[[term-ssl-policy]]SSL policy::
An SSL policy in Neo4j consists of a xref:security/ssl-framework.adoc#term-ssl-certificate[a digital certificate] and a set of configuration parameters defined in _neo4j.conf_.

[[term-ssl-pkcs1]]PKCS #1::
PKCS #1 is the first family of standards called Public-Key Cryptography Standards (PKCS).
It provides the basic definitions and recommendations for implementing the RSA algorithm for public-key cryptography.
It defines the mathematical properties of public and private keys, primitive operations for encryption and signatures, secure cryptographic schemes, and related ASN.1 syntax representations.

[[term-ssl-pkcs5]]PKCS #5::
PKCS #5 contains recommendations for implementating password-based cryptography, covering key derivation functions, encryption schemes, message authentication schemes, and _ASN.1_ syntax, identifying the techniques.

[[term-ssl-pkcs8]]PKCS #8::
PKCS #8 is a standard syntax for storing private key information.
The PKCS #8 private key may be encrypted with a passphrase using the PKCS #5 standards, which support multiple ciphers.
The main difference from xref:security/ssl-framework.adoc#term-ssl-pkcs1[PKCS #1] is that it allows more algorithms than RSA and supports stronger encryption of the private key.

[[term-ssl-private-key]]private key::
The private key ensures that encrypted messages can be deciphered only by the intended recipient.
The private key is commonly stored in a file named _<file name>.key_.
It is important to protect the private key to ensure the integrity of encrypted communication.

[[term-ssl-pki]]Public Key Infrastructure (_PKI_)::
A set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke xref:security/ssl-framework.adoc#term-ssl-certificate[digital certificates] and manage xref:security/ssl-framework.adoc#term-ssl-public-key[public-key] encryption.

[[term-ssl-public-key]]public key::
The public key can be obtained and used by anyone to encrypt messages intended for a particular recipient.
This is also referred to as the xref:security/ssl-framework.adoc#term-ssl-certificate[certificate].

[[term-ssl-tls-protocol]]TLS protocol::
The cryptographic protocol that provides communications security over a computer network.
The Transport Layer Security (TLS) protocol and its predecessor, the Secure Sockets Layer (SSL) protocol, are both frequently referred to as "SSL".

[[term-ssl-TLS-version]]TLS version::
A version of the TLS protocol.

[[term-ssl-x509]]X.509::
X.509 is an International Telecommunication Union (ITU) standard defining the format of xref:security/ssl-framework.adoc#term-ssl-public-key[public key] certificates.
