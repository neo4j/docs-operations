[role=enterprise-edition]
[[causal-clustering-lifecycle]]
= Causal Clustering lifecycle
:description: This section describes the lifecycle of a Neo4j Causal Cluster. 

This section includes:

* xref:clustering-advanced/lifecycle.adoc#causal-clustering-lifecycle-introduction[Introduction]
* xref:clustering-advanced/lifecycle.adoc#causal-clustering-discovery-protocol[Discovery protocol]
* xref:clustering-advanced/lifecycle.adoc#causal-clustering-lifecycle-core-membership[Core membership]
* xref:clustering-advanced/lifecycle.adoc#causal-clustering-lifecycle-rr-membership[Read Replica membership]
* xref:clustering-advanced/lifecycle.adoc#causal-clustering-transacting-via-raft-protocol[Transacting via the Raft protocol]
* xref:clustering-advanced/lifecycle.adoc#causal-clustering-catchup-protocol[Catchup protocol]
* xref:clustering-advanced/lifecycle.adoc#causal-clustering-rr-shutdown[Read Replica shutdown]
* xref:clustering-advanced/lifecycle.adoc#causal-clustering-core-shutdown[Core shutdown]


[[causal-clustering-lifecycle-introduction]]
== Introduction

In this section we will develop some deeper knowledge of how the cluster operates.
By developing our understanding of how the cluster works we will be better equipped to design, deploy, and troubleshoot our production systems.

Our in-depth tour will follow the lifecycle of a cluster.
We will boot a Core cluster and pick up key architectural foundations as the cluster forms and transacts.
We will then add in Read Replicas and show how they bootstrap join the cluster and then catchup and remain caught up with the Core Servers.
We will then see how backup is used in live cluster environments before shutting down Read Replicas and Core Servers.


[[causal-clustering-discovery-protocol]]
== Discovery protocol

The discovery protocol is the first step in forming a Causal Cluster.
It takes in some information about existing _Core_ cluster servers, and uses this to initiate a network join protocol.

image::causal-clustering-discovery.svg[title="Causal Cluster discovery protocol: Core-to-Core or Read Replica-to-Core only.", role="middle"]

Using this information, the server will either join an existing cluster or form one of its own.

[NOTE]
====
The discovery protocol targets Core Servers only regardless of whether it is a Core Server or Read Replica performing discovery.
It is because we expect Read Replicas to be both numerous and, relatively speaking, transient whereas Core Servers will likely be fewer in number and relatively stable over time.
====

The discovery protocol takes information from `xref:reference/configuration-settings.adoc#config_causal_clustering.initial_discovery_members[causal_clustering.initial_discovery_members]` in xref:configuration/file-locations.adoc[_neo4j.conf_], which lists which IP addresses and ports that form the cluster on startup.
Detailed information about discovery and discovery configuration options is given in the xref:clustering/setup-new-cluster.adoc#causal-clustering-discovery[Initial discovery of cluster members] section.
When consuming this information, the server will try to handshake with the other listed servers.
On successful handshake with another server (or servers), the current server will discover the whole current topology.

The discovery protocol continues to run throughout the lifetime of the Causal Cluster and is used to maintain the current state of available servers and to help clients route queries to an appropriate server via the client-side link:{neo4j-docs-base-uri}/driver-manual/1.7[drivers].

//=== Discovery protocol implementation

//The discovery service is implemented using one out of two third-party middleware systems: https://hazelcast.org/documentation/[_Hazelcast_] or https://akka.io/docs/[_Akka_].

//Only the Akka-based implementation supports <<intra-cluster-encryption, intra-cluster encryption>> of the discovery protocol.
//Causal Clusters running a version of Neo4j prior to v3.5.0 can only use the Hazelcast-based implementation.

//It is possible to switch from one implementation to the other.
//This requires the cluster to be taken offline and the configuration parameter to be changed, before starting up the cluster again.
//For new clusters, the Akka-based implementation is recommended.

//The implementation can be selected using the `<<config_causal_clustering.discovery_implementation, causal_clustering.discovery_implementation>>` parameter.
//Valid values are: `hazelcast` (default) and `akka`.


[[causal-clustering-lifecycle-core-membership]]
== Core membership

If it is a Core Server that is performing discovery, once it has made a connection to the one of the existing Core Servers, it then joins the Raft protocol.

[NOTE]
====
Raft is a distributed algorithm for maintaining a consistent log across multiple shared-nothing servers designed by Diego Ongaro for his 2014 Ph.D. thesis.
See the https://raft.github.io/slides/linkedin2014.pdf[Raft thesis] for details.
====

Raft handles cluster membership by making it a normal part of keeping a distributed log in sync.
Joining a cluster involves the insertion of a cluster membership entry into the Raft log which is then reliably replicated around the existing cluster.
Once that entry is applied to enough members of the Raft consensus group (those machines running the specific instance of the algorithm), they update their view of the cluster to include the new server.
Thus membership changes benefit from the same safety properties as other data transacted via Raft (see xref:clustering-advanced/lifecycle.adoc#causal-clustering-transacting-via-raft-protocol[Transacting via the Raft protocol] for more information).

The new Core Server must also catch up its own Raft log with respect to the other Core Servers as it initializes its internal Raft instance.
This is the normal case when a cluster is first booted and has performed few operations.
There will be a delay before the new Core Server becomes available if it also needs to catch up (as per xref:clustering-advanced/lifecycle.adoc#causal-clustering-catchup-protocol[Catchup protocol]) graph data from other servers.
This is the normal case for a long lived cluster where the servers holds a great deal of graph data.

When an instance establishes a connection to any other instance, it determines the current state of the cluster and ensures that it is eligible to join.
To be eligible the Neo4j instance must host the same database store as other members of the cluster (although it is allowed to be in an older, outdated, state), or be a new deployment without a database store.


[[causal-clustering-lifecycle-rr-membership]]
== Read Replica membership

When a Read Replica performs discovery, once it has made a connection to any of the available Core clusters it proceeds to add itself into a shared whiteboard.

image::read-replica-discovery.svg[title="All Read Replicas registered with shared whiteboard.", role="middle"]

This whiteboard provides a view of all live Read Replicas and is used both for routing requests from database drivers that support end-user applications and for monitoring the state of the cluster.

The Read Replicas are not involved in the Raft protocol, nor are they able to influence cluster topology.
Hence a shared whiteboard outside of Raft comfortably scales to very large numbers of Read Replicas.

The whiteboard is kept up to date as Read Replicas join and leave the cluster, even if they fail abruptly rather than leaving gracefully.


[[causal-clustering-transacting-via-raft-protocol]]
== Transacting via the Raft protocol

Once bootstrapped, each Core Server spends its time processing database transactions.
Updates are reliably replicated around Core Servers via the Raft protocol.
Updates appear in the form of a (committed) Raft log entry containing transaction commands which is subsequently applied to update the database.

[NOTE]
====
One of Raft's primary design goals is to be easily understandable so that there are fewer places for tricky bugs to hide in implementations.
As a side-effect, it is also possible for database operators to reason about their Core Servers in their Causal Clusters.
====

The Raft Leader for the current term (a logical clock) appends the transaction (an 'entry' in Raft terminology) to the head of its local log and asks the other instances to do the same.
When the Leader can see that a majority instances have appended the entry, it can be considered committed into the Raft log.
The client application can now be informed that the transaction has safely committed since there is sufficient redundancy in the system to tolerate any (non-pathological) faults.

[NOTE]
====
The Raft protocol describes three roles that an instance can be playing: _Leader_, _Follower_, and _Candidate_.
These are transient roles and any Core Server can expect to play them throughout the lifetime of a cluster.
While it is interesting from a computing science point of view to understand those states, operators should not be overly concerned: they are an implementation detail.
====

For safety, within any Raft protocol instance there is only one Leader able to make forward progress in any given term.
The Leader bears the responsibility for imposing order on Raft log entries and driving the log forward with respect to the _Followers_.

Followers maintain their logs with respect to the current Leader's log.
Should any participant in the cluster suspect that the Leader has failed, then they can instigate a leadership election by entering the _Candidate_ state.
In Neo4j Core Servers this is happens at ms timescale, around 500ms by default.

Whichever instance is in the best state (including the existing Leader, if it remains available) can emerge from the election as Leader.
The "best state" for a Leader is decided by highest term, then by longest log, then by highest committed entry.

The ability to fail over roles without losing data allows forward progress even in the event of faults.
Even where Raft instances fail, the protocol can rapidly piece together which of the remaining instances is best placed to take over from the failed instance (or instances) *without data loss*.
This is the essence of a _non-blocking_ consensus protocol which allows Neo4j Causal Clustering to provide continuous availability to applications.


[[causal-clustering-catchup-protocol]]
== Catchup protocol

Read Replicas spend their time concurrently processing graph queries and applying a stream of transactions from the Core Servers to update their local graph store.

image::read-replica-tx-polling.svg[title="Transactions shipped from Core to Read Replica.", role="middle"]

Updates from Core Servers to Read Replicas are propagated by transaction shipping.
Transaction shipping is instigated by Read Replicas frequently _polling_ any of the Core Servers specifying the ID of the last transaction they received and processed.
The frequency of polling is an operational choice.

[NOTE]
====
Neo4j transaction IDs are strictly monotonic integer values (they always increase).
This makes it possible to determine whether or not a transaction has been applied to a Read Replica by comparing its last processed transaction ID with that of a Core Server.
====

If there is a large difference between an Read Replica's transaction history and that of a Core Server, polling may not result in any transactions being shipped.
This is quite expected, for example when a new Read Replica is introduced to a long-running cluster or where a Read Replica has been down for some significant period of time.
In such cases the catchup protocol will realize the gap between the Core Servers and Read Replica is too large to fill via transaction shipping and will fall back to copying the database store directly from Core Server to Read Replica.
Since we are working with a live system, at the end of the database store copy the Core Server's database is likely to have changed.
The Read Replica completes the catchup by asking for any transactions missed during the copy operation before becoming available.

[NOTE]
====
A very slow database store copy could conceivably leave the Read Replica too far behind to catch up via transaction log shipping as the Core Server has substantially moved on.
In such cases the Read Replica server repeats the catchup protocol.
In pathological cases the operator can intervene to snapshot, restore, or file copy recent store files from a fast backup.
====


[[causal-clustering-rr-shutdown]]
== Read Replica shutdown

On clean shutdown, a Read Replica will invoke the discovery protocol to remove itself from the shared whiteboard overview of the cluster.
It will also ensure that the database is cleanly shutdown and consistent, immediately ready for future use.

On an unclean shutdown such as a power outage, the Core Servers maintaining the overview of the cluster will notice that the Read Replica's connection has been abruptly been cut.
The discovery machinery will initially hide the Read Replica's whiteboard entry, and if the Read Replica does not reappear quickly its modest memory use in the shared whiteboard will be reclaimed.

On unclean shutdown it is possible the Read Replica will not have entirely consistent store files or transaction logs.
On subsequent reboot the Read Replica will rollback any partially applied transactions such that the database is in a consistent state.


[[causal-clustering-core-shutdown]]
== Core shutdown

A clean Core Server shutdown, like Core Server booting, is handled via the Raft protocol.
When a Core Server is shut down, it appends a membership entry to the Raft log which is then replicated around the Core Servers.
Once a majority of Core Servers have committed that membership entry the leaver has logically left the cluster and can safely shut down.
All remaining instances accept that the cluster has grown smaller, and is therefore less fault tolerant.
If the leaver happened to be playing the Leader role at the point of leaving, it will be transitioned to another Core Server after a brief election.

An unclean shutdown does not directly inform the cluster that a Core Server has left.
Instead the Core cluster size remains the same for purposes of computing majorities for commits.
Thus an unclean shutdown in a cluster of 5 Core Servers now requires 3/4 members to agree to commit which is a tighter margin than 3/5 before the unclean shutdown.

[NOTE]
====
Of course when Core Servers fail, operators or monitoring scripts can be alerted so that they can intervene in the cluster if necessary.
====

If the leaver was playing the Leader role, there will be a brief election to produce a new Leader.
Once the new Leader is established, the Core cluster continues albeit with less redundancy.
However even with this failure, a Core cluster of 5 servers reduced to 4 can still tolerate one more fault before becoming read-only.
