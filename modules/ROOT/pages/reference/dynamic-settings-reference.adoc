[role=enterprise-edition]
[[dynamic-settings-reference]]
= Dynamic configuration settings
:description: This page provides a complete reference to the Neo4j dynamic configuration settings. 


This page provides a complete reference to the Neo4j dynamic configuration settings, which can be changed at runtime, without restarting the service.
This complete reference is a sub-list of all the Neo4j configuration settings.

[NOTE]
====
Changes to the configuration at runtime are not persisted.
To avoid losing changes when restarting Neo4j, make sure you update xref:configuration/file-locations.adoc[_neo4j.conf_] as well.

In a clustered environment, `CALL dbms.setConfigValue` affects only the server it is run against, and it is not propagated to other members.
If you want to change the configuration settings on all cluster members, you have to run the procedure against each of them and update their _neo4j.conf_ file.

For more information on how to update dynamic configuration settings, see xref:configuration/dynamic-settings.adoc[Update dynamic settings].
====

.Dynamic settings reference
[options="header"]
|===
|Name|Description
|<<config_db.checkpoint.iops.limit,db.checkpoint.iops.limit>>|Limit the number of IOs the background checkpoint process will consume per second.
|<<config_db.format,db.format>>|Database format.
|<<config_db.lock.acquisition.timeout,db.lock.acquisition.timeout>>|The maximum time interval within which lock should be acquired.
|<<config_db.logs.query.early_raw_logging_enabled,db.logs.query.early_raw_logging_enabled>>|Log query text and parameters without obfuscating passwords.
|<<config_db.logs.query.enabled,db.logs.query.enabled>>|Log executed queries.
|<<config_db.logs.query.max_parameter_length,db.logs.query.max_parameter_length>>|Sets a maximum character length use for each parameter in the log.
|<<config_db.logs.query.obfuscate_literals,db.logs.query.obfuscate_literals>>|Obfuscates all literals of the query before writing to the log.
|<<config_db.logs.query.parameter_logging_enabled,db.logs.query.parameter_logging_enabled>>|Log parameters for the executed queries being logged.
|<<config_db.logs.query.plan_description_enabled,db.logs.query.plan_description_enabled>>|Log query plan description table, useful for debugging purposes.
|<<config_db.logs.query.threshold,db.logs.query.threshold>>|If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO.
|<<config_db.logs.query.transaction.enabled,db.logs.query.transaction.enabled>>|Log the start and end of a transaction.
|<<config_db.logs.query.transaction.threshold,db.logs.query.transaction.threshold>>|If the transaction is open for more time than this threshold, the transaction is logged once completed - provided transaction logging (db.logs.query.transaction.enabled) is set to `INFO`.
|<<config_db.memory.transaction.max,db.memory.transaction.max>>|Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_db.memory.transaction.total.max,db.memory.transaction.total.max>>|Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_db.track_query_cpu_time,db.track_query_cpu_time>>|Enables or disables tracking of how much time a query spends actively executing on the CPU.
|<<config_db.transaction.bookmark_ready_timeout,db.transaction.bookmark_ready_timeout>>|The maximum amount of time to wait for the database state represented by the bookmark.
|<<config_db.transaction.concurrent.maximum,db.transaction.concurrent.maximum>>|The maximum number of concurrently running transactions.
|<<config_db.transaction.sampling.percentage,db.transaction.sampling.percentage>>|Transaction sampling percentage.
|<<config_db.transaction.timeout,db.transaction.timeout>>|The maximum time interval of a transaction within which it should be completed.
|<<config_db.transaction.tracing.level,db.transaction.tracing.level>>|Transaction creation tracing level.
|<<config_db.tx_log.preallocate,db.tx_log.preallocate>>|Specify if Neo4j should try to preallocate logical log file in advance.
|<<config_db.tx_log.rotation.retention_policy,db.tx_log.rotation.retention_policy>>|Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
|<<config_db.tx_log.rotation.size,db.tx_log.rotation.size>>|Specifies at which file size the logical log will auto-rotate.
|<<config_dbms.cypher.render_plan_description,dbms.cypher.render_plan_description>>|If set to `true` a textual representation of the plan description will be rendered on the server for all queries running with `EXPLAIN` or `PROFILE`.
|<<config_dbms.memory.transaction.total.max,dbms.memory.transaction.total.max>>|Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_dbms.routing.client_side.enforce_for_domains,dbms.routing.client_side.enforce_for_domains>>|Always use client side routing (regardless of the default router) for neo4j:// protocol connections to these domains.
|<<config_dbms.routing.reads_on_writers_enabled,dbms.routing.reads_on_writers_enabled>>|label:enterprise-edition[Enterprise only]Configure if the `dbms.routing.getRoutingTable()` procedure should include the writer as read endpoint or return only non-writers (non writer primaries and secondaries) Note: writer is returned as read endpoint if no other member is present all.
|<<config_dbms.security.key.name,dbms.security.key.name>>|label:enterprise-edition[Enterprise only]Name of the 256 length AES encryption key, which is used for the symmetric encryption.
|<<config_dbms.security.keystore.password,dbms.security.keystore.password>>|label:enterprise-edition[Enterprise only]Password for accessing the keystore holding a 256 length AES encryption key, which is used for the symmetric encryption.
|<<config_dbms.security.keystore.path,dbms.security.keystore.path>>|label:enterprise-edition[Enterprise only]Location of the keystore holding a 256 length AES encryption key, which is used for the symmetric encryption of secrets held in system database.
|<<config_dbms.security.ldap.authentication.attribute,dbms.security.ldap.authentication.attribute>>|label:enterprise-edition[Enterprise only]The attribute to use when looking up users.
Using this setting requires `dbms.security.ldap.authentication.search_for_attribute` to be true and thus `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` to be configured.
|<<config_dbms.security.ldap.authentication.user_dn_template,dbms.security.ldap.authentication.user_dn_template>>|label:enterprise-edition[Enterprise only]LDAP user DN template.
|<<config_dbms.security.ldap.authorization.access_permitted_group,dbms.security.ldap.authorization.access_permitted_group>>|label:enterprise-edition[Enterprise only]The LDAP group to which a user must belong to get any access to the system.Set this to restrict access to a subset of LDAP users belonging to a particular group.
|<<config_dbms.security.ldap.authorization.group_membership_attributes,dbms.security.ldap.authorization.group_membership_attributes>>|label:enterprise-edition[Enterprise only]A list of attribute names on a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled.
|<<config_dbms.security.ldap.authorization.group_to_role_mapping,dbms.security.ldap.authorization.group_to_role_mapping>>|label:enterprise-edition[Enterprise only]An authorization mapping from LDAP group names to Neo4j role names.
|<<config_dbms.security.ldap.authorization.nested_groups_enabled,dbms.security.ldap.authorization.nested_groups_enabled>>|label:enterprise-edition[Enterprise only]This setting determines whether multiple LDAP search results will be processed (as is required for the lookup of nested groups).
|<<config_dbms.security.ldap.authorization.nested_groups_search_filter,dbms.security.ldap.authorization.nested_groups_search_filter>>|label:enterprise-edition[Enterprise only]The search template which will be used to find the nested groups which the user is a member of.
|<<config_dbms.security.ldap.authorization.user_search_base,dbms.security.ldap.authorization.user_search_base>>|label:enterprise-edition[Enterprise only]The name of the base object or named context to search for user objects when LDAP authorization is enabled.
|<<config_dbms.security.ldap.authorization.user_search_filter,dbms.security.ldap.authorization.user_search_filter>>|label:enterprise-edition[Enterprise only]The LDAP search filter to search for a user principal when LDAP authorization is enabled.
|<<config_dbms.security.oidc.-provider-.audience,dbms.security.oidc.<provider>.audience>>|label:enterprise-edition[Enterprise only]Expected values of the Audience (aud) claim in the id token.
|<<config_dbms.security.oidc.-provider-.auth_endpoint,dbms.security.oidc.<provider>.auth_endpoint>>|label:enterprise-edition[Enterprise only]The OIDC authorization endpoint.
|<<config_dbms.security.oidc.-provider-.auth_flow,dbms.security.oidc.<provider>.auth_flow>>|label:enterprise-edition[Enterprise only]The OIDC flow to use.
|<<config_dbms.security.oidc.-provider-.auth_params,dbms.security.oidc.<provider>.auth_params>>|label:enterprise-edition[Enterprise only]Optional additional parameters that the auth endpoint requires.
|<<config_dbms.security.oidc.-provider-.authorization.group_to_role_mapping,dbms.security.oidc.<provider>.authorization.group_to_role_mapping>>|label:enterprise-edition[Enterprise only]An authorization mapping from IdP group names to Neo4j role names.
|<<config_dbms.security.oidc.-provider-.claims.groups,dbms.security.oidc.<provider>.claims.groups>>|label:enterprise-edition[Enterprise only]The claim to use as the list of groups in Neo4j.
|<<config_dbms.security.oidc.-provider-.claims.username,dbms.security.oidc.<provider>.claims.username>>|label:enterprise-edition[Enterprise only]The claim to use as the username in Neo4j.
|<<config_dbms.security.oidc.-provider-.client_id,dbms.security.oidc.<provider>.client_id>>|label:enterprise-edition[Enterprise only]Client id needed if token contains multiple Audience (aud) claims.
|<<config_dbms.security.oidc.-provider-.config,dbms.security.oidc.<provider>.config>>|label:enterprise-edition[Enterprise only]The accepted values (all optional) are:
----
  principal: in which JWT claim the user's email address is specified, 
             email is the default.
|<<config_dbms.security.oidc.-provider-.get_groups_from_user_info,dbms.security.oidc.<provider>.get_groups_from_user_info>>|label:enterprise-edition[Enterprise only]When turned on, Neo4j gets the groups from the provider user info endpoint.
|<<config_dbms.security.oidc.-provider-.get_username_from_user_info,dbms.security.oidc.<provider>.get_username_from_user_info>>|label:enterprise-edition[Enterprise only]When turned on, Neo4j gets the username from the provider user info endpoint.
|<<config_dbms.security.oidc.-provider-.issuer,dbms.security.oidc.<provider>.issuer>>|label:enterprise-edition[Enterprise only]The expected value of the iss claim in the id token.
|<<config_dbms.security.oidc.-provider-.jwks_uri,dbms.security.oidc.<provider>.jwks_uri>>|label:enterprise-edition[Enterprise only]The location of the JWK public key set for the identity provider.
|<<config_dbms.security.oidc.-provider-.params,dbms.security.oidc.<provider>.params>>|label:enterprise-edition[Enterprise only]The map is a semicolon separated list of key-value pairs.
|<<config_dbms.security.oidc.-provider-.token_endpoint,dbms.security.oidc.<provider>.token_endpoint>>|label:enterprise-edition[Enterprise only]The OIDC token endpoint.
|<<config_dbms.security.oidc.-provider-.token_params,dbms.security.oidc.<provider>.token_params>>|label:enterprise-edition[Enterprise only]Optional query parameters that the token endpoint requires.
|<<config_dbms.security.oidc.-provider-.user_info_uri,dbms.security.oidc.<provider>.user_info_uri>>|label:enterprise-edition[Enterprise only]The identity providers user info uri.
|<<config_dbms.security.oidc.-provider-.well_known_discovery_uri,dbms.security.oidc.<provider>.well_known_discovery_uri>>|label:enterprise-edition[Enterprise only]The 'well known' OpenID Connect Discovery endpoint used to fetch identity provider settings.
|<<config_server.cluster.catchup.connect_randomly_to_server_group,server.cluster.catchup.connect_randomly_to_server_group>>|label:enterprise-edition[Enterprise only]Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
|<<config_server.databases.default_to_read_only,server.databases.default_to_read_only>>|Whether or not any database on this instance are read_only by default.
|<<config_server.databases.read_only,server.databases.read_only>>|List of databases for which to prevent write queries.
|<<config_server.databases.writable,server.databases.writable>>|List of databases for which to allow write queries.
|<<config_server.groups,server.groups>>|label:enterprise-edition[Enterprise only]A list of tag names for the server used when configuring load balancing and replication policies.
|<<config_server.memory.pagecache.flush.buffer.enabled,server.memory.pagecache.flush.buffer.enabled>>|Page cache can be configured to use a temporal buffer for flushing purposes.
|<<config_server.memory.pagecache.flush.buffer.size_in_pages,server.memory.pagecache.flush.buffer.size_in_pages>>|Page cache can be configured to use a temporal buffer for flushing purposes.
|===

[[config_db.checkpoint.iops.limit]]
.db.checkpoint.iops.limit
[cols="<1s,<4"]
|===
|Description
a|Limit the number of IOs the background checkpoint process will consume per second. This setting is advisory, is ignored in Neo4j Community Edition, and is followed to best effort in Enterprise Edition. An IO is in this case a 8 KiB (mostly sequential) write. Limiting the write IO in this way will leave more bandwidth in the IO subsystem to service random-read IOs, which is important for the response time of queries when the database cannot fit entirely in memory. The only drawback of this setting is that longer checkpoint times may lead to slightly longer recovery times in case of a database or system crash. A lower number means lower IO pressure, and consequently longer checkpoint times. Set this to -1 to disable the IOPS limit and remove the limitation entirely; this will let the checkpointer flush data as fast as the hardware will go. Removing the setting, or commenting it out, will set the default value of 600.
|Valid values
a|db.checkpoint.iops.limit, an integer
|Dynamic a|true
|Default value
m|+++600+++
|===

[[config_db.format]]
.db.format
[cols="<1s,<4"]
|===
|Description
a|Database format. This is the format that will be used for new databases. Valid values are `standard`, `aligned`, or `high_limit`.The `aligned` format is essentially the `standard` format with some minimal padding at the end of pages such that a single record will never cross a page boundary. The `high_limit` format is available for Enterprise Edition only. It is required if you have a graph that is larger than 34 billion nodes, 34 billion relationships, or 68 billion properties.
|Valid values
a|db.format, a string
|Dynamic a|true
|Default value
m|+++aligned+++
|===

[[config_db.lock.acquisition.timeout]]
.db.lock.acquisition.timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum time interval within which lock should be acquired. Zero (default) means timeout is disabled.
|Valid values
a|db.lock.acquisition.timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_db.logs.query.early_raw_logging_enabled]]
.db.logs.query.early_raw_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log query text and parameters without obfuscating passwords. This allows queries to be logged earlier before parsing starts.
|Valid values
a|db.logs.query.early_raw_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_db.logs.query.enabled]]
.db.logs.query.enabled
[cols="<1s,<4"]
|===
|Description
a|Log executed queries. Valid values are `OFF`, `INFO`, or `VERBOSE`.

`OFF`::  no logging.
`INFO`:: log queries at the end of execution, that take longer than the configured threshold, `<<config_db.logs.query.threshold,db.logs.query.threshold>>`.
`VERBOSE`:: log queries at the start and end of execution, regardless of `<<config_db.logs.query.threshold,db.logs.query.threshold>>`.

Log entries are written to the query log.

This feature is available in the Neo4j Enterprise Edition.
|Valid values
a|db.logs.query.enabled, one of [OFF, INFO, VERBOSE]
|Dynamic a|true
|Default value
m|+++VERBOSE+++
|===

[[config_db.logs.query.max_parameter_length]]
.db.logs.query.max_parameter_length
[cols="<1s,<4"]
|===
|Description
a|Sets a maximum character length use for each parameter in the log. This only takes effect if `<<config_db.logs.query.parameter_logging_enabled,db.logs.query.parameter_logging_enabled>> = true`.
|Valid values
a|db.logs.query.max_parameter_length, an integer
|Dynamic a|true
|Default value
m|+++2147483647+++
|===

[[config_db.logs.query.obfuscate_literals]]
.db.logs.query.obfuscate_literals
[cols="<1s,<4"]
|===
|Description
a|Obfuscates all literals of the query before writing to the log. Note that node labels, relationship types and map property keys are still shown. Changing the setting will not affect queries that are cached. So, if you want the switch to have immediate effect, you must also call `CALL db.clearQueryCaches()`.
|Valid values
a|db.logs.query.obfuscate_literals, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_db.logs.query.parameter_logging_enabled]]
.db.logs.query.parameter_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log parameters for the executed queries being logged.
|Valid values
a|db.logs.query.parameter_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_db.logs.query.plan_description_enabled]]
.db.logs.query.plan_description_enabled
[cols="<1s,<4"]
|===
|Description
a|Log query plan description table, useful for debugging purposes.
|Valid values
a|db.logs.query.plan_description_enabled, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_db.logs.query.threshold]]
.db.logs.query.threshold
[cols="<1s,<4"]
|===
|Description
a|If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO. Defaults to 0 seconds, that is all queries are logged.
|Valid values
a|db.logs.query.threshold, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_db.logs.query.transaction.enabled]]
.db.logs.query.transaction.enabled
[cols="<1s,<4"]
|===
|Description
a|Log the start and end of a transaction. Valid values are 'OFF', 'INFO', or 'VERBOSE'.
OFF:  no logging.
INFO: log start and end of transactions that take longer than the configured threshold, <<config_db.logs.query.transaction.threshold,db.logs.query.transaction.threshold>>.
VERBOSE: log start and end of all transactions.
Log entries are written to the query log.
This feature is available in the Neo4j Enterprise Edition.
|Valid values
a|db.logs.query.transaction.enabled, one of [OFF, INFO, VERBOSE]
|Dynamic a|true
|Default value
m|+++OFF+++
|===

[[config_db.logs.query.transaction.threshold]]
.db.logs.query.transaction.threshold
[cols="<1s,<4"]
|===
|Description
a|If the transaction is open for more time than this threshold, the transaction is logged once completed - provided transaction logging (<<config_db.logs.query.transaction.enabled,db.logs.query.transaction.enabled>>) is set to `INFO`. Defaults to 0 seconds (all transactions are logged).
|Valid values
a|db.logs.query.transaction.threshold, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_db.memory.transaction.max]]
.db.memory.transaction.max
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'largest possible value'.
|Valid values
a|db.memory.transaction.max, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `1.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_db.memory.transaction.total.max]]
.db.memory.transaction.total.max
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'unlimited'.
|Valid values
a|db.memory.transaction.total.max, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `10.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_db.track_query_cpu_time]]
.db.track_query_cpu_time
[cols="<1s,<4"]
|===
|Description
a|Enables or disables tracking of how much time a query spends actively executing on the CPU. Calling `SHOW TRANSACTIONS` will display the time. This can also be logged in the query log by using `db.logs.query.time_logging_enabled`.
|Valid values
a|db.track_query_cpu_time, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_db.transaction.bookmark_ready_timeout]]
.db.transaction.bookmark_ready_timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum amount of time to wait for the database state represented by the bookmark.
|Valid values
a|db.transaction.bookmark_ready_timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`) which is minimum `1s`
|Dynamic a|true
|Default value
m|+++30s+++
|===

[[config_db.transaction.concurrent.maximum]]
.db.transaction.concurrent.maximum
[cols="<1s,<4"]
|===
|Description
a|The maximum number of concurrently running transactions. If set to 0, limit is disabled.
|Valid values
a|db.transaction.concurrent.maximum, an integer
|Dynamic a|true
|Default value
m|+++1000+++
|===

[[config_db.transaction.sampling.percentage]]
.db.transaction.sampling.percentage
[cols="<1s,<4"]
|===
|Description
a|Transaction sampling percentage.
|Valid values
a|db.transaction.sampling.percentage, an integer which is in the range `1` to `100`
|Dynamic a|true
|Default value
m|+++5+++
|===

[[config_db.transaction.timeout]]
.db.transaction.timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum time interval of a transaction within which it should be completed.
|Valid values
a|db.transaction.timeout, a duration (Valid units are: `ns`, `μs`, `ms`, `s`, `m`, `h` and `d`; default unit is `s`)
|Dynamic a|true
|Default value
m|+++0s+++
|===

[[config_db.transaction.tracing.level]]
.db.transaction.tracing.level
[cols="<1s,<4"]
|===
|Description
a|Transaction creation tracing level.
|Valid values
a|db.transaction.tracing.level, one of [DISABLED, SAMPLE, ALL]
|Dynamic a|true
|Default value
m|+++DISABLED+++
|===

[[config_db.tx_log.preallocate]]
.db.tx_log.preallocate
[cols="<1s,<4"]
|===
|Description
a|Specify if Neo4j should try to preallocate logical log file in advance.
|Valid values
a|db.tx_log.preallocate, a boolean
|Dynamic a|true
|Default value
m|+++true+++
|===

[[config_db.tx_log.rotation.retention_policy]]
.db.tx_log.rotation.retention_policy
[cols="<1s,<4"]
|===
|Description
a|Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
|Valid values
a|db.tx_log.rotation.retention_policy, a string which matches the pattern `^(true{vbar}keep_all{vbar}false{vbar}keep_none{vbar}(\d+[KkMmGg]?( (files{vbar}size{vbar}txs{vbar}entries{vbar}hours{vbar}days))))$` (Must be `true` or `keep_all`, `false` or `keep_none`, or of format `<number><optional unit> <type>`. Valid units are `K`, `M` and `G`. Valid types are `files`, `size`, `txs`, `entries`, `hours` and `days`. For example, `100M size` will limit logical log space on disk to 100MB per database,and `200K txs` will limit the number of transactions kept to 200 000 per database.)
|Dynamic a|true
|Default value
m|+++2 days+++
|===

[[config_db.tx_log.rotation.size]]
.db.tx_log.rotation.size
[cols="<1s,<4"]
|===
|Description
a|Specifies at which file size the logical log will auto-rotate. Minimum accepted value is 128 KiB.
|Valid values
a|db.tx_log.rotation.size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `128.00KiB`
|Dynamic a|true
|Default value
m|+++256.00MiB+++
|===

[[config_dbms.cypher.render_plan_description]]
.dbms.cypher.render_plan_description
[cols="<1s,<4"]
|===
|Description
a|If set to `true` a textual representation of the plan description will be rendered on the server for all queries running with `EXPLAIN` or `PROFILE`. This allows clients such as the neo4j browser and Cypher shell to show a more detailed plan description.
|Valid values
a|dbms.cypher.render_plan_description, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.memory.transaction.total.max]]
.dbms.memory.transaction.total.max
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'unlimited'.
|Valid values
a|dbms.memory.transaction.total.max, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `10.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|+++0B+++
|===

[[config_dbms.routing.client_side.enforce_for_domains]]
.dbms.routing.client_side.enforce_for_domains
[cols="<1s,<4"]
|===
|Description
a|Always use client side routing (regardless of the default router) for neo4j:// protocol connections to these domains. A comma separated list of domains. Wildcards (*) are supported.
|Valid values
a|dbms.routing.client_side.enforce_for_domains, a ',' separated set with elements of type 'a string'.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.routing.reads_on_writers_enabled]]
.dbms.routing.reads_on_writers_enabled
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Configure if the `dbms.routing.getRoutingTable()` procedure should include the writer as read endpoint or return only non-writers (non writer primaries and secondaries) Note: writer is returned as read endpoint if no other member is present all.
|Valid values
a|dbms.routing.reads_on_writers_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.security.key.name]]
.dbms.security.key.name
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Name of the 256 length AES encryption key, which is used for the symmetric encryption.
|Valid values
a|dbms.security.key.name, a string
|Dynamic a|true
|Default value
m|+++aesKey+++
|===

[[config_dbms.security.keystore.password]]
.dbms.security.keystore.password
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Password for accessing the keystore holding a 256 length AES encryption key, which is used for the symmetric encryption.
|Valid values
a|dbms.security.keystore.password, a secure string
|Dynamic a|true
|===

[[config_dbms.security.keystore.path]]
.dbms.security.keystore.path
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Location of the keystore holding a 256 length AES encryption key, which is used for the symmetric encryption of secrets held in system database.
|Valid values
a|dbms.security.keystore.path, a path
|Dynamic a|true
|===

[[config_dbms.security.ldap.authentication.attribute]]
.dbms.security.ldap.authentication.attribute
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The attribute to use when looking up users.
Using this setting requires `dbms.security.ldap.authentication.search_for_attribute` to be true and thus `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` to be configured.
|Valid values
a|dbms.security.ldap.authentication.attribute, a string which matches the pattern `[A-Za-z0-9-]*` (has to be a valid LDAP attribute name, only containing letters [A-Za-z], digits [0-9] and hyphens [-].)
|Dynamic a|true
|Default value
m|+++samaccountname+++
|===

[[config_dbms.security.ldap.authentication.user_dn_template]]
.dbms.security.ldap.authentication.user_dn_template
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]LDAP user DN template. An LDAP object is referenced by its distinguished name (DN), and a user DN is an LDAP fully-qualified unique user identifier. This setting is used to generate an LDAP DN that conforms with the LDAP directory's schema from the user principal that is submitted with the authentication token when logging in. The special token {0} is a placeholder where the user principal will be substituted into the DN string.
|Valid values
a|dbms.security.ldap.authentication.user_dn_template, a string which Must be a string containing '{0}' to understand where to insert the runtime authentication principal.
|Dynamic a|true
|Default value
m|+++uid={0},ou=users,dc=example,dc=com+++
|===

[[config_dbms.security.ldap.authorization.access_permitted_group]]
.dbms.security.ldap.authorization.access_permitted_group
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The LDAP group to which a user must belong to get any access to the system.Set this to restrict access to a subset of LDAP users belonging to a particular group. If this is not set, any user to successfully authenticate via LDAP will have access to the PUBLIC role and any other roles assigned to them via <<config_dbms.security.ldap.authorization.group_to_role_mapping,dbms.security.ldap.authorization.group_to_role_mapping>>.
|Valid values
a|dbms.security.ldap.authorization.access_permitted_group, a string
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.security.ldap.authorization.group_membership_attributes]]
.dbms.security.ldap.authorization.group_membership_attributes
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]A list of attribute names on a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled. This setting is ignored when `dbms.ldap_authorization_nested_groups_enabled` is `true`.
|Valid values
a|dbms.security.ldap.authorization.group_membership_attributes, a ',' separated list with elements of type 'a string'. which Can not be empty
|Dynamic a|true
|Default value
m|+++memberOf+++
|===

[[config_dbms.security.ldap.authorization.group_to_role_mapping]]
.dbms.security.ldap.authorization.group_to_role_mapping
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]An authorization mapping from LDAP group names to Neo4j role names. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the LDAP group name and the value is a comma separated list of corresponding role names. For example: group1=role1;group2=role2;group3=role3,role4,role5
You could also use whitespaces and quotes around group names to make this mapping more readable, for example: 
----
`dbms.security.ldap.authorization.group_to_role_mapping`=\
         "cn=Neo4j Read Only,cn=users,dc=example,dc=com"      = reader;    \
         "cn=Neo4j Read-Write,cn=users,dc=example,dc=com"     = publisher; \
         "cn=Neo4j Schema Manager,cn=users,dc=example,dc=com" = architect; \
         "cn=Neo4j Administrator,cn=users,dc=example,dc=com"  = admin
----
|Valid values
a|dbms.security.ldap.authorization.group_to_role_mapping, a string which must be semicolon separated list of key-value pairs or empty
|Dynamic a|true
|Default value
m|++++++
|===

[[config_dbms.security.ldap.authorization.nested_groups_enabled]]
.dbms.security.ldap.authorization.nested_groups_enabled
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]This setting determines whether multiple LDAP search results will be processed (as is required for the lookup of nested groups). If set to `true` then instead of using attributes on the user object to determine group membership (as specified by `<<config_dbms.security.ldap.authorization.group_membership_attributes,dbms.security.ldap.authorization.group_membership_attributes>>`), the `user` object will only be used to determine the user's Distinguished Name, which will subsequently be used with  `<<config_dbms.security.ldap.authorization.user_search_filter,dbms.security.ldap.authorization.user_search_filter>>` in order to perform a nested group search. The Distinguished Names of the resultant group search results will be used to determine roles.
|Valid values
a|dbms.security.ldap.authorization.nested_groups_enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.security.ldap.authorization.nested_groups_search_filter]]
.dbms.security.ldap.authorization.nested_groups_search_filter
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The search template which will be used to find the nested groups which the user is a member of. The filter should contain the placeholder token `{0}` which will be substituted with the user's Distinguished Name (which is found for the specified user principle using `<<config_dbms.security.ldap.authorization.user_search_filter,dbms.security.ldap.authorization.user_search_filter>>`). The default value specifies Active Directory's LDAP_MATCHING_RULE_IN_CHAIN (aka 1.2.840.113556.1.4.1941) implementation which will walk the ancestry of group membership for the specified user.
|Valid values
a|dbms.security.ldap.authorization.nested_groups_search_filter, a string
|Dynamic a|true
|Default value
m|+++(&(objectclass=group)(member:1.2.840.113556.1.4.1941:={0}))+++
|===

[[config_dbms.security.ldap.authorization.user_search_base]]
.dbms.security.ldap.authorization.user_search_base
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The name of the base object or named context to search for user objects when LDAP authorization is enabled. A common case is that this matches the last part of `<<config_dbms.security.ldap.authentication.user_dn_template,dbms.security.ldap.authentication.user_dn_template>>`.
|Valid values
a|dbms.security.ldap.authorization.user_search_base, a string which Can not be empty
|Dynamic a|true
|Default value
m|+++ou=users,dc=example,dc=com+++
|===

[[config_dbms.security.ldap.authorization.user_search_filter]]
.dbms.security.ldap.authorization.user_search_filter
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The LDAP search filter to search for a user principal when LDAP authorization is enabled. The filter should contain the placeholder token {0} which will be substituted for the user principal.
|Valid values
a|dbms.security.ldap.authorization.user_search_filter, a string
|Dynamic a|true
|Default value
m|+++(&(objectClass=*)(uid={0}))+++
|===

[[config_dbms.security.oidc.-provider-.audience]]
.dbms.security.oidc.<provider>.audience
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Expected values of the Audience (aud) claim in the id token.
|Valid values
a|dbms.security.oidc.<provider>.audience, a ',' separated list with elements of type 'a string'. which Can not be empty
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.auth_endpoint]]
.dbms.security.oidc.<provider>.auth_endpoint
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The OIDC authorization endpoint. If this is not supplied Neo4j will attempt to discover it from the well_known_discovery_uri.
|Valid values
a|dbms.security.oidc.<provider>.auth_endpoint, a URI
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.auth_flow]]
.dbms.security.oidc.<provider>.auth_flow
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The OIDC flow to use. This is exposed to clients via the discovery endpoint. Supported values are `pkce` and `implicit`
|Valid values
a|dbms.security.oidc.<provider>.auth_flow, one of [PKCE, IMPLICIT]
|Dynamic a|true
|Default value
m|+++PKCE+++
|===

[[config_dbms.security.oidc.-provider-.auth_params]]
.dbms.security.oidc.<provider>.auth_params
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Optional additional parameters that the auth endpoint requires. Please use params instead. The map is a semicolon separated list of key-value pairs. For example: `k1=v1;k2=v2`.
|Valid values
a|dbms.security.oidc.<provider>.auth_params, A simple key value map pattern `k1=v1;k2=v2`.
|Dynamic a|true
|Default value
m|+++{}+++
|Deprecated
a|The `dbms.security.oidc.<provider>.auth_params` configuration setting has been deprecated.
|===

[[config_dbms.security.oidc.-provider-.authorization.group_to_role_mapping]]
.dbms.security.oidc.<provider>.authorization.group_to_role_mapping
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]An authorization mapping from IdP group names to Neo4j role names. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the IdP group name and the value is a comma separated list of corresponding role names. For example: group1=role1;group2=role2;group3=role3,role4,role5
You could also use whitespaces and quotes around group names to make this mapping more readable, for example: 
----
dbms.security.oidc.<provider>.authorization.group_to_role_mapping=\
         "Neo4j Read Only"      = reader;    \
         "Neo4j Read-Write"     = publisher; \
         "Neo4j Schema Manager" = architect; \
         "Neo4j Administrator"  = admin
----
|Valid values
a|dbms.security.oidc.<provider>.authorization.group_to_role_mapping, a string which must be semicolon separated list of key-value pairs or empty
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.claims.groups]]
.dbms.security.oidc.<provider>.claims.groups
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The claim to use as the list of groups in Neo4j. These could be Neo4J roles directly, or can be mapped using dbms.security.oidc.<provider>.authorization.group_to_role_mapping.
|Valid values
a|dbms.security.oidc.<provider>.claims.groups, a string
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.claims.username]]
.dbms.security.oidc.<provider>.claims.username
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The claim to use as the username in Neo4j. This would typically be sub, but in some situations it may be be desirable to use something else such as email.
|Valid values
a|dbms.security.oidc.<provider>.claims.username, a string
|Dynamic a|true
|Default value
m|+++sub+++
|===

[[config_dbms.security.oidc.-provider-.client_id]]
.dbms.security.oidc.<provider>.client_id
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Client id needed if token contains multiple Audience (aud) claims.
|Valid values
a|dbms.security.oidc.<provider>.client_id, a string
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.config]]
.dbms.security.oidc.<provider>.config
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The accepted values (all optional) are:
----
  principal: in which JWT claim the user's email address is specified, 
             email is the default. This is the value that will be shown in browser.
  code_challenge_method: default is `S256` and it's the only supported method
                         at this moment. This setting applies only for pkce auth flow
  token_type_principal: the options are almost always either access_token, 
                        which is the default, or id_token.
  token_type_authentication: the options are almost always either access_token, 
                             which is the default, or id_token.
  implicit_flow_requires_nonce: true or false. Defaults to false.
----
|Valid values
a|dbms.security.oidc.<provider>.config, A simple key value map pattern `k1=v1;k2=v2`. Valid key options are: `[principal, code_challenge_method, implicit_flow_requires_nonce, token_type_authentication, token_type_principal]`.
|Dynamic a|true
|Default value
m|+++{}+++
|===

[[config_dbms.security.oidc.-provider-.get_groups_from_user_info]]
.dbms.security.oidc.<provider>.get_groups_from_user_info
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]When turned on, Neo4j gets the groups from the provider user info endpoint.
|Valid values
a|dbms.security.oidc.<provider>.get_groups_from_user_info, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.security.oidc.-provider-.get_username_from_user_info]]
.dbms.security.oidc.<provider>.get_username_from_user_info
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]When turned on, Neo4j gets the username from the provider user info endpoint.
|Valid values
a|dbms.security.oidc.<provider>.get_username_from_user_info, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_dbms.security.oidc.-provider-.issuer]]
.dbms.security.oidc.<provider>.issuer
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The expected value of the iss claim in the id token. If this is not supplied Neo4j will attempt to discover it from the well_known_discovery_uri.
|Valid values
a|dbms.security.oidc.<provider>.issuer, a string
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.jwks_uri]]
.dbms.security.oidc.<provider>.jwks_uri
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The location of the JWK public key set for the identity provider. If this is not supplied Neo4j will attempt to discover it from the well_known_discovery_uri.
|Valid values
a|dbms.security.oidc.<provider>.jwks_uri, a URI
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.params]]
.dbms.security.oidc.<provider>.params
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The map is a semicolon separated list of key-value pairs. For example: `k1=v1;k2=v2`.
The user should at least provide:
----
  client_id: the SSO Idp client idenfifier.
  response_type: code if auth_flow is pkce or token for implicit auth_flow.
  scope: often containing a subset of 'email profile openid groups'.
----
For example: `client_id=my-client-id;response_type=code;scope=openid profile email`.
|Valid values
a|dbms.security.oidc.<provider>.params, A simple key value map pattern `k1=v1;k2=v2`. Required key options are: `[scope, client_id, response_type]`.
|Dynamic a|true
|Default value
m|+++{}+++
|===

[[config_dbms.security.oidc.-provider-.token_endpoint]]
.dbms.security.oidc.<provider>.token_endpoint
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The OIDC token endpoint. If this is not supplied Neo4j will attempt to discover it from the well_known_discovery_uri.
|Valid values
a|dbms.security.oidc.<provider>.token_endpoint, a URI
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.token_params]]
.dbms.security.oidc.<provider>.token_params
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Optional query parameters that the token endpoint requires. The map is a semicolon separated list of key-value pairs. For example: `k1=v1;k2=v2`.If the token endpoint requires a client_secret then this parameter should contain `client_secret=super-secret`
|Valid values
a|dbms.security.oidc.<provider>.token_params, A simple key value map pattern `k1=v1;k2=v2`.
|Dynamic a|true
|Default value
m|+++{}+++
|===

[[config_dbms.security.oidc.-provider-.user_info_uri]]
.dbms.security.oidc.<provider>.user_info_uri
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The identity providers user info uri.
|Valid values
a|dbms.security.oidc.<provider>.user_info_uri, a URI
|Dynamic a|true
|===

[[config_dbms.security.oidc.-provider-.well_known_discovery_uri]]
.dbms.security.oidc.<provider>.well_known_discovery_uri
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]The 'well known' OpenID Connect Discovery endpoint used to fetch identity provider settings. If not provided, `issuer`, `jwks_uri`, `auth_endpoint` should be present. If the auth_flow is pkce, `token_endpoint` should also be provided.
|Valid values
a|dbms.security.oidc.<provider>.well_known_discovery_uri, a URI
|Dynamic a|true
|===

[[config_server.cluster.catchup.connect_randomly_to_server_group]]
.server.cluster.catchup.connect_randomly_to_server_group
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`server.cluster.catchup.upstream_strategy`) includes the value `connect-randomly-to-server-group`.
|Valid values
a|server.cluster.catchup.connect_randomly_to_server_group, a ',' separated list with elements of type 'a string identifying a Server Tag'.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_server.databases.default_to_read_only]]
.server.databases.default_to_read_only
[cols="<1s,<4"]
|===
|Description
a|Whether or not any database on this instance are read_only by default. If false, individual databases may be marked as read_only using server.database.read_only. If true, individual databases may be marked as writable using <<config_server.databases.writable,server.databases.writable>>.
|Valid values
a|server.databases.default_to_read_only, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_server.databases.read_only]]
.server.databases.read_only
[cols="<1s,<4"]
|===
|Description
a|List of databases for which to prevent write queries. Databases not included in this list maybe read_only anyway depending upon the value of <<config_server.databases.default_to_read_only,server.databases.default_to_read_only>>.
|Valid values
a|server.databases.read_only, a ',' separated set with elements of type 'A valid database name containing only alphabetic characters, numbers, dots and dashes with a length between 3 and 63 characters, starting with an alphabetic character but not with the name 'system''. which Value 'system' can't be included in read only databases collection!
|Dynamic a|true
|Default value
m|++++++
|===

[[config_server.databases.writable]]
.server.databases.writable
[cols="<1s,<4"]
|===
|Description
a|List of databases for which to allow write queries. Databases not included in this list will allow write queries anyway, unless <<config_server.databases.default_to_read_only,server.databases.default_to_read_only>> is set to true.
|Valid values
a|server.databases.writable, a ',' separated set with elements of type 'A valid database name containing only alphabetic characters, numbers, dots and dashes with a length between 3 and 63 characters, starting with an alphabetic character but not with the name 'system''.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_server.groups]]
.server.groups
[cols="<1s,<4"]
|===
|Description
a|label:enterprise-edition[Enterprise only]A list of tag names for the server used when configuring load balancing and replication policies.
|Valid values
a|server.groups, a ',' separated list with elements of type 'a string identifying a Server Tag'.
|Dynamic a|true
|Default value
m|++++++
|===

[[config_server.memory.pagecache.flush.buffer.enabled]]
.server.memory.pagecache.flush.buffer.enabled
[cols="<1s,<4"]
|===
|Description
a|Page cache can be configured to use a temporal buffer for flushing purposes. It is used to combine, if possible, sequence of several cache pages into one bigger buffer to minimize the number of individual IOPS performed and better utilization of available I/O resources, especially when those are restricted.
|Valid values
a|server.memory.pagecache.flush.buffer.enabled, a boolean
|Dynamic a|true
|Default value
m|+++false+++
|===

[[config_server.memory.pagecache.flush.buffer.size_in_pages]]
.server.memory.pagecache.flush.buffer.size_in_pages
[cols="<1s,<4"]
|===
|Description
a|Page cache can be configured to use a temporal buffer for flushing purposes. It is used to combine, if possible, sequence of several cache pages into one bigger buffer to minimize the number of individual IOPS performed and better utilization of available I/O resources, especially when those are restricted. Use this setting to configure individual file flush buffer size in pages (8KiB). To be able to utilize this buffer during page cache flushing, buffered flush should be enabled.
|Valid values
a|server.memory.pagecache.flush.buffer.size_in_pages, an integer which is in the range `1` to `512`
|Dynamic a|true
|Default value
m|+++128+++
|===

